
Convex Optimization





Convex Optimization

Stephen Boyd

Department of Electrical Engineering

Stanford University

Lieven Vandenberghe

Electrical Engineering Department

University of California, Los Angeles



cambridge university press

Cambridge, New York, Melbourne, Madrid, Cape Town, Singapore, Sa˜o Paolo, Delhi

Cambridge University Press
The Edinburgh Building, Cambridge, CB2 8RU, UK

Published in the United States of America by Cambridge University Press, New York

http://www.cambridge.org
Information on this title: www.cambridge.org/9780521833783

c© Cambridge University Press 2004
This publication is in copyright. Subject to statutory exception
and to the provisions of relevant collective licensing agreements,
no reproduction of any part may take place without
the written permission of Cambridge University Press.

First published 2004
Seventh printing with corrections 2009

Printed in the United Kingdom at the University Press, Cambridge

A catalogue record for this publication is available from the British Library

Library of Congress Cataloguing-in-Publication data

Boyd, Stephen P.
Convex Optimization / Stephen Boyd & Lieven Vandenberghe
p. cm.

Includes bibliographical references and index.
ISBN 0 521 83378 7
1. Mathematical optimization. 2. Convex functions. I. Vandenberghe, Lieven. II. Title.

QA402.5.B69 2004
519.6–dc22 2003063284

ISBN 978-0-521-83378-3 hardback

Cambridge University Press has no responsiblity for the persistency or accuracy of URLs

for external or third-party internet websites referred to in this publication, and does not

guarantee that any content on such websites is, or will remain, accurate or appropriate.



For

Anna, Nicholas, and Nora

Danie¨l and Margriet





Contents

Preface xi

1 Introduction 1

1.1 Mathematical optimization . . . . . . . . . . . . . . . . . . . . . . . . 1

1.2 Least-squares and linear programming . . . . . . . . . . . . . . . . . . 4

1.3 Convex optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7

1.4 Nonlinear optimization . . . . . . . . . . . . . . . . . . . . . . . . . . 9

1.5 Outline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11

1.6 Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16

I Theory 19

2 Convex sets 21

2.1 Affine and convex sets . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

2.2 Some important examples . . . . . . . . . . . . . . . . . . . . . . . . . 27

2.3 Operations that preserve convexity . . . . . . . . . . . . . . . . . . . . 35

2.4 Generalized inequalities . . . . . . . . . . . . . . . . . . . . . . . . . . 43

2.5 Separating and supporting hyperplanes . . . . . . . . . . . . . . . . . . 46

2.6 Dual cones and generalized inequalities . . . . . . . . . . . . . . . . . . 51

Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59

Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60

3 Convex functions 67

3.1 Basic properties and examples . . . . . . . . . . . . . . . . . . . . . . 67

3.2 Operations that preserve convexity . . . . . . . . . . . . . . . . . . . . 79

3.3 The conjugate function . . . . . . . . . . . . . . . . . . . . . . . . . . 90

3.4 Quasiconvex functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 95

3.5 Log-concave and log-convex functions . . . . . . . . . . . . . . . . . . 104

3.6 Convexity with respect to generalized inequalities . . . . . . . . . . . . 108

Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112

Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113



viii Contents

4 Convex optimization problems 127

4.1 Optimization problems . . . . . . . . . . . . . . . . . . . . . . . . . . 127

4.2 Convex optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136

4.3 Linear optimization problems . . . . . . . . . . . . . . . . . . . . . . . 146

4.4 Quadratic optimization problems . . . . . . . . . . . . . . . . . . . . . 152

4.5 Geometric programming . . . . . . . . . . . . . . . . . . . . . . . . . . 160

4.6 Generalized inequality constraints . . . . . . . . . . . . . . . . . . . . . 167

4.7 Vector optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174

Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188

Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189

5 Duality 215

5.1 The Lagrange dual function . . . . . . . . . . . . . . . . . . . . . . . . 215

5.2 The Lagrange dual problem . . . . . . . . . . . . . . . . . . . . . . . . 223

5.3 Geometric interpretation . . . . . . . . . . . . . . . . . . . . . . . . . 232

5.4 Saddle-point interpretation . . . . . . . . . . . . . . . . . . . . . . . . 237

5.5 Optimality conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . 241

5.6 Perturbation and sensitivity analysis . . . . . . . . . . . . . . . . . . . 249

5.7 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253

5.8 Theorems of alternatives . . . . . . . . . . . . . . . . . . . . . . . . . 258

5.9 Generalized inequalities . . . . . . . . . . . . . . . . . . . . . . . . . . 264

Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272

Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273

II Applications 289

6 Approximation and fitting 291

6.1 Norm approximation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291

6.2 Least-norm problems . . . . . . . . . . . . . . . . . . . . . . . . . . . 302

6.3 Regularized approximation . . . . . . . . . . . . . . . . . . . . . . . . 305

6.4 Robust approximation . . . . . . . . . . . . . . . . . . . . . . . . . . . 318

6.5 Function fitting and interpolation . . . . . . . . . . . . . . . . . . . . . 324

Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 343

Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 344

7 Statistical estimation 351

7.1 Parametric distribution estimation . . . . . . . . . . . . . . . . . . . . 351

7.2 Nonparametric distribution estimation . . . . . . . . . . . . . . . . . . 359

7.3 Optimal detector design and hypothesis testing . . . . . . . . . . . . . 364

7.4 Chebyshev and Chernoff bounds . . . . . . . . . . . . . . . . . . . . . 374

7.5 Experiment design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 384

Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 392

Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393



Contents ix

8 Geometric problems 397

8.1 Projection on a set . . . . . . . . . . . . . . . . . . . . . . . . . . . . 397

8.2 Distance between sets . . . . . . . . . . . . . . . . . . . . . . . . . . . 402

8.3 Euclidean distance and angle problems . . . . . . . . . . . . . . . . . . 405

8.4 Extremal volume ellipsoids . . . . . . . . . . . . . . . . . . . . . . . . 410

8.5 Centering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 416

8.6 Classification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 422

8.7 Placement and location . . . . . . . . . . . . . . . . . . . . . . . . . . 432

8.8 Floor planning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 438

Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 446

Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 447

III Algorithms 455

9 Unconstrained minimization 457

9.1 Unconstrained minimization problems . . . . . . . . . . . . . . . . . . 457

9.2 Descent methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 463

9.3 Gradient descent method . . . . . . . . . . . . . . . . . . . . . . . . . 466

9.4 Steepest descent method . . . . . . . . . . . . . . . . . . . . . . . . . 475

9.5 Newton’s method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 484

9.6 Self-concordance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 496

9.7 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 508

Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 513

Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 514

10 Equality constrained minimization 521

10.1 Equality constrained minimization problems . . . . . . . . . . . . . . . 521

10.2 Newton’s method with equality constraints . . . . . . . . . . . . . . . . 525

10.3 Infeasible start Newton method . . . . . . . . . . . . . . . . . . . . . . 531

10.4 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 542

Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 556

Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 557

11 Interior-point methods 561

11.1 Inequality constrained minimization problems . . . . . . . . . . . . . . 561

11.2 Logarithmic barrier function and central path . . . . . . . . . . . . . . 562

11.3 The barrier method . . . . . . . . . . . . . . . . . . . . . . . . . . . . 568

11.4 Feasibility and phase I methods . . . . . . . . . . . . . . . . . . . . . . 579

11.5 Complexity analysis via self-concordance . . . . . . . . . . . . . . . . . 585

11.6 Problems with generalized inequalities . . . . . . . . . . . . . . . . . . 596

11.7 Primal-dual interior-point methods . . . . . . . . . . . . . . . . . . . . 609

11.8 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 615

Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 621

Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 623



x Contents

Appendices 631

A Mathematical background 633
A.1 Norms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 633
A.2 Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 637
A.3 Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 639
A.4 Derivatives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 640
A.5 Linear algebra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 645
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 652

B Problems involving two quadratic functions 653
B.1 Single constraint quadratic optimization . . . . . . . . . . . . . . . . . 653
B.2 The S-procedure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 655
B.3 The field of values of two symmetric matrices . . . . . . . . . . . . . . 656
B.4 Proofs of the strong duality results . . . . . . . . . . . . . . . . . . . . 657
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 659

C Numerical linear algebra background 661
C.1 Matrix structure and algorithm complexity . . . . . . . . . . . . . . . . 661
C.2 Solving linear equations with factored matrices . . . . . . . . . . . . . . 664
C.3 LU, Cholesky, and LDLT factorization . . . . . . . . . . . . . . . . . . 668
C.4 Block elimination and Schur complements . . . . . . . . . . . . . . . . 672
C.5 Solving underdetermined linear equations . . . . . . . . . . . . . . . . . 681
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 684

References 685

Notation 697

Index 701



Preface

This book is about convex optimization, a special class of mathematical optimiza-
tion problems, which includes least-squares and linear programming problems. It
is well known that least-squares and linear programming problems have a fairly
complete theory, arise in a variety of applications, and can be solved numerically
very efficiently. The basic point of this book is that the same can be said for the
larger class of convex optimization problems.

While the mathematics of convex optimization has been studied for about a
century, several related recent developments have stimulated new interest in the
topic. The first is the recognition that interior-point methods, developed in the
1980s to solve linear programming problems, can be used to solve convex optimiza-
tion problems as well. These new methods allow us to solve certain new classes
of convex optimization problems, such as semidefinite programs and second-order
cone programs, almost as easily as linear programs.

The second development is the discovery that convex optimization problems
(beyond least-squares and linear programs) are more prevalent in practice than
was previously thought. Since 1990 many applications have been discovered in
areas such as automatic control systems, estimation and signal processing, com-
munications and networks, electronic circuit design, data analysis and modeling,
statistics, and finance. Convex optimization has also found wide application in com-
binatorial optimization and global optimization, where it is used to find bounds on
the optimal value, as well as approximate solutions. We believe that many other
applications of convex optimization are still waiting to be discovered.

There are great advantages to recognizing or formulating a problem as a convex
optimization problem. The most basic advantage is that the problem can then be
solved, very reliably and efficiently, using interior-point methods or other special
methods for convex optimization. These solution methods are reliable enough to be
embedded in a computer-aided design or analysis tool, or even a real-time reactive
or automatic control system. There are also theoretical or conceptual advantages
of formulating a problem as a convex optimization problem. The associated dual
problem, for example, often has an interesting interpretation in terms of the original
problem, and sometimes leads to an efficient or distributed method for solving it.

We think that convex optimization is an important enough topic that everyone
who uses computational mathematics should know at least a little bit about it.
In our opinion, convex optimization is a natural next topic after advanced linear
algebra (topics like least-squares, singular values), and linear programming.



xii Preface

Goal of this book

For many general purpose optimization methods, the typical approach is to just
try out the method on the problem to be solved. The full benefits of convex
optimization, in contrast, only come when the problem is known ahead of time to
be convex. Of course, many optimization problems are not convex, and it can be
difficult to recognize the ones that are, or to reformulate a problem so that it is
convex.

Our main goal is to help the reader develop a working knowledge of
convex optimization, i.e., to develop the skills and background needed
to recognize, formulate, and solve convex optimization problems.

Developing a working knowledge of convex optimization can be mathematically
demanding, especially for the reader interested primarily in applications. In our
experience (mostly with graduate students in electrical engineering and computer
science), the investment often pays off well, and sometimes very well.

There are several books on linear programming, and general nonlinear pro-
gramming, that focus on problem formulation, modeling, and applications. Several
other books cover the theory of convex optimization, or interior-point methods and
their complexity analysis. This book is meant to be something in between, a book
on general convex optimization that focuses on problem formulation and modeling.

We should also mention what this book is not. It is not a text primarily about
convex analysis, or the mathematics of convex optimization; several existing texts
cover these topics well. Nor is the book a survey of algorithms for convex optimiza-
tion. Instead we have chosen just a few good algorithms, and describe only simple,
stylized versions of them (which, however, do work well in practice). We make no
attempt to cover the most recent state of the art in interior-point (or other) meth-
ods for solving convex problems. Our coverage of numerical implementation issues
is also highly simplified, but we feel that it is adequate for the potential user to
develop working implementations, and we do cover, in some detail, techniques for
exploiting structure to improve the efficiency of the methods. We also do not cover,
in more than a simplified way, the complexity theory of the algorithms we describe.
We do, however, give an introduction to the important ideas of self-concordance
and complexity analysis for interior-point methods.

Audience

This book is meant for the researcher, scientist, or engineer who uses mathemat-
ical optimization, or more generally, computational mathematics. This includes,
naturally, those working directly in optimization and operations research, and also
many others who use optimization, in fields like computer science, economics, fi-
nance, statistics, data mining, and many fields of science and engineering. Our
primary focus is on the latter group, the potential users of convex optimization,
and not the (less numerous) experts in the field of convex optimization.

The only background required of the reader is a good knowledge of advanced
calculus and linear algebra. If the reader has seen basic mathematical analysis (e.g.,
norms, convergence, elementary topology), and basic probability theory, he or she
should be able to follow every argument and discussion in the book. We hope that



Preface xiii

readers who have not seen analysis and probability, however, can still get all of the
essential ideas and important points. Prior exposure to numerical computing or
optimization is not needed, since we develop all of the needed material from these
areas in the text or appendices.

Using this book in courses

We hope that this book will be useful as the primary or alternate textbook for
several types of courses. Since 1995 we have been using drafts of this book for
graduate courses on linear, nonlinear, and convex optimization (with engineering
applications) at Stanford and UCLA. We are able to cover most of the material,
though not in detail, in a one quarter graduate course. A one semester course allows
for a more leisurely pace, more applications, more detailed treatment of theory,
and perhaps a short student project. A two quarter sequence allows an expanded
treatment of the more basic topics such as linear and quadratic programming (which
are very useful for the applications oriented student), or a more substantial student
project.

This book can also be used as a reference or alternate text for a more traditional
course on linear and nonlinear optimization, or a course on control systems (or
other applications area), that includes some coverage of convex optimization. As
the secondary text in a more theoretically oriented course on convex optimization,
it can be used as a source of simple practical examples.

Acknowledgments

We have been developing the material for this book for almost a decade. Over the
years we have benefited from feedback and suggestions from many people, including
our own graduate students, students in our courses, and our colleagues at Stanford,
UCLA, and elsewhere. Unfortunately, space limitations and shoddy record keeping
do not allow us to name everyone who has contributed. However, we wish to
particularly thank A. Aggarwal, V. Balakrishnan, A. Bernard, B. Bray, R. Cottle,
A. d’Aspremont, J. Dahl, J. Dattorro, D. Donoho, J. Doyle, L. El Ghaoui, P. Glynn,
M. Grant, A. Hansson, T. Hastie, A. Lewis, M. Lobo, Z.-Q. Luo, M. Mesbahi, W.
Naylor, P. Parrilo, I. Pressman, R. Tibshirani, B. Van Roy, L. Xiao, and Y. Ye.
J. Jalden and A. d’Aspremont contributed the time-frequency analysis example
in §6.5.4, and the consumer preference bounding example in §6.5.5, respectively.
P. Parrilo suggested exercises 4.4 and 4.56. Newer printings benefited greatly from
Igal Sason’s meticulous reading of the book.

We want to single out two others for special acknowledgment. Arkadi Ne-
mirovski incited our original interest in convex optimization, and encouraged us
to write this book. We also want to thank Kishan Baheti for playing a critical
role in the development of this book. In 1994 he encouraged us to apply for a Na-
tional Science Foundation combined research and curriculum development grant,
on convex optimization with engineering applications, and this book is a direct (if
delayed) consequence.

Stephen Boyd Stanford, California
Lieven Vandenberghe Los Angeles, California





Chapter 1

Introduction

In this introduction we give an overview of mathematical optimization, focusing on
the special role of convex optimization. The concepts introduced informally here
will be covered in later chapters, with more care and technical detail.

1.1 Mathematical optimization

A mathematical optimization problem, or just optimization problem, has the form

minimize f0(x)
subject to fi(x) ≤ bi, i = 1, . . . ,m. (1.1)

Here the vector x = (x1, . . . , xn) is the optimization variable of the problem, the
function f0 : R

n → R is the objective function, the functions fi : Rn → R,
i = 1, . . . ,m, are the (inequality) constraint functions, and the constants b1, . . . , bm
are the limits, or bounds, for the constraints. A vector x⋆ is called optimal, or a
solution of the problem (1.1), if it has the smallest objective value among all vectors
that satisfy the constraints: for any z with f1(z) ≤ b1, . . . , fm(z) ≤ bm, we have
f0(z) ≥ f0(x⋆).

We generally consider families or classes of optimization problems, characterized
by particular forms of the objective and constraint functions. As an important
example, the optimization problem (1.1) is called a linear program if the objective
and constraint functions f0, . . . , fm are linear, i.e., satisfy

fi(αx+ βy) = αfi(x) + βfi(y) (1.2)

for all x, y ∈ Rn and all α, β ∈ R. If the optimization problem is not linear, it is
called a nonlinear program.

This book is about a class of optimization problems called convex optimiza-
tion problems. A convex optimization problem is one in which the objective and
constraint functions are convex, which means they satisfy the inequality

fi(αx+ βy) ≤ αfi(x) + βfi(y) (1.3)



2 1 Introduction

for all x, y ∈ Rn and all α, β ∈ R with α+ β = 1, α ≥ 0, β ≥ 0. Comparing (1.3)
and (1.2), we see that convexity is more general than linearity: inequality replaces
the more restrictive equality, and the inequality must hold only for certain values
of α and β. Since any linear program is therefore a convex optimization problem,
we can consider convex optimization to be a generalization of linear programming.

1.1.1 Applications

The optimization problem (1.1) is an abstraction of the problem of making the best
possible choice of a vector in Rn from a set of candidate choices. The variable x
represents the choice made; the constraints fi(x) ≤ bi represent firm requirements
or specifications that limit the possible choices, and the objective value f0(x) rep-
resents the cost of choosing x. (We can also think of −f0(x) as representing the
value, or utility, of choosing x.) A solution of the optimization problem (1.1) corre-
sponds to a choice that has minimum cost (or maximum utility), among all choices
that meet the firm requirements.

In portfolio optimization, for example, we seek the best way to invest some
capital in a set of n assets. The variable xi represents the investment in the ith
asset, so the vector x ∈ Rn describes the overall portfolio allocation across the set of
assets. The constraints might represent a limit on the budget (i.e., a limit on the
total amount to be invested), the requirement that investments are nonnegative
(assuming short positions are not allowed), and a minimum acceptable value of
expected return for the whole portfolio. The objective or cost function might be
a measure of the overall risk or variance of the portfolio return. In this case,
the optimization problem (1.1) corresponds to choosing a portfolio allocation that
minimizes risk, among all possible allocations that meet the firm requirements.

Another example is device sizing in electronic design, which is the task of choos-
ing the width and length of each device in an electronic circuit. Here the variables
represent the widths and lengths of the devices. The constraints represent a va-
riety of engineering requirements, such as limits on the device sizes imposed by
the manufacturing process, timing requirements that ensure that the circuit can
operate reliably at a specified speed, and a limit on the total area of the circuit. A
common objective in a device sizing problem is the total power consumed by the
circuit. The optimization problem (1.1) is to find the device sizes that satisfy the
design requirements (on manufacturability, timing, and area) and are most power
efficient.

In data fitting, the task is to find a model, from a family of potential models,
that best fits some observed data and prior information. Here the variables are the
parameters in the model, and the constraints can represent prior information or
required limits on the parameters (such as nonnegativity). The objective function
might be a measure of misfit or prediction error between the observed data and
the values predicted by the model, or a statistical measure of the unlikeliness or
implausibility of the parameter values. The optimization problem (1.1) is to find
the model parameter values that are consistent with the prior information, and give
the smallest misfit or prediction error with the observed data (or, in a statistical



1.1 Mathematical optimization 3

framework, are most likely).

An amazing variety of practical problems involving decision making (or system
design, analysis, and operation) can be cast in the form of a mathematical opti-
mization problem, or some variation such as a multicriterion optimization problem.
Indeed, mathematical optimization has become an important tool in many areas.
It is widely used in engineering, in electronic design automation, automatic con-
trol systems, and optimal design problems arising in civil, chemical, mechanical,
and aerospace engineering. Optimization is used for problems arising in network
design and operation, finance, supply chain management, scheduling, and many
other areas. The list of applications is still steadily expanding.

For most of these applications, mathematical optimization is used as an aid to
a human decision maker, system designer, or system operator, who supervises the
process, checks the results, and modifies the problem (or the solution approach)
when necessary. This human decision maker also carries out any actions suggested
by the optimization problem, e.g., buying or selling assets to achieve the optimal
portfolio.

A relatively recent phenomenon opens the possibility of many other applications
for mathematical optimization. With the proliferation of computers embedded in
products, we have seen a rapid growth in embedded optimization. In these em-
bedded applications, optimization is used to automatically make real-time choices,
and even carry out the associated actions, with no (or little) human intervention or
oversight. In some application areas, this blending of traditional automatic control
systems and embedded optimization is well under way; in others, it is just start-
ing. Embedded real-time optimization raises some new challenges: in particular,
it requires solution methods that are extremely reliable, and solve problems in a
predictable amount of time (and memory).

1.1.2 Solving optimization problems

A solution method for a class of optimization problems is an algorithm that com-
putes a solution of the problem (to some given accuracy), given a particular problem
from the class, i.e., an instance of the problem. Since the late 1940s, a large effort
has gone into developing algorithms for solving various classes of optimization prob-
lems, analyzing their properties, and developing good software implementations.
The effectiveness of these algorithms, i.e., our ability to solve the optimization prob-
lem (1.1), varies considerably, and depends on factors such as the particular forms
of the objective and constraint functions, how many variables and constraints there
are, and special structure, such as sparsity. (A problem is sparse if each constraint
function depends on only a small number of the variables).

Even when the objective and constraint functions are smooth (for example,
polynomials) the general optimization problem (1.1) is surprisingly difficult to solve.
Approaches to the general problem therefore involve some kind of compromise, such
as very long computation time, or the possibility of not finding the solution. Some
of these methods are discussed in §1.4.

There are, however, some important exceptions to the general rule that most
optimization problems are difficult to solve. For a few problem classes we have



4 1 Introduction

effective algorithms that can reliably solve even large problems, with hundreds or
thousands of variables and constraints. Two important and well known examples,
described in §1.2 below (and in detail in chapter 4), are least-squares problems and
linear programs. It is less well known that convex optimization is another exception
to the rule: Like least-squares or linear programming, there are very effective
algorithms that can reliably and efficiently solve even large convex problems.

1.2 Least-squares and linear programming

In this section we describe two very widely known and used special subclasses of
convex optimization: least-squares and linear programming. (A complete technical
treatment of these problems will be given in chapter 4.)

1.2.1 Least-squares problems

A least-squares problem is an optimization problem with no constraints (i.e., m =
0) and an objective which is a sum of squares of terms of the form aTi x− bi:

minimize f0(x) = ‖Ax− b‖22 =
∑k

i=1(a
T
i x− bi)2. (1.4)

Here A ∈ Rk×n (with k ≥ n), aTi are the rows of A, and the vector x ∈ Rn is the
optimization variable.

Solving least-squares problems

The solution of a least-squares problem (1.4) can be reduced to solving a set of
linear equations,

(ATA)x = AT b,

so we have the analytical solution x = (ATA)−1AT b. For least-squares problems
we have good algorithms (and software implementations) for solving the problem to
high accuracy, with very high reliability. The least-squares problem can be solved
in a time approximately proportional to n2k, with a known constant. A current
desktop computer can solve a least-squares problem with hundreds of variables, and
thousands of terms, in a few seconds; more powerful computers, of course, can solve
larger problems, or the same size problems, faster. (Moreover, these solution times
will decrease exponentially in the future, according to Moore’s law.) Algorithms
and software for solving least-squares problems are reliable enough for embedded
optimization.

In many cases we can solve even larger least-squares problems, by exploiting
some special structure in the coefficient matrix A. Suppose, for example, that the
matrix A is sparse, which means that it has far fewer than kn nonzero entries. By
exploiting sparsity, we can usually solve the least-squares problem much faster than
order n2k. A current desktop computer can solve a sparse least-squares problem



1.2 Least-squares and linear programming 5

with tens of thousands of variables, and hundreds of thousands of terms, in around
a minute (although this depends on the particular sparsity pattern).

For extremely large problems (say, with millions of variables), or for problems
with exacting real-time computing requirements, solving a least-squares problem
can be a challenge. But in the vast majority of cases, we can say that existing
methods are very effective, and extremely reliable. Indeed, we can say that solving
least-squares problems (that are not on the boundary of what is currently achiev-
able) is a (mature) technology, that can be reliably used by many people who do
not know, and do not need to know, the details.

Using least-squares

The least-squares problem is the basis for regression analysis, optimal control, and
many parameter estimation and data fitting methods. It has a number of statistical
interpretations, e.g., as maximum likelihood estimation of a vector x, given linear
measurements corrupted by Gaussian measurement errors.

Recognizing an optimization problem as a least-squares problem is straightfor-
ward; we only need to verify that the objective is a quadratic function (and then
test whether the associated quadratic form is positive semidefinite). While the
basic least-squares problem has a simple fixed form, several standard techniques
are used to increase its flexibility in applications.

In weighted least-squares, the weighted least-squares cost

k∑
i=1

wi(a
T
i x− bi)2,

where w1, . . . , wk are positive, is minimized. (This problem is readily cast and
solved as a standard least-squares problem.) Here the weights wi are chosen to
reflect differing levels of concern about the sizes of the terms aTi x − bi, or simply
to influence the solution. In a statistical setting, weighted least-squares arises
in estimation of a vector x, given linear measurements corrupted by errors with
unequal variances.

Another technique in least-squares is regularization, in which extra terms are
added to the cost function. In the simplest case, a positive multiple of the sum of
squares of the variables is added to the cost function:

k∑
i=1

(aTi x− bi)2 + ρ
n∑
i=1

x2i ,

where ρ > 0. (This problem too can be formulated as a standard least-squares
problem.) The extra terms penalize large values of x, and result in a sensible
solution in cases when minimizing the first sum only does not. The parameter ρ is
chosen by the user to give the right trade-off between making the original objective
function

∑k
i=1(a

T
i x−bi)2 small, while keeping

∑n
i=1 x

2
i not too big. Regularization

comes up in statistical estimation when the vector x to be estimated is given a prior
distribution.

Weighted least-squares and regularization are covered in chapter 6; their sta-
tistical interpretations are given in chapter 7.



6 1 Introduction

1.2.2 Linear programming

Another important class of optimization problems is linear programming, in which
the objective and all constraint functions are linear:

minimize cTx
subject to aTi x ≤ bi, i = 1, . . . ,m. (1.5)

Here the vectors c, a1, . . . , am ∈ Rn and scalars b1, . . . , bm ∈ R are problem pa-
rameters that specify the objective and constraint functions.

Solving linear programs

There is no simple analytical formula for the solution of a linear program (as there
is for a least-squares problem), but there are a variety of very effective methods for
solving them, including Dantzig’s simplex method, and the more recent interior-
point methods described later in this book. While we cannot give the exact number
of arithmetic operations required to solve a linear program (as we can for least-
squares), we can establish rigorous bounds on the number of operations required
to solve a linear program, to a given accuracy, using an interior-point method. The
complexity in practice is order n2m (assuming m ≥ n) but with a constant that is
less well characterized than for least-squares. These algorithms are quite reliable,
although perhaps not quite as reliable as methods for least-squares. We can easily
solve problems with hundreds of variables and thousands of constraints on a small
desktop computer, in a matter of seconds. If the problem is sparse, or has some
other exploitable structure, we can often solve problems with tens or hundreds of
thousands of variables and constraints.

As with least-squares problems, it is still a challenge to solve extremely large
linear programs, or to solve linear programs with exacting real-time computing re-
quirements. But, like least-squares, we can say that solving (most) linear programs
is a mature technology. Linear programming solvers can be (and are) embedded in
many tools and applications.

Using linear programming

Some applications lead directly to linear programs in the form (1.5), or one of
several other standard forms. In many other cases the original optimization prob-
lem does not have a standard linear program form, but can be transformed to an
equivalent linear program (and then, of course, solved) using techniques covered in
detail in chapter 4.

As a simple example, consider the Chebyshev approximation problem:

minimize maxi=1,...,k |aTi x− bi|. (1.6)

Here x ∈ Rn is the variable, and a1, . . . , ak ∈ Rn, b1, . . . , bk ∈ R are parameters
that specify the problem instance. Note the resemblance to the least-squares prob-
lem (1.4). For both problems, the objective is a measure of the size of the terms
aTi x − bi. In least-squares, we use the sum of squares of the terms as objective,
whereas in Chebyshev approximation, we use the maximum of the absolute values.



1.3 Convex optimization 7

One other important distinction is that the objective function in the Chebyshev
approximation problem (1.6) is not differentiable; the objective in the least-squares
problem (1.4) is quadratic, and therefore differentiable.

The Chebyshev approximation problem (1.6) can be solved by solving the linear
program

minimize t
subject to aTi x− t ≤ bi, i = 1, . . . , k

−aTi x− t ≤ −bi, i = 1, . . . , k,
(1.7)

with variables x ∈ Rn and t ∈ R. (The details will be given in chapter 6.)
Since linear programs are readily solved, the Chebyshev approximation problem is
therefore readily solved.

Anyone with a working knowledge of linear programming would recognize the
Chebyshev approximation problem (1.6) as one that can be reduced to a linear
program. For those without this background, though, it might not be obvious that
the Chebyshev approximation problem (1.6), with its nondifferentiable objective,
can be formulated and solved as a linear program.

While recognizing problems that can be reduced to linear programs is more
involved than recognizing a least-squares problem, it is a skill that is readily ac-
quired, since only a few standard tricks are used. The task can even be partially
automated; some software systems for specifying and solving optimization prob-
lems can automatically recognize (some) problems that can be reformulated as
linear programs.

1.3 Convex optimization

A convex optimization problem is one of the form

minimize f0(x)
subject to fi(x) ≤ bi, i = 1, . . . ,m, (1.8)

where the functions f0, . . . , fm : R
n → R are convex, i.e., satisfy

fi(αx+ βy) ≤ αfi(x) + βfi(y)

for all x, y ∈ Rn and all α, β ∈ R with α+β = 1, α ≥ 0, β ≥ 0. The least-squares
problem (1.4) and linear programming problem (1.5) are both special cases of the
general convex optimization problem (1.8).

1.3.1 Solving convex optimization problems

There is in general no analytical formula for the solution of convex optimization
problems, but (as with linear programming problems) there are very effective meth-
ods for solving them. Interior-point methods work very well in practice, and in some
cases can be proved to solve the problem to a specified accuracy with a number of



8 1 Introduction

operations that does not exceed a polynomial of the problem dimensions. (This is
covered in chapter 11.)

We will see that interior-point methods can solve the problem (1.8) in a num-
ber of steps or iterations that is almost always in the range between 10 and 100.
Ignoring any structure in the problem (such as sparsity), each step requires on the
order of

max{n3, n2m,F}

operations, where F is the cost of evaluating the first and second derivatives of the
objective and constraint functions f0, . . . , fm.

Like methods for solving linear programs, these interior-point methods are quite
reliable. We can easily solve problems with hundreds of variables and thousands
of constraints on a current desktop computer, in at most a few tens of seconds. By
exploiting problem structure (such as sparsity), we can solve far larger problems,
with many thousands of variables and constraints.

We cannot yet claim that solving general convex optimization problems is a
mature technology, like solving least-squares or linear programming problems. Re-
search on interior-point methods for general nonlinear convex optimization is still
a very active research area, and no consensus has emerged yet as to what the best
method or methods are. But it is reasonable to expect that solving general con-
vex optimization problems will become a technology within a few years. And for
some subclasses of convex optimization problems, for example second-order cone
programming or geometric programming (studied in detail in chapter 4), it is fair
to say that interior-point methods are approaching a technology.

1.3.2 Using convex optimization

Using convex optimization is, at least conceptually, very much like using least-
squares or linear programming. If we can formulate a problem as a convex opti-
mization problem, then we can solve it efficiently, just as we can solve a least-squares
problem efficiently. With only a bit of exaggeration, we can say that, if you formu-
late a practical problem as a convex optimization problem, then you have solved
the original problem.

There are also some important differences. Recognizing a least-squares problem
is straightforward, but recognizing a convex function can be difficult. In addition,
there are many more tricks for transforming convex problems than for transforming
linear programs. Recognizing convex optimization problems, or those that can
be transformed to convex optimization problems, can therefore be challenging.
The main goal of this book is to give the reader the background needed to do
this. Once the skill of recognizing or formulating convex optimization problems is
developed, you will find that surprisingly many problems can be solved via convex
optimization.

The challenge, and art, in using convex optimization is in recognizing and for-
mulating the problem. Once this formulation is done, solving the problem is, like
least-squares or linear programming, (almost) technology.



1.4 Nonlinear optimization 9

1.4 Nonlinear optimization

Nonlinear optimization (or nonlinear programming) is the term used to describe
an optimization problem when the objective or constraint functions are not linear,
but not known to be convex. Sadly, there are no effective methods for solving
the general nonlinear programming problem (1.1). Even simple looking problems
with as few as ten variables can be extremely challenging, while problems with a
few hundreds of variables can be intractable. Methods for the general nonlinear
programming problem therefore take several different approaches, each of which
involves some compromise.

1.4.1 Local optimization

In local optimization, the compromise is to give up seeking the optimal x, which
minimizes the objective over all feasible points. Instead we seek a point that is
only locally optimal, which means that it minimizes the objective function among
feasible points that are near it, but is not guaranteed to have a lower objective
value than all other feasible points. A large fraction of the research on general
nonlinear programming has focused on methods for local optimization, which as a
consequence are well developed.

Local optimization methods can be fast, can handle large-scale problems, and
are widely applicable, since they only require differentiability of the objective and
constraint functions. As a result, local optimization methods are widely used in
applications where there is value in finding a good point, if not the very best. In
an engineering design application, for example, local optimization can be used to
improve the performance of a design originally obtained by manual, or other, design
methods.

There are several disadvantages of local optimization methods, beyond (possi-
bly) not finding the true, globally optimal solution. The methods require an initial
guess for the optimization variable. This initial guess or starting point is critical,
and can greatly affect the objective value of the local solution obtained. Little
information is provided about how far from (globally) optimal the local solution
is. Local optimization methods are often sensitive to algorithm parameter values,
which may need to be adjusted for a particular problem, or family of problems.

Using a local optimization method is trickier than solving a least-squares prob-
lem, linear program, or convex optimization problem. It involves experimenting
with the choice of algorithm, adjusting algorithm parameters, and finding a good
enough initial guess (when one instance is to be solved) or a method for producing
a good enough initial guess (when a family of problems is to be solved). Roughly
speaking, local optimization methods are more art than technology. Local opti-
mization is a well developed art, and often very effective, but it is nevertheless an
art. In contrast, there is little art involved in solving a least-squares problem or
a linear program (except, of course, those on the boundary of what is currently
possible).

An interesting comparison can be made between local optimization methods for
nonlinear programming, and convex optimization. Since differentiability of the ob-



10 1 Introduction

jective and constraint functions is the only requirement for most local optimization
methods, formulating a practical problem as a nonlinear optimization problem is
relatively straightforward. The art in local optimization is in solving the problem
(in the weakened sense of finding a locally optimal point), once it is formulated.
In convex optimization these are reversed: The art and challenge is in problem
formulation; once a problem is formulated as a convex optimization problem, it is
relatively straightforward to solve it.

1.4.2 Global optimization

In global optimization, the true global solution of the optimization problem (1.1)
is found; the compromise is efficiency. The worst-case complexity of global opti-
mization methods grows exponentially with the problem sizes n and m; the hope
is that in practice, for the particular problem instances encountered, the method is
far faster. While this favorable situation does occur, it is not typical. Even small
problems, with a few tens of variables, can take a very long time (e.g., hours or
days) to solve.

Global optimization is used for problems with a small number of variables, where
computing time is not critical, and the value of finding the true global solution is
very high. One example from engineering design is worst-case analysis or verifica-
tion of a high value or safety-critical system. Here the variables represent uncertain
parameters, that can vary during manufacturing, or with the environment or op-
erating condition. The objective function is a utility function, i.e., one for which
smaller values are worse than larger values, and the constraints represent prior
knowledge about the possible parameter values. The optimization problem (1.1) is
the problem of finding the worst-case values of the parameters. If the worst-case
value is acceptable, we can certify the system as safe or reliable (with respect to
the parameter variations).

A local optimization method can rapidly find a set of parameter values that
is bad, but not guaranteed to be the absolute worst possible. If a local optimiza-
tion method finds parameter values that yield unacceptable performance, it has
succeeded in determining that the system is not reliable. But a local optimization
method cannot certify the system as reliable; it can only fail to find bad parameter
values. A global optimization method, in contrast, will find the absolute worst val-
ues of the parameters, and if the associated performance is acceptable, can certify
the system as safe. The cost is computation time, which can be very large, even
for a relatively small number of parameters. But it may be worth it in cases where
the value of certifying the performance is high, or the cost of being wrong about
the reliability or safety is high.

1.4.3 Role of convex optimization in nonconvex problems

In this book we focus primarily on convex optimization problems, and applications
that can be reduced to convex optimization problems. But convex optimization
also plays an important role in problems that are not convex.



1.5 Outline 11

Initialization for local optimization

One obvious use is to combine convex optimization with a local optimization
method. Starting with a nonconvex problem, we first find an approximate, but
convex, formulation of the problem. By solving this approximate problem, which
can be done easily and without an initial guess, we obtain the exact solution to the
approximate convex problem. This point is then used as the starting point for a
local optimization method, applied to the original nonconvex problem.

Convex heuristics for nonconvex optimization

Convex optimization is the basis for several heuristics for solving nonconvex prob-
lems. One interesting example we will see is the problem of finding a sparse vector
x (i.e., one with few nonzero entries) that satisfies some constraints. While this is
a difficult combinatorial problem, there are some simple heuristics, based on con-
vex optimization, that often find fairly sparse solutions. (These are described in
chapter 6.)

Another broad example is given by randomized algorithms, in which an ap-
proximate solution to a nonconvex problem is found by drawing some number of
candidates from a probability distribution, and taking the best one found as the
approximate solution. Now suppose the family of distributions from which we will
draw the candidates is parametrized, e.g., by its mean and covariance. We can then
pose the question, which of these distributions gives us the smallest expected value
of the objective? It turns out that this problem is sometimes a convex problem,
and therefore efficiently solved. (See, e.g., exercise 11.23.)

Bounds for global optimization

Many methods for global optimization require a cheaply computable lower bound
on the optimal value of the nonconvex problem. Two standard methods for doing
this are based on convex optimization. In relaxation, each nonconvex constraint
is replaced with a looser, but convex, constraint. In Lagrangian relaxation, the
Lagrangian dual problem (described in chapter 5) is solved. This problem is convex,
and provides a lower bound on the optimal value of the nonconvex problem.

1.5 Outline

The book is divided into three main parts, titled Theory, Applications, and Algo-
rithms.

1.5.1 Part I: Theory

In part I, Theory, we cover basic definitions, concepts, and results from convex
analysis and convex optimization. We make no attempt to be encyclopedic, and
skew our selection of topics toward those that we think are useful in recognizing



12 1 Introduction

and formulating convex optimization problems. This is classical material, almost
all of which can be found in other texts on convex analysis and optimization. We
make no attempt to give the most general form of the results; for that the reader
can refer to any of the standard texts on convex analysis.

Chapters 2 and 3 cover convex sets and convex functions, respectively. We
give some common examples of convex sets and functions, as well as a number of
convex calculus rules, i.e., operations on sets and functions that preserve convexity.
Combining the basic examples with the convex calculus rules allows us to form
(or perhaps more importantly, recognize) some fairly complicated convex sets and
functions.

In chapter 4, Convex optimization problems, we give a careful treatment of op-
timization problems, and describe a number of transformations that can be used to
reformulate problems. We also introduce some common subclasses of convex opti-
mization, such as linear programming and geometric programming, and the more
recently developed second-order cone programming and semidefinite programming.

Chapter 5 covers Lagrangian duality, which plays a central role in convex opti-
mization. Here we give the classical Karush-Kuhn-Tucker conditions for optimality,
and a local and global sensitivity analysis for convex optimization problems.

1.5.2 Part II: Applications

In part II, Applications, we describe a variety of applications of convex optimization,
in areas like probability and statistics, computational geometry, and data fitting.
We have described these applications in a way that is accessible, we hope, to a broad
audience. To keep each application short, we consider only simple cases, sometimes
adding comments about possible extensions. We are sure that our treatment of
some of the applications will cause experts to cringe, and we apologize to them
in advance. But our goal is to convey the flavor of the application, quickly and
to a broad audience, and not to give an elegant, theoretically sound, or complete
treatment. Our own backgrounds are in electrical engineering, in areas like control
systems, signal processing, and circuit analysis and design. Although we include
these topics in the courses we teach (using this book as the main text), only a few
of these applications are broadly enough accessible to be included here.

The aim of part II is to show the reader, by example, how convex optimization
can be applied in practice.

1.5.3 Part III: Algorithms

In part III, Algorithms, we describe numerical methods for solving convex opti-
mization problems, focusing on Newton’s algorithm and interior-point methods.
Part III is organized as three chapters, which cover unconstrained optimization,
equality constrained optimization, and inequality constrained optimization, respec-
tively. These chapters follow a natural hierarchy, in which solving a problem is
reduced to solving a sequence of simpler problems. Quadratic optimization prob-
lems (including, e.g., least-squares) form the base of the hierarchy; they can be



1.5 Outline 13

solved exactly by solving a set of linear equations. Newton’s method, developed in
chapters 9 and 10, is the next level in the hierarchy. In Newton’s method, solving
an unconstrained or equality constrained problem is reduced to solving a sequence
of quadratic problems. In chapter 11, we describe interior-point methods, which
form the top level of the hierarchy. These methods solve an inequality constrained
problem by solving a sequence of unconstrained, or equality constrained, problems.

Overall we cover just a handful of algorithms, and omit entire classes of good
methods, such as quasi-Newton, conjugate-gradient, bundle, and cutting-plane al-
gorithms. For the methods we do describe, we give simplified variants, and not the
latest, most sophisticated versions. Our choice of algorithms was guided by several
criteria. We chose algorithms that are simple (to describe and implement), but
also reliable and robust, and effective and fast enough for most problems.

Many users of convex optimization end up using (but not developing) standard
software, such as a linear or semidefinite programming solver. For these users, the
material in part III is meant to convey the basic flavor of the methods, and give
some ideas of their basic attributes. For those few who will end up developing new
algorithms, we think that part III serves as a good introduction.

1.5.4 Appendices

There are three appendices. The first lists some basic facts from mathematics that
we use, and serves the secondary purpose of setting out our notation. The second
appendix covers a fairly particular topic, optimization problems with quadratic
objective and one quadratic constraint. These are nonconvex problems that never-
theless can be effectively solved, and we use the results in several of the applications
described in part II.

The final appendix gives a brief introduction to numerical linear algebra, con-
centrating on methods that can exploit problem structure, such as sparsity, to gain
efficiency. We do not cover a number of important topics, including roundoff analy-
sis, or give any details of the methods used to carry out the required factorizations.
These topics are covered by a number of excellent texts.

1.5.5 Comments on examples

In many places in the text (but particularly in parts II and III, which cover ap-
plications and algorithms, respectively) we illustrate ideas using specific examples.
In some cases, the examples are chosen (or designed) specifically to illustrate our
point; in other cases, the examples are chosen to be ‘typical’. This means that the
examples were chosen as samples from some obvious or simple probability distri-
bution. The dangers of drawing conclusions about algorithm performance from a
few tens or hundreds of randomly generated examples are well known, so we will
not repeat them here. These examples are meant only to give a rough idea of al-
gorithm performance, or a rough idea of how the computational effort varies with
problem dimensions, and not as accurate predictors of algorithm performance. In
particular, your results may vary from ours.



14 1 Introduction

1.5.6 Comments on exercises

Each chapter concludes with a set of exercises. Some involve working out the de-
tails of an argument or claim made in the text. Others focus on determining, or
establishing, convexity of some given sets, functions, or problems; or more gener-
ally, convex optimization problem formulation. Some chapters include numerical
exercises, which require some (but not much) programming in an appropriate high
level language. The difficulty level of the exercises is mixed, and varies without
warning from quite straightforward to rather tricky.

1.6 Notation

Our notation is more or less standard, with a few exceptions. In this section we
describe our basic notation; a more complete list appears on page 697.

We useR to denote the set of real numbers, R+ to denote the set of nonnegative
real numbers, and R++ to denote the set of positive real numbers. The set of real
n-vectors is denoted Rn, and the set of real m× n matrices is denoted Rm×n. We
delimit vectors and matrices with square brackets, with the components separated
by space. We use parentheses to construct column vectors from comma separated
lists. For example, if a, b, c ∈ R, we have

(a, b, c) =

 ab
c

 = [ a b c ]T ,
which is an element of R3. The symbol 1 denotes a vector all of whose components
are one (with dimension determined from context). The notation xi can refer to
the ith component of the vector x, or to the ith element of a set or sequence of
vectors x1, x2, . . .. The context, or the text, makes it clear which is meant.

We use Sk to denote the set of symmetric k × k matrices, Sk+ to denote the
set of symmetric positive semidefinite k × k matrices, and Sk++ to denote the set
of symmetric positive definite k × k matrices. The curled inequality symbol �
(and its strict form ≻) is used to denote generalized inequality: between vectors,
it represents componentwise inequality; between symmetric matrices, it represents
matrix inequality. With a subscript, the symbol �K (or ≺K) denotes generalized
inequality with respect to the cone K (explained in §2.4.1).

Our notation for describing functions deviates a bit from standard notation,
but we hope it will cause no confusion. We use the notation f : Rp → Rq to mean
that f is an Rq-valued function on some subset of Rp, specifically, its domain,
which we denote dom f . We can think of our use of the notation f : Rp → Rq as
a declaration of the function type, as in a computer language: f : Rp → Rq means
that the function f takes as argument a real p-vector, and returns a real q-vector.
The set dom f , the domain of the function f , specifies the subset of Rp of points
x for which f(x) is defined. As an example, we describe the logarithm function
as log : R → R, with dom log = R++. The notation log : R → R means that



1.6 Notation 15

the logarithm function accepts and returns a real number; dom log = R++ means
that the logarithm is defined only for positive numbers.

We use Rn as a generic finite-dimensional vector space. We will encounter
several other finite-dimensional vector spaces, e.g., the space of polynomials of a
variable with a given maximum degree, or the space Sk of symmetric k×k matrices.
By identifying a basis for a vector space, we can always identify it with Rn (where
n is its dimension), and therefore the generic results, stated for the vector space
Rn, can be applied. We usually leave it to the reader to translate general results
or statements to other vector spaces. For example, any linear function f : Rn → R
can be represented in the form f(x) = cTx, where c ∈ Rn. The corresponding
statement for the vector space Sk can be found by choosing a basis and translating.
This results in the statement: any linear function f : Sk → R can be represented
in the form f(X) = tr(CX), where C ∈ Sk.



16 1 Introduction

Bibliography

Least-squares is a very old subject; see, for example, the treatise written (in Latin) by
Gauss in the 1820s, and recently translated by Stewart [Gau95]. More recent work in-
cludes the books by Lawson and Hanson [LH95] and Bjo¨rck [Bjo¨96]. References on linear
programming can be found in chapter 4.

There are many good texts on local methods for nonlinear programming, including Gill,
Murray, and Wright [GMW81], Nocedal and Wright [NW99], Luenberger [Lue84], and
Bertsekas [Ber99].

Global optimization is covered in the books by Horst and Pardalos [HP94], Pinter [Pin95],
and Tuy [Tuy98]. Using convex optimization to find bounds for nonconvex problems is
an active research topic, and addressed in the books above on global optimization, the
book by Ben-Tal and Nemirovski [BTN01, §4.3], and the survey by Nesterov, Wolkowicz,
and Ye [NWY00]. Some notable papers on this subject are Goemans and Williamson
[GW95], Nesterov [Nes00, Nes98], Ye [Ye99], and Parrilo [Par03]. Randomized methods
are discussed in Motwani and Raghavan [MR95].

Convex analysis, the mathematics of convex sets, functions, and optimization problems, is
a well developed subfield of mathematics. Basic references include the books by Rockafel-
lar [Roc70], Hiriart-Urruty and Lemare´chal [HUL93, HUL01], Borwein and Lewis [BL00],
and Bertsekas, Nedic´, and Ozdaglar [Ber03]. More references on convex analysis can be
found in chapters 2–5.

Nesterov and Nemirovski [NN94] were the first to point out that interior-point methods
can solve many convex optimization problems; see also the references in chapter 11. The
book by Ben-Tal and Nemirovski [BTN01] covers modern convex optimization, interior-
point methods, and applications.

Solution methods for convex optimization that we do not cover in this book include
subgradient methods [Sho85], bundle methods [HUL93], cutting-plane methods [Kel60,
EM75, GLY96], and the ellipsoid method [Sho91, BGT81].

The idea that convex optimization problems are tractable is not new. It has long been rec-
ognized that the theory of convex optimization is far more straightforward (and complete)
than the theory of general nonlinear optimization. In this context Rockafellar stated, in
his 1993 SIAM Review survey paper [Roc93],

In fact the great watershed in optimization isn’t between linearity and nonlin-
earity, but convexity and nonconvexity.

The first formal argument that convex optimization problems are easier to solve than
general nonlinear optimization problems was made by Nemirovski and Yudin, in their
1983 book Problem Complexity and Method Efficiency in Optimization [NY83]. They
showed that the information-based complexity of convex optimization problems is far
lower than that of general nonlinear optimization problems. A more recent book on this
topic is Vavasis [Vav91].

The low (theoretical) complexity of interior-point methods is integral to modern research
in this area. Much of the research focuses on proving that an interior-point (or other)
method can solve some class of convex optimization problems with a number of operations
that grows no faster than a polynomial of the problem dimensions and log(1/ǫ), where
ǫ > 0 is the required accuracy. (We will see some simple results like these in chapter 11.)
The first comprehensive work on this topic is the book by Nesterov and Nemirovski
[NN94]. Other books include Ben-Tal and Nemirovski [BTN01, lecture 5] and Renegar
[Ren01]. The polynomial-time complexity of interior-point methods for various convex
optimization problems is in marked contrast to the situation for a number of nonconvex
optimization problems, for which all known algorithms require, in the worst case, a number
of operations that is exponential in the problem dimensions.



Bibliography 17

Convex optimization has been used in many applications areas, too numerous to cite
here. Convex analysis is central in economics and finance, where it is the basis of many
results. For example the separating hyperplane theorem, together with a no-arbitrage
assumption, is used to deduce the existence of prices and risk-neutral probabilities (see,
e.g., Luenberger [Lue95, Lue98] and Ross [Ros99]). Convex optimization, especially our
ability to solve semidefinite programs, has recently received particular attention in au-
tomatic control theory. Applications of convex optimization in control theory can be
found in the books by Boyd and Barratt [BB91], Boyd, El Ghaoui, Feron, and Balakrish-
nan [BEFB94], Dahleh and Diaz-Bobillo [DDB95], El Ghaoui and Niculescu [EN00], and
Dullerud and Paganini [DP00]. A good example of embedded (convex) optimization is
model predictive control, an automatic control technique that requires the solution of a
(convex) quadratic program at each step. Model predictive control is now widely used in
the chemical process control industry; see Morari and Zafirou [MZ89]. Another applica-
tions area where convex optimization (and especially, geometric programming) has a long
history is electronic circuit design. Research papers on this topic include Fishburn and
Dunlop [FD85], Sapatnekar, Rao, Vaidya, and Kang [SRVK93], and Hershenson, Boyd,
and Lee [HBL01]. Luo [Luo03] gives a survey of applications in signal processing and
communications. More references on applications of convex optimization can be found in
chapters 4 and 6–8.

High quality implementations of recent interior-point methods for convex optimization
problems are available in the LOQO [Van97] and MOSEK [MOS02] software packages,
and the codes listed in chapter 11. Software systems for specifying optimization prob-
lems include AMPL [FGK99] and GAMS [BKMR98]. Both provide some support for
recognizing problems that can be transformed to linear programs.





Part I

Theory





Chapter 2

Convex sets

2.1 Affine and convex sets

2.1.1 Lines and line segments

Suppose x1 6= x2 are two points in Rn. Points of the form
y = θx1 + (1− θ)x2,

where θ ∈ R, form the line passing through x1 and x2. The parameter value θ = 0
corresponds to y = x2, and the parameter value θ = 1 corresponds to y = x1.
Values of the parameter θ between 0 and 1 correspond to the (closed) line segment
between x1 and x2.

Expressing y in the form

y = x2 + θ(x1 − x2)
gives another interpretation: y is the sum of the base point x2 (corresponding
to θ = 0) and the direction x1 − x2 (which points from x2 to x1) scaled by the
parameter θ. Thus, θ gives the fraction of the way from x2 to x1 where y lies. As
θ increases from 0 to 1, the point y moves from x2 to x1; for θ > 1, the point y lies
on the line beyond x1. This is illustrated in figure 2.1.

2.1.2 Affine sets

A set C ⊆ Rn is affine if the line through any two distinct points in C lies in C,
i.e., if for any x1, x2 ∈ C and θ ∈ R, we have θx1+(1− θ)x2 ∈ C. In other words,
C contains the linear combination of any two points in C, provided the coefficients
in the linear combination sum to one.

This idea can be generalized to more than two points. We refer to a point
of the form θ1x1 + · · · + θkxk, where θ1 + · · · + θk = 1, as an affine combination
of the points x1, . . . , xk. Using induction from the definition of affine set (i.e.,
that it contains every affine combination of two points in it), it can be shown that



22 2 Convex sets

x1

x2

θ = 1.2
θ = 1

θ = 0.6

θ = 0
θ = −0.2

Figure 2.1 The line passing through x1 and x2 is described parametrically
by θx1+(1− θ)x2, where θ varies over R. The line segment between x1 and
x2, which corresponds to θ between 0 and 1, is shown darker.

an affine set contains every affine combination of its points: If C is an affine set,
x1, . . . , xk ∈ C, and θ1+ · · ·+ θk = 1, then the point θ1x1+ · · ·+ θkxk also belongs
to C.

If C is an affine set and x0 ∈ C, then the set
V = C − x0 = {x− x0 | x ∈ C}

is a subspace, i.e., closed under sums and scalar multiplication. To see this, suppose
v1, v2 ∈ V and α, β ∈ R. Then we have v1 + x0 ∈ C and v2 + x0 ∈ C, and so

αv1 + βv2 + x0 = α(v1 + x0) + β(v2 + x0) + (1− α− β)x0 ∈ C,
since C is affine, and α + β + (1 − α − β) = 1. We conclude that αv1 + βv2 ∈ V ,
since αv1 + βv2 + x0 ∈ C.

Thus, the affine set C can be expressed as

C = V + x0 = {v + x0 | v ∈ V },
i.e., as a subspace plus an offset. The subspace V associated with the affine set C
does not depend on the choice of x0, so x0 can be chosen as any point in C. We
define the dimension of an affine set C as the dimension of the subspace V = C−x0,
where x0 is any element of C.

Example 2.1 Solution set of linear equations. The solution set of a system of linear
equations, C = {x | Ax = b}, where A ∈ Rm×n and b ∈ Rm, is an affine set. To
show this, suppose x1, x2 ∈ C, i.e., Ax1 = b, Ax2 = b. Then for any θ, we have

A(θx1 + (1− θ)x2) = θAx1 + (1− θ)Ax2
= θb+ (1− θ)b
= b,

which shows that the affine combination θx1 + (1− θ)x2 is also in C. The subspace
associated with the affine set C is the nullspace of A.

We also have a converse: every affine set can be expressed as the solution set of a
system of linear equations.



2.1 Affine and convex sets 23

The set of all affine combinations of points in some set C ⊆ Rn is called the
affine hull of C, and denoted aff C:

aff C = {θ1x1 + · · ·+ θkxk | x1, . . . , xk ∈ C, θ1 + · · ·+ θk = 1}.

The affine hull is the smallest affine set that contains C, in the following sense: if
S is any affine set with C ⊆ S, then aff C ⊆ S.

2.1.3 Affine dimension and relative interior

We define the affine dimension of a set C as the dimension of its affine hull. Affine
dimension is useful in the context of convex analysis and optimization, but is not
always consistent with other definitions of dimension. As an example consider the
unit circle in R2, i.e., {x ∈ R2 | x21 + x22 = 1}. Its affine hull is all of R2, so its
affine dimension is two. By most definitions of dimension, however, the unit circle
in R2 has dimension one.

If the affine dimension of a set C ⊆ Rn is less than n, then the set lies in
the affine set aff C 6= Rn. We define the relative interior of the set C, denoted
relintC, as its interior relative to aff C:

relintC = {x ∈ C | B(x, r) ∩ aff C ⊆ C for some r > 0},

where B(x, r) = {y | ‖y − x‖ ≤ r}, the ball of radius r and center x in the norm
‖ · ‖. (Here ‖ · ‖ is any norm; all norms define the same relative interior.) We can
then define the relative boundary of a set C as clC \ relintC, where clC is the
closure of C.

Example 2.2 Consider a square in the (x1, x2)-plane in R
3, defined as

C = {x ∈ R3 | − 1 ≤ x1 ≤ 1, −1 ≤ x2 ≤ 1, x3 = 0}.

Its affine hull is the (x1, x2)-plane, i.e., aff C = {x ∈ R3 | x3 = 0}. The interior of C
is empty, but the relative interior is

relintC = {x ∈ R3 | − 1 < x1 < 1, −1 < x2 < 1, x3 = 0}.

Its boundary (in R3) is itself; its relative boundary is the wire-frame outline,

{x ∈ R3 | max{|x1|, |x2|} = 1, x3 = 0}.

2.1.4 Convex sets

A set C is convex if the line segment between any two points in C lies in C, i.e.,
if for any x1, x2 ∈ C and any θ with 0 ≤ θ ≤ 1, we have

θx1 + (1− θ)x2 ∈ C.



24 2 Convex sets

Figure 2.2 Some simple convex and nonconvex sets. Left. The hexagon,
which includes its boundary (shown darker), is convex. Middle. The kidney
shaped set is not convex, since the line segment between the two points in
the set shown as dots is not contained in the set. Right. The square contains
some boundary points but not others, and is not convex.

Figure 2.3 The convex hulls of two sets in R2. Left. The convex hull of a
set of fifteen points (shown as dots) is the pentagon (shown shaded). Right.
The convex hull of the kidney shaped set in figure 2.2 is the shaded set.

Roughly speaking, a set is convex if every point in the set can be seen by every other
point, along an unobstructed straight path between them, where unobstructed
means lying in the set. Every affine set is also convex, since it contains the entire
line between any two distinct points in it, and therefore also the line segment
between the points. Figure 2.2 illustrates some simple convex and nonconvex sets
in R2.

We call a point of the form θ1x1 + · · · + θkxk, where θ1 + · · · + θk = 1 and
θi ≥ 0, i = 1, . . . , k, a convex combination of the points x1, . . . , xk. As with affine
sets, it can be shown that a set is convex if and only if it contains every convex
combination of its points. A convex combination of points can be thought of as a
mixture or weighted average of the points, with θi the fraction of xi in the mixture.

The convex hull of a set C, denoted convC, is the set of all convex combinations
of points in C:

convC = {θ1x1 + · · ·+ θkxk | xi ∈ C, θi ≥ 0, i = 1, . . . , k, θ1 + · · ·+ θk = 1}.
As the name suggests, the convex hull convC is always convex. It is the smallest
convex set that contains C: If B is any convex set that contains C, then convC ⊆
B. Figure 2.3 illustrates the definition of convex hull.

The idea of a convex combination can be generalized to include infinite sums, in-
tegrals, and, in the most general form, probability distributions. Suppose θ1, θ2, . . .



2.1 Affine and convex sets 25

satisfy

θi ≥ 0, i = 1, 2, . . . ,
∞∑
i=1

θi = 1,

and x1, x2, . . . ∈ C, where C ⊆ Rn is convex. Then
∞∑
i=1

θixi ∈ C,

if the series converges. More generally, suppose p : Rn → R satisfies p(x) ≥ 0 for
all x ∈ C and ∫

C
p(x) dx = 1, where C ⊆ Rn is convex. Then∫

C

p(x)x dx ∈ C,

if the integral exists.

In the most general form, suppose C ⊆ Rn is convex and x is a random vector
with x ∈ C with probability one. Then Ex ∈ C. Indeed, this form includes all
the others as special cases. For example, suppose the random variable x only takes
on the two values x1 and x2, with prob(x = x1) = θ and prob(x = x2) = 1 − θ,
where 0 ≤ θ ≤ 1. Then Ex = θx1 + (1− θ)x2, and we are back to a simple convex
combination of two points.

2.1.5 Cones

A set C is called a cone, or nonnegative homogeneous, if for every x ∈ C and θ ≥ 0
we have θx ∈ C. A set C is a convex cone if it is convex and a cone, which means
that for any x1, x2 ∈ C and θ1, θ2 ≥ 0, we have

θ1x1 + θ2x2 ∈ C.

Points of this form can be described geometrically as forming the two-dimensional
pie slice with apex 0 and edges passing through x1 and x2. (See figure 2.4.)

A point of the form θ1x1 + · · · + θkxk with θ1, . . . , θk ≥ 0 is called a conic
combination (or a nonnegative linear combination) of x1, . . . , xk. If xi are in a
convex cone C, then every conic combination of xi is in C. Conversely, a set C is
a convex cone if and only if it contains all conic combinations of its elements. Like
convex (or affine) combinations, the idea of conic combination can be generalized
to infinite sums and integrals.

The conic hull of a set C is the set of all conic combinations of points in C, i.e.,

{θ1x1 + · · ·+ θkxk | xi ∈ C, θi ≥ 0, i = 1, . . . , k},

which is also the smallest convex cone that contains C (see figure 2.5).



26 2 Convex sets

0

x1

x2

Figure 2.4 The pie slice shows all points of the form θ1x1 + θ2x2, where
θ1, θ2 ≥ 0. The apex of the slice (which corresponds to θ1 = θ2 = 0) is at
0; its edges (which correspond to θ1 = 0 or θ2 = 0) pass through the points
x1 and x2.

00

Figure 2.5 The conic hulls (shown shaded) of the two sets of figure 2.3.



2.2 Some important examples 27

2.2 Some important examples

In this section we describe some important examples of convex sets which we will
encounter throughout the rest of the book. We start with some simple examples.

• The empty set ∅, any single point (i.e., singleton) {x0}, and the whole space
Rn are affine (hence, convex) subsets of Rn.

• Any line is affine. If it passes through zero, it is a subspace, hence also a
convex cone.

• A line segment is convex, but not affine (unless it reduces to a point).
• A ray, which has the form {x0 + θv | θ ≥ 0}, where v 6= 0, is convex, but not
affine. It is a convex cone if its base x0 is 0.

• Any subspace is affine, and a convex cone (hence convex).

2.2.1 Hyperplanes and halfspaces

A hyperplane is a set of the form

{x | aTx = b},
where a ∈ Rn, a 6= 0, and b ∈ R. Analytically it is the solution set of a nontrivial
linear equation among the components of x (and hence an affine set). Geometri-
cally, the hyperplane {x | aTx = b} can be interpreted as the set of points with a
constant inner product to a given vector a, or as a hyperplane with normal vector
a; the constant b ∈ R determines the offset of the hyperplane from the origin. This
geometric interpretation can be understood by expressing the hyperplane in the
form

{x | aT (x− x0) = 0},
where x0 is any point in the hyperplane (i.e., any point that satisfies a

Tx0 = b).
This representation can in turn be expressed as

{x | aT (x− x0) = 0} = x0 + a⊥,
where a⊥ denotes the orthogonal complement of a, i.e., the set of all vectors or-
thogonal to it:

a⊥ = {v | aT v = 0}.
This shows that the hyperplane consists of an offset x0, plus all vectors orthog-
onal to the (normal) vector a. These geometric interpretations are illustrated in
figure 2.6.

A hyperplane divides Rn into two halfspaces. A (closed) halfspace is a set of
the form

{x | aTx ≤ b}, (2.1)
where a 6= 0, i.e., the solution set of one (nontrivial) linear inequality. Halfspaces
are convex, but not affine. This is illustrated in figure 2.7.



28 2 Convex sets

a

x

aTx = b

x0

Figure 2.6 Hyperplane in R2, with normal vector a and a point x0 in the
hyperplane. For any point x in the hyperplane, x− x0 (shown as the darker
arrow) is orthogonal to a.

a

aTx ≥ b

aTx ≤ b

x0

Figure 2.7 A hyperplane defined by aTx = b inR2 determines two halfspaces.
The halfspace determined by aTx ≥ b (not shaded) is the halfspace extending
in the direction a. The halfspace determined by aTx ≤ b (which is shown
shaded) extends in the direction −a. The vector a is the outward normal of
this halfspace.



2.2 Some important examples 29

a

x1

x2

x0

Figure 2.8 The shaded set is the halfspace determined by aT (x − x0) ≤ 0.
The vector x1−x0 makes an acute angle with a, so x1 is not in the halfspace.
The vector x2−x0 makes an obtuse angle with a, and so is in the halfspace.

The halfspace (2.1) can also be expressed as

{x | aT (x− x0) ≤ 0}, (2.2)

where x0 is any point on the associated hyperplane, i.e., satisfies a
Tx0 = b. The

representation (2.2) suggests a simple geometric interpretation: the halfspace con-
sists of x0 plus any vector that makes an obtuse (or right) angle with the (outward
normal) vector a. This is illustrated in figure 2.8.

The boundary of the halfspace (2.1) is the hyperplane {x | aTx = b}. The set
{x | aTx < b}, which is the interior of the halfspace {x | aTx ≤ b}, is called an
open halfspace.

2.2.2 Euclidean balls and ellipsoids

A (Euclidean) ball (or just ball) in Rn has the form

B(xc, r) = {x | ‖x− xc‖2 ≤ r} = {x | (x− xc)T (x− xc) ≤ r2},

where r > 0, and ‖ · ‖2 denotes the Euclidean norm, i.e., ‖u‖2 = (uTu)1/2. The
vector xc is the center of the ball and the scalar r is its radius ; B(xc, r) consists
of all points within a distance r of the center xc. Another common representation
for the Euclidean ball is

B(xc, r) = {xc + ru | ‖u‖2 ≤ 1}.



30 2 Convex sets

xc

Figure 2.9 An ellipsoid in R2, shown shaded. The center xc is shown as a
dot, and the two semi-axes are shown as line segments.

A Euclidean ball is a convex set: if ‖x1 − xc‖2 ≤ r, ‖x2 − xc‖2 ≤ r, and
0 ≤ θ ≤ 1, then

‖θx1 + (1− θ)x2 − xc‖2 = ‖θ(x1 − xc) + (1− θ)(x2 − xc)‖2
≤ θ‖x1 − xc‖2 + (1− θ)‖x2 − xc‖2
≤ r.

(Here we use the homogeneity property and triangle inequality for ‖·‖2; see §A.1.2.)
A related family of convex sets is the ellipsoids, which have the form

E = {x | (x− xc)TP−1(x− xc) ≤ 1}, (2.3)
where P = PT ≻ 0, i.e., P is symmetric and positive definite. The vector xc ∈ Rn
is the center of the ellipsoid. The matrix P determines how far the ellipsoid extends
in every direction from xc; the lengths of the semi-axes of E are given by

√
λi, where

λi are the eigenvalues of P . A ball is an ellipsoid with P = r
2I. Figure 2.9 shows

an ellipsoid in R2.
Another common representation of an ellipsoid is

E = {xc +Au | ‖u‖2 ≤ 1}, (2.4)
where A is square and nonsingular. In this representation we can assume without
loss of generality that A is symmetric and positive definite. By taking A = P 1/2,
this representation gives the ellipsoid defined in (2.3). When the matrix A in (2.4)
is symmetric positive semidefinite but singular, the set in (2.4) is called a degenerate
ellipsoid ; its affine dimension is equal to the rank of A. Degenerate ellipsoids are
also convex.

2.2.3 Norm balls and norm cones

Suppose ‖·‖ is any norm onRn (see §A.1.2). From the general properties of norms it
can be shown that a norm ball of radius r and center xc, given by {x | ‖x−xc‖ ≤ r},
is convex. The norm cone associated with the norm ‖ · ‖ is the set

C = {(x, t) | ‖x‖ ≤ t} ⊆ Rn+1.



2.2 Some important examples 31

x1
x2

t

−1
0

1

−1

0

1
0

0.5

1

Figure 2.10 Boundary of second-order cone inR3, {(x1, x2, t) | (x21+x22)1/2 ≤
t}.

It is (as the name suggests) a convex cone.

Example 2.3 The second-order cone is the norm cone for the Euclidean norm, i.e.,

C = {(x, t) ∈ Rn+1 | ‖x‖2 ≤ t}

=

{[
x
t

] ∣∣∣∣∣
[
x
t

]T [
I 0
0 −1

][
x
t

]
≤ 0, t ≥ 0

}
.

The second-order cone is also known by several other names. It is called the quadratic
cone, since it is defined by a quadratic inequality. It is also called the Lorentz cone
or ice-cream cone. Figure 2.10 shows the second-order cone in R3.

2.2.4 Polyhedra

A polyhedron is defined as the solution set of a finite number of linear equalities
and inequalities:

P = {x | aTj x ≤ bj , j = 1, . . . ,m, cTj x = dj , j = 1, . . . , p}. (2.5)

A polyhedron is thus the intersection of a finite number of halfspaces and hyper-
planes. Affine sets (e.g., subspaces, hyperplanes, lines), rays, line segments, and
halfspaces are all polyhedra. It is easily shown that polyhedra are convex sets.
A bounded polyhedron is sometimes called a polytope, but some authors use the
opposite convention (i.e., polytope for any set of the form (2.5), and polyhedron



32 2 Convex sets

a1 a2

a3

a4

a5

P

Figure 2.11 The polyhedron P (shown shaded) is the intersection of five
halfspaces, with outward normal vectors a1, . . . . , a5.

when it is bounded). Figure 2.11 shows an example of a polyhedron defined as the
intersection of five halfspaces.

It will be convenient to use the compact notation

P = {x | Ax � b, Cx = d} (2.6)
for (2.5), where

A =

 a
T
1
...
aTm

 , C =
 c

T
1
...
cTp

 ,
and the symbol � denotes vector inequality or componentwise inequality in Rm:
u � v means ui ≤ vi for i = 1, . . . ,m.

Example 2.4 The nonnegative orthant is the set of points with nonnegative compo-
nents, i.e.,

R
n
+ = {x ∈ Rn | xi ≥ 0, i = 1, . . . , n} = {x ∈ Rn | x � 0}.

(Here R+ denotes the set of nonnegative numbers: R+ = {x ∈ R | x ≥ 0}.) The
nonnegative orthant is a polyhedron and a cone (and therefore called a polyhedral
cone).

Simplexes

Simplexes are another important family of polyhedra. Suppose the k + 1 points
v0, . . . , vk ∈ Rn are affinely independent, which means v1 − v0, . . . , vk − v0 are
linearly independent. The simplex determined by them is given by

C = conv{v0, . . . , vk} = {θ0v0 + · · ·+ θkvk | θ � 0, 1T θ = 1}, (2.7)



2.2 Some important examples 33

where 1 denotes the vector with all entries one. The affine dimension of this simplex
is k, so it is sometimes referred to as a k-dimensional simplex in Rn.

Example 2.5 Some common simplexes. A 1-dimensional simplex is a line segment;
a 2-dimensional simplex is a triangle (including its interior); and a 3-dimensional
simplex is a tetrahedron.

The unit simplex is the n-dimensional simplex determined by the zero vector and the
unit vectors, i.e., 0, e1, . . . , en ∈ Rn. It can be expressed as the set of vectors that
satisfy

x � 0, 1Tx ≤ 1.

The probability simplex is the (n − 1)-dimensional simplex determined by the unit
vectors e1, . . . , en ∈ Rn. It is the set of vectors that satisfy

x � 0, 1Tx = 1.

Vectors in the probability simplex correspond to probability distributions on a set
with n elements, with xi interpreted as the probability of the ith element.

To describe the simplex (2.7) as a polyhedron, i.e., in the form (2.6), we proceed
as follows. By definition, x ∈ C if and only if x = θ0v0+ θ1v1+ · · ·+ θkvk for some
θ � 0 with 1T θ = 1. Equivalently, if we define y = (θ1, . . . , θk) and

B =
[
v1 − v0 · · · vk − v0

] ∈ Rn×k,
we can say that x ∈ C if and only if

x = v0 +By (2.8)

for some y � 0 with 1T y ≤ 1. Now we note that affine independence of the
points v0, . . . , vk implies that the matrix B has rank k. Therefore there exists a
nonsingular matrix A = (A1, A2) ∈ Rn×n such that

AB =

[
A1
A2

]
B =

[
I
0

]
.

Multiplying (2.8) on the left with A, we obtain

A1x = A1v0 + y, A2x = A2v0.

From this we see that x ∈ C if and only if A2x = A2v0, and the vector y =
A1x−A1v0 satisfies y � 0 and 1T y ≤ 1. In other words we have x ∈ C if and only
if

A2x = A2v0, A1x � A1v0, 1TA1x ≤ 1 + 1TA1v0,
which is a set of linear equalities and inequalities in x, and so describes a polyhe-
dron.



34 2 Convex sets

Convex hull description of polyhedra

The convex hull of the finite set {v1, . . . , vk} is

conv{v1, . . . , vk} = {θ1v1 + · · ·+ θkvk | θ � 0, 1T θ = 1}.

This set is a polyhedron, and bounded, but (except in special cases, e.g., a simplex)
it is not simple to express it in the form (2.5), i.e., by a set of linear equalities and
inequalities.

A generalization of this convex hull description is

{θ1v1 + · · ·+ θkvk | θ1 + · · ·+ θm = 1, θi ≥ 0, i = 1, . . . , k}, (2.9)

where m ≤ k. Here we consider nonnegative linear combinations of vi, but only
the first m coefficients are required to sum to one. Alternatively, we can inter-
pret (2.9) as the convex hull of the points v1, . . . , vm, plus the conic hull of the
points vm+1, . . . , vk. The set (2.9) defines a polyhedron, and conversely, every
polyhedron can be represented in this form (although we will not show this).

The question of how a polyhedron is represented is subtle, and has very im-
portant practical consequences. As a simple example consider the unit ball in the
ℓ∞-norm in R

n,

C = {x | |xi| ≤ 1, i = 1, . . . , n}.
The set C can be described in the form (2.5) with 2n linear inequalities ±eTi x ≤ 1,
where ei is the ith unit vector. To describe it in the convex hull form (2.9) requires
at least 2n points:

C = conv{v1, . . . , v2n},
where v1, . . . , v2n are the 2

n vectors all of whose components are 1 or −1. Thus
the size of the two descriptions differs greatly, for large n.

2.2.5 The positive semidefinite cone

We use the notation Sn to denote the set of symmetric n× n matrices,

Sn = {X ∈ Rn×n | X = XT },

which is a vector space with dimension n(n + 1)/2. We use the notation Sn+ to
denote the set of symmetric positive semidefinite matrices:

Sn+ = {X ∈ Sn | X � 0},

and the notation Sn++ to denote the set of symmetric positive definite matrices:

Sn++ = {X ∈ Sn | X ≻ 0}.

(This notation is meant to be analogous to R+, which denotes the nonnegative
reals, and R++, which denotes the positive reals.)



2.3 Operations that preserve convexity 35

xy

z

0

0.5

1

−1

0

1
0

0.5

1

Figure 2.12 Boundary of positive semidefinite cone in S2.

The set Sn+ is a convex cone: if θ1, θ2 ≥ 0 and A, B ∈ Sn+, then θ1A+θ2B ∈ Sn+.
This can be seen directly from the definition of positive semidefiniteness: for any
x ∈ Rn, we have

xT (θ1A+ θ2B)x = θ1x
TAx+ θ2x

TBx ≥ 0,

if A � 0, B � 0 and θ1, θ2 ≥ 0.

Example 2.6 Positive semidefinite cone in S2. We have

X =

[
x y
y z

]
∈ S2+ ⇐⇒ x ≥ 0, z ≥ 0, xz ≥ y2.

The boundary of this cone is shown in figure 2.12, plotted in R3 as (x, y, z).

2.3 Operations that preserve convexity

In this section we describe some operations that preserve convexity of sets, or
allow us to construct convex sets from others. These operations, together with the
simple examples described in §2.2, form a calculus of convex sets that is useful for
determining or establishing convexity of sets.



36 2 Convex sets

2.3.1 Intersection

Convexity is preserved under intersection: if S1 and S2 are convex, then S1 ∩S2 is
convex. This property extends to the intersection of an infinite number of sets: if
Sα is convex for every α ∈ A, then

⋂
α∈A Sα is convex. (Subspaces, affine sets, and

convex cones are also closed under arbitrary intersections.) As a simple example,
a polyhedron is the intersection of halfspaces and hyperplanes (which are convex),
and therefore is convex.

Example 2.7 The positive semidefinite cone Sn+ can be expressed as⋂
z 6=0

{X ∈ Sn | zTXz ≥ 0}.

For each z 6= 0, zTXz is a (not identically zero) linear function of X, so the sets

{X ∈ Sn | zTXz ≥ 0}

are, in fact, halfspaces in Sn. Thus the positive semidefinite cone is the intersection
of an infinite number of halfspaces, and so is convex.

Example 2.8 We consider the set

S = {x ∈ Rm | |p(t)| ≤ 1 for |t| ≤ π/3}, (2.10)

where p(t) =
∑m

k=1
xk cos kt. The set S can be expressed as the intersection of an

infinite number of slabs: S =
⋂
|t|≤π/3

St, where

St = {x | − 1 ≤ (cos t, . . . , cosmt)Tx ≤ 1},

and so is convex. The definition and the set are illustrated in figures 2.13 and 2.14,
for m = 2.

In the examples above we establish convexity of a set by expressing it as a
(possibly infinite) intersection of halfspaces. We will see in §2.5.1 that a converse
holds: every closed convex set S is a (usually infinite) intersection of halfspaces.
In fact, a closed convex set S is the intersection of all halfspaces that contain it:

S =
⋂

{H | H halfspace, S ⊆ H}.

2.3.2 Affine functions

Recall that a function f : Rn → Rm is affine if it is a sum of a linear function and
a constant, i.e., if it has the form f(x) = Ax + b, where A ∈ Rm×n and b ∈ Rm.
Suppose S ⊆ Rn is convex and f : Rn → Rm is an affine function. Then the image
of S under f ,

f(S) = {f(x) | x ∈ S},



2.3 Operations that preserve convexity 37

0 π/3 2π/3 π

−1
0

1

t

p
(t
)

Figure 2.13 Three trigonometric polynomials associated with points in the
set S defined in (2.10), for m = 2. The trigonometric polynomial plotted
with dashed line type is the average of the other two.

x1

x
2 S

−2 −1 0 1 2−2

−1

0

1

2

Figure 2.14 The set S defined in (2.10), for m = 2, is shown as the white
area in the middle of the plot. The set is the intersection of an infinite
number of slabs (20 of which are shown), hence convex.



38 2 Convex sets

is convex. Similarly, if f : Rk → Rn is an affine function, the inverse image of S
under f ,

f−1(S) = {x | f(x) ∈ S},
is convex.

Two simple examples are scaling and translation. If S ⊆ Rn is convex, α ∈ R,
and a ∈ Rn, then the sets αS and S + a are convex, where

αS = {αx | x ∈ S}, S + a = {x+ a | x ∈ S}.
The projection of a convex set onto some of its coordinates is convex: if S ⊆
Rm ×Rn is convex, then

T = {x1 ∈ Rm | (x1, x2) ∈ S for some x2 ∈ Rn}
is convex.

The sum of two sets is defined as

S1 + S2 = {x+ y | x ∈ S1, y ∈ S2}.
If S1 and S2 are convex, then S1 + S2 is convex. To see this, if S1 and S2 are
convex, then so is the direct or Cartesian product

S1 × S2 = {(x1, x2) | x1 ∈ S1, x2 ∈ S2}.
The image of this set under the linear function f(x1, x2) = x1 + x2 is the sum
S1 + S2.

We can also consider the partial sum of S1, S2 ∈ Rn ×Rm, defined as
S = {(x, y1 + y2) | (x, y1) ∈ S1, (x, y2) ∈ S2},

where x ∈ Rn and yi ∈ Rm. For m = 0, the partial sum gives the intersection of
S1 and S2; for n = 0, it is set addition. Partial sums of convex sets are convex (see
exercise 2.16).

Example 2.9 Polyhedron. The polyhedron {x | Ax � b, Cx = d} can be expressed as
the inverse image of the Cartesian product of the nonnegative orthant and the origin
under the affine function f(x) = (b−Ax, d− Cx):

{x | Ax � b, Cx = d} = {x | f(x) ∈ Rm+ × {0}}.

Example 2.10 Solution set of linear matrix inequality. The condition

A(x) = x1A1 + · · ·+ xnAn � B, (2.11)
whereB, Ai ∈ Sm, is called a linear matrix inequality (LMI) in x. (Note the similarity
to an ordinary linear inequality,

aTx = x1a1 + · · ·+ xnan ≤ b,
with b, ai ∈ R.)
The solution set of a linear matrix inequality, {x | A(x) � B}, is convex. Indeed,
it is the inverse image of the positive semidefinite cone under the affine function
f : Rn → Sm given by f(x) = B −A(x).



2.3 Operations that preserve convexity 39

Example 2.11 Hyperbolic cone. The set

{x | xTPx ≤ (cTx)2, cTx ≥ 0}

where P ∈ Sn+ and c ∈ Rn, is convex, since it is the inverse image of the second-order
cone,

{(z, t) | zT z ≤ t2, t ≥ 0},
under the affine function f(x) = (P 1/2x, cTx).

Example 2.12 Ellipsoid. The ellipsoid

E = {x | (x− xc)TP−1(x− xc) ≤ 1},

where P ∈ Sn++, is the image of the unit Euclidean ball {u | ‖u‖2 ≤ 1} under the
affine mapping f(u) = P 1/2u+xc. (It is also the inverse image of the unit ball under
the affine mapping g(x) = P−1/2(x− xc).)

2.3.3 Linear-fractional and perspective functions

In this section we explore a class of functions, called linear-fractional, that is more
general than affine but still preserves convexity.

The perspective function

We define the perspective function P : Rn+1 → Rn, with domain domP = Rn ×
R++, as P (z, t) = z/t. (Here R++ denotes the set of positive numbers: R++ =
{x ∈ R | x > 0}.) The perspective function scales or normalizes vectors so the last
component is one, and then drops the last component.

Remark 2.1 We can interpret the perspective function as the action of a pin-hole
camera. A pin-hole camera (in R3) consists of an opaque horizontal plane x3 = 0,
with a single pin-hole at the origin, through which light can pass, and a horizontal
image plane x3 = −1. An object at x, above the camera (i.e., with x3 > 0), forms
an image at the point −(x1/x3, x2/x3, 1) on the image plane. Dropping the last
component of the image point (since it is always −1), the image of a point at x
appears at y = −(x1/x3, x2/x3) = −P (x) on the image plane. This is illustrated in
figure 2.15.

If C ⊆ domP is convex, then its image

P (C) = {P (x) | x ∈ C}

is convex. This result is certainly intuitive: a convex object, viewed through a
pin-hole camera, yields a convex image. To establish this fact we show that line
segments are mapped to line segments under the perspective function. (This too



40 2 Convex sets

x3 = 0

x3 = −1
Figure 2.15 Pin-hole camera interpretation of perspective function. The
dark horizontal line represents the plane x3 = 0 in R

3, which is opaque,
except for a pin-hole at the origin. Objects or light sources above the plane
appear on the image plane x3 = −1, which is shown as the lighter horizontal
line. The mapping of the position of a source to the position of its image is
related to the perspective function.

makes sense: a line segment, viewed through a pin-hole camera, yields a line seg-
ment image.) Suppose that x = (x˜, xn+1), y = (y˜, yn+1) ∈ Rn+1 with xn+1 > 0,
yn+1 > 0. Then for 0 ≤ θ ≤ 1,

P (θx+ (1− θ)y) = θx˜+ (1− θ)y˜
θxn+1 + (1− θ)yn+1 = µP (x) + (1− µ)P (y),

where

µ =
θxn+1

θxn+1 + (1− θ)yn+1 ∈ [0, 1].

This correspondence between θ and µ is monotonic: as θ varies between 0 and 1
(which sweeps out the line segment [x, y]), µ varies between 0 and 1 (which sweeps
out the line segment [P (x), P (y)]). This shows that P ([x, y]) = [P (x), P (y)].

Now suppose C is convex with C ⊆ domP (i.e., xn+1 > 0 for all x ∈ C), and
x, y ∈ C. To establish convexity of P (C) we need to show that the line segment
[P (x), P (y)] is in P (C). But this line segment is the image of the line segment
[x, y] under P , and so lies in P (C).

The inverse image of a convex set under the perspective function is also convex:
if C ⊆ Rn is convex, then

P−1(C) = {(x, t) ∈ Rn+1 | x/t ∈ C, t > 0}

is convex. To show this, suppose (x, t) ∈ P−1(C), (y, s) ∈ P−1(C), and 0 ≤ θ ≤ 1.
We need to show that

θ(x, t) + (1− θ)(y, s) ∈ P−1(C),

i.e., that
θx+ (1− θ)y
θt+ (1− θ)s ∈ C



2.3 Operations that preserve convexity 41

(θt+ (1− θ)s > 0 is obvious). This follows from
θx+ (1− θ)y
θt+ (1− θ)s = µ(x/t) + (1− µ)(y/s),

where

µ =
θt

θt+ (1− θ)s ∈ [0, 1].

Linear-fractional functions

A linear-fractional function is formed by composing the perspective function with
an affine function. Suppose g : Rn → Rm+1 is affine, i.e.,

g(x) =

[
A
cT

]
x+

[
b
d

]
, (2.12)

where A ∈ Rm×n, b ∈ Rm, c ∈ Rn, and d ∈ R. The function f : Rn → Rm given
by f = P ◦ g, i.e.,

f(x) = (Ax+ b)/(cTx+ d), dom f = {x | cTx+ d > 0}, (2.13)

is called a linear-fractional (or projective) function. If c = 0 and d > 0, the domain
of f isRn, and f is an affine function. So we can think of affine and linear functions
as special cases of linear-fractional functions.

Remark 2.2 Projective interpretation. It is often convenient to represent a linear-
fractional function as a matrix

Q =

[
A b
cT d

]
∈ R(m+1)×(n+1) (2.14)

that acts on (multiplies) points of form (x, 1), which yields (Ax + b, cTx + d). This
result is then scaled or normalized so that its last component is one, which yields
(f(x), 1).

This representation can be interpreted geometrically by associating Rn with a set
of rays in Rn+1 as follows. With each point z in Rn we associate the (open) ray
P(z) = {t(z, 1) | t > 0} in Rn+1. The last component of this ray takes on positive
values. Conversely any ray in Rn+1, with base at the origin and last component
which takes on positive values, can be written as P(v) = {t(v, 1) | t ≥ 0} for some
v ∈ Rn. This (projective) correspondence P between Rn and the halfspace of rays
with positive last component is one-to-one and onto.

The linear-fractional function (2.13) can be expressed as

f(x) = P−1(QP(x)).

Thus, we start with x ∈ dom f , i.e., cTx + d > 0. We then form the ray P(x) in
Rn+1. The linear transformation with matrix Q acts on this ray to produce another
ray QP(x). Since x ∈ dom f , the last component of this ray assumes positive values.
Finally we take the inverse projective transformation to recover f(x).



42 2 Convex sets

x1

x
2 C

−1 0 1−1

0

1

x1

x
2

f(C)

−1 0 1−1

0

1

Figure 2.16 Left. A set C ⊆ R2. The dashed line shows the boundary of
the domain of the linear-fractional function f(x) = x/(x1 + x2 + 1) with
dom f = {(x1, x2) | x1 + x2 + 1 > 0}. Right. Image of C under f . The
dashed line shows the boundary of the domain of f−1.

Like the perspective function, linear-fractional functions preserve convexity. If
C is convex and lies in the domain of f (i.e., cTx + d > 0 for x ∈ C), then its
image f(C) is convex. This follows immediately from results above: the image of C
under the affine mapping (2.12) is convex, and the image of the resulting set under
the perspective function P , which yields f(C), is convex. Similarly, if C ⊆ Rm is
convex, then the inverse image f−1(C) is convex.

Example 2.13 Conditional probabilities. Suppose u and v are random variables
that take on values in {1, . . . , n} and {1, . . . ,m}, respectively, and let pij denote
prob(u = i, v = j). Then the conditional probability fij = prob(u = i|v = j) is
given by

fij =
pij∑n
k=1

pkj
.

Thus f is obtained by a linear-fractional mapping from p.

It follows that if C is a convex set of joint probabilities for (u, v), then the associated
set of conditional probabilities of u given v is also convex.

Figure 2.16 shows a set C ⊆ R2, and its image under the linear-fractional
function

f(x) =
1

x1 + x2 + 1
x, dom f = {(x1, x2) | x1 + x2 + 1 > 0}.



2.4 Generalized inequalities 43

2.4 Generalized inequalities

2.4.1 Proper cones and generalized inequalities

A cone K ⊆ Rn is called a proper cone if it satisfies the following:
• K is convex.
• K is closed.
• K is solid, which means it has nonempty interior.
• K is pointed, which means that it contains no line (or equivalently, x ∈
K, − x ∈ K =⇒ x = 0).

A proper cone K can be used to define a generalized inequality, which is a partial
ordering on Rn that has many of the properties of the standard ordering on R.
We associate with the proper cone K the partial ordering on Rn defined by

x �K y ⇐⇒ y − x ∈ K.
We also write x �K y for y �K x. Similarly, we define an associated strict partial
ordering by

x ≺K y ⇐⇒ y − x ∈ intK,
and write x ≻K y for y ≺K x. (To distinguish the generalized inequality �K
from the strict generalized inequality, we sometimes refer to �K as the nonstrict
generalized inequality.)

When K = R+, the partial ordering �K is the usual ordering ≤ on R, and
the strict partial ordering ≺K is the same as the usual strict ordering < on R.
So generalized inequalities include as a special case ordinary (nonstrict and strict)
inequality in R.

Example 2.14 Nonnegative orthant and componentwise inequality. The nonnegative
orthant K = Rn+ is a proper cone. The associated generalized inequality �K corre-
sponds to componentwise inequality between vectors: x �K y means that xi ≤ yi,
i = 1, . . . , n. The associated strict inequality corresponds to componentwise strict
inequality: x ≺K y means that xi < yi, i = 1, . . . , n.
The nonstrict and strict partial orderings associated with the nonnegative orthant
arise so frequently that we drop the subscript Rn+; it is understood when the symbol
� or ≺ appears between vectors.

Example 2.15 Positive semidefinite cone and matrix inequality. The positive semidef-
inite cone Sn+ is a proper cone in S

n. The associated generalized inequality �K is the
usual matrix inequality: X �K Y means Y − X is positive semidefinite. The inte-
rior of Sn+ (in S

n) consists of the positive definite matrices, so the strict generalized
inequality also agrees with the usual strict inequality between symmetric matrices:
X ≺K Y means Y −X is positive definite.
Here, too, the partial ordering arises so frequently that we drop the subscript: for
symmetric matrices we write simply X � Y or X ≺ Y . It is understood that the
generalized inequalities are with respect to the positive semidefinite cone.



44 2 Convex sets

Example 2.16 Cone of polynomials nonnegative on [0, 1]. Let K be defined as

K = {c ∈ Rn | c1 + c2t+ · · ·+ cntn−1 ≥ 0 for t ∈ [0, 1]}, (2.15)

i.e., K is the cone of (coefficients of) polynomials of degree n−1 that are nonnegative
on the interval [0, 1]. It can be shown that K is a proper cone; its interior is the set
of coefficients of polynomials that are positive on the interval [0, 1].

Two vectors c, d ∈ Rn satisfy c �K d if and only if

c1 + c2t+ · · ·+ cntn−1 ≤ d1 + d2t+ · · ·+ dntn−1

for all t ∈ [0, 1].

Properties of generalized inequalities

A generalized inequality �K satisfies many properties, such as

• �K is preserved under addition: if x �K y and u �K v, then x+u �K y+v.

• �K is transitive: if x �K y and y �K z then x �K z.

• �K is preserved under nonnegative scaling : if x �K y and α ≥ 0 then
αx �K αy.

• �K is reflexive: x �K x.

• �K is antisymmetric: if x �K y and y �K x, then x = y.

• �K is preserved under limits: if xi �K yi for i = 1, 2, . . ., xi → x and yi → y
as i→∞, then x �K y.

The corresponding strict generalized inequality ≺K satisfies, for example,

• if x ≺K y then x �K y.

• if x ≺K y and u �K v then x+ u ≺K y + v.

• if x ≺K y and α > 0 then αx ≺K αy.

• x 6≺K x.

• if x ≺K y, then for u and v small enough, x+ u ≺K y + v.

These properties are inherited from the definitions of �K and ≺K , and the prop-
erties of proper cones; see exercise 2.30.



2.4 Generalized inequalities 45

2.4.2 Minimum and minimal elements

The notation of generalized inequality (i.e., �K , ≺K) is meant to suggest the
analogy to ordinary inequality onR (i.e., ≤, <). While many properties of ordinary
inequality do hold for generalized inequalities, some important ones do not. The
most obvious difference is that ≤ on R is a linear ordering : any two points are
comparable, meaning either x ≤ y or y ≤ x. This property does not hold for
other generalized inequalities. One implication is that concepts like minimum and
maximum are more complicated in the context of generalized inequalities. We
briefly discuss this in this section.

We say that x ∈ S is the minimum element of S (with respect to the general-
ized inequality �K) if for every y ∈ S we have x �K y. We define the maximum
element of a set S, with respect to a generalized inequality, in a similar way. If a
set has a minimum (maximum) element, then it is unique. A related concept is
minimal element. We say that x ∈ S is a minimal element of S (with respect to
the generalized inequality �K) if y ∈ S, y �K x only if y = x. We define maxi-
mal element in a similar way. A set can have many different minimal (maximal)
elements.

We can describe minimum and minimal elements using simple set notation. A
point x ∈ S is the minimum element of S if and only if

S ⊆ x+K.
Here x + K denotes all the points that are comparable to x and greater than or
equal to x (according to �K). A point x ∈ S is a minimal element if and only if

(x−K) ∩ S = {x}.
Here x−K denotes all the points that are comparable to x and less than or equal
to x (according to �K); the only point in common with S is x.

For K = R+, which induces the usual ordering on R, the concepts of minimal
and minimum are the same, and agree with the usual definition of the minimum
element of a set.

Example 2.17 Consider the cone R2+, which induces componentwise inequality in
R2. Here we can give some simple geometric descriptions of minimal and minimum
elements. The inequality x � y means y is above and to the right of x. To say that
x ∈ S is the minimum element of a set S means that all other points of S lie above
and to the right. To say that x is a minimal element of a set S means that no other
point of S lies to the left and below x. This is illustrated in figure 2.17.

Example 2.18 Minimum and minimal elements of a set of symmetric matrices. We
associate with each A ∈ Sn++ an ellipsoid centered at the origin, given by

EA = {x | xTA−1x ≤ 1}.
We have A � B if and only if EA ⊆ EB .
Let v1, . . . , vk ∈ Rn be given and define

S = {P ∈ Sn++ | vTi P−1vi ≤ 1, i = 1, . . . , k},



46 2 Convex sets

x1

x2S1

S2

Figure 2.17 Left. The set S1 has a minimum element x1 with respect to
componentwise inequality in R2. The set x1 + K is shaded lightly; x1 is
the minimum element of S1 since S1 ⊆ x1 + K. Right. The point x2 is a
minimal point of S2. The set x2 −K is shown lightly shaded. The point x2
is minimal because x2 −K and S2 intersect only at x2.

which corresponds to the set of ellipsoids that contain the points v1, . . . , vk. The
set S does not have a minimum element: for any ellipsoid that contains the points
v1, . . . , vk we can find another one that contains the points, and is not comparable
to it. An ellipsoid is minimal if it contains the points, but no smaller ellipsoid does.
Figure 2.18 shows an example in R2 with k = 2.

2.5 Separating and supporting hyperplanes

2.5.1 Separating hyperplane theorem

In this section we describe an idea that will be important later: the use of hyper-
planes or affine functions to separate convex sets that do not intersect. The basic
result is the separating hyperplane theorem: Suppose C and D are nonempty dis-
joint convex sets, i.e., C ∩D = ∅. Then there exist a 6= 0 and b such that aTx ≤ b
for all x ∈ C and aTx ≥ b for all x ∈ D. In other words, the affine function aTx− b
is nonpositive on C and nonnegative on D. The hyperplane {x | aTx = b} is called
a separating hyperplane for the sets C and D, or is said to separate the sets C and
D. This is illustrated in figure 2.19.

Proof of separating hyperplane theorem

Here we consider a special case, and leave the extension of the proof to the gen-
eral case as an exercise (exercise 2.22). We assume that the (Euclidean) distance
between C and D, defined as

dist(C,D) = inf{‖u− v‖2 | u ∈ C, v ∈ D},



2.5 Separating and supporting hyperplanes 47

E1

E2

E3

Figure 2.18 Three ellipsoids in R2, centered at the origin (shown as the
lower dot), that contain the points shown as the upper dots. The ellipsoid
E1 is not minimal, since there exist ellipsoids that contain the points, and
are smaller (e.g., E3). E3 is not minimal for the same reason. The ellipsoid
E2 is minimal, since no other ellipsoid (centered at the origin) contains the
points and is contained in E2.

D

C

a

aTx ≥ b aTx ≤ b

Figure 2.19 The hyperplane {x | aTx = b} separates the disjoint convex sets
C and D. The affine function aTx− b is nonpositive on C and nonnegative
on D.



48 2 Convex sets

D

C

a

d

c

Figure 2.20 Construction of a separating hyperplane between two convex
sets. The points c ∈ C and d ∈ D are the pair of points in the two sets that
are closest to each other. The separating hyperplane is orthogonal to, and
bisects, the line segment between c and d.

is positive, and that there exist points c ∈ C and d ∈ D that achieve the minimum
distance, i.e., ‖c− d‖2 = dist(C,D). (These conditions are satisfied, for example,
when C and D are closed and one set is bounded.)

Define

a = d− c, b = ‖d‖
2
2 − ‖c‖22
2

.

We will show that the affine function

f(x) = aTx− b = (d− c)T (x− (1/2)(d+ c))
is nonpositive on C and nonnegative on D, i.e., that the hyperplane {x | aTx = b}
separates C and D. This hyperplane is perpendicular to the line segment between
c and d, and passes through its midpoint, as shown in figure 2.20.

We first show that f is nonnegative on D. The proof that f is nonpositive on
C is similar (or follows by swapping C and D and considering −f). Suppose there
were a point u ∈ D for which

f(u) = (d− c)T (u− (1/2)(d+ c)) < 0. (2.16)
We can express f(u) as

f(u) = (d− c)T (u− d+ (1/2)(d− c)) = (d− c)T (u− d) + (1/2)‖d− c‖22.
We see that (2.16) implies (d− c)T (u− d) < 0. Now we observe that

d

dt
‖d+ t(u− d)− c‖22

∣∣∣∣
t=0

= 2(d− c)T (u− d) < 0,

so for some small t > 0, with t ≤ 1, we have
‖d+ t(u− d)− c‖2 < ‖d− c‖2,



2.5 Separating and supporting hyperplanes 49

i.e., the point d+ t(u− d) is closer to c than d is. Since D is convex and contains
d and u, we have d+ t(u− d) ∈ D. But this is impossible, since d is assumed to be
the point in D that is closest to C.

Example 2.19 Separation of an affine and a convex set. Suppose C is convex and
D is affine, i.e., D = {Fu + g | u ∈ Rm}, where F ∈ Rn×m. Suppose C and D are
disjoint, so by the separating hyperplane theorem there are a 6= 0 and b such that
aTx ≤ b for all x ∈ C and aTx ≥ b for all x ∈ D.
Now aTx ≥ b for all x ∈ D means aTFu ≥ b − aT g for all u ∈ Rm. But a linear
function is bounded below on Rm only when it is zero, so we conclude aTF = 0 (and
hence, b ≤ aT g).
Thus we conclude that there exists a 6= 0 such that FT a = 0 and aTx ≤ aT g for all
x ∈ C.

Strict separation

The separating hyperplane we constructed above satisfies the stronger condition
that aTx < b for all x ∈ C and aTx > b for all x ∈ D. This is called strict
separation of the sets C and D. Simple examples show that in general, disjoint
convex sets need not be strictly separable by a hyperplane (even when the sets are
closed; see exercise 2.23). In many special cases, however, strict separation can be
established.

Example 2.20 Strict separation of a point and a closed convex set. Let C be a closed
convex set and x0 6∈ C. Then there exists a hyperplane that strictly separates x0
from C.

To see this, note that the two sets C and B(x0, ǫ) do not intersect for some ǫ > 0.
By the separating hyperplane theorem, there exist a 6= 0 and b such that aTx ≤ b for
x ∈ C and aTx ≥ b for x ∈ B(x0, ǫ).
Using B(x0, ǫ) = {x0 + u | ‖u‖2 ≤ ǫ}, the second condition can be expressed as

aT (x0 + u) ≥ b for all ‖u‖2 ≤ ǫ.

The u that minimizes the lefthand side is u = −ǫa/‖a‖2; using this value we have

aTx0 − ǫ‖a‖2 ≥ b.

Therefore the affine function

f(x) = aTx− b− ǫ‖a‖2/2

is negative on C and positive at x0.

As an immediate consequence we can establish a fact that we already mentioned
above: a closed convex set is the intersection of all halfspaces that contain it. Indeed,
let C be closed and convex, and let S be the intersection of all halfspaces containing
C. Obviously x ∈ C ⇒ x ∈ S. To show the converse, suppose there exists x ∈ S,
x 6∈ C. By the strict separation result there exists a hyperplane that strictly separates
x from C, i.e., there is a halfspace containing C but not x. In other words, x 6∈ S.



50 2 Convex sets

Converse separating hyperplane theorems

The converse of the separating hyperplane theorem (i.e., existence of a separating
hyperplane implies that C and D do not intersect) is not true, unless one imposes
additional constraints on C or D, even beyond convexity. As a simple counterex-
ample, consider C = D = {0} ⊆ R. Here the hyperplane x = 0 separates C and
D.

By adding conditions on C and D various converse separation theorems can be
derived. As a very simple example, suppose C and D are convex sets, with C open,
and there exists an affine function f that is nonpositive on C and nonnegative on
D. Then C and D are disjoint. (To see this we first note that f must be negative
on C; for if f were zero at a point of C then f would take on positive values near
the point, which is a contradiction. But then C and D must be disjoint since f
is negative on C and nonnegative on D.) Putting this converse together with the
separating hyperplane theorem, we have the following result: any two convex sets
C and D, at least one of which is open, are disjoint if and only if there exists a
separating hyperplane.

Example 2.21 Theorem of alternatives for strict linear inequalities. We derive the
necessary and sufficient conditions for solvability of a system of strict linear inequal-
ities

Ax ≺ b. (2.17)
These inequalities are infeasible if and only if the (convex) sets

C = {b−Ax | x ∈ Rn}, D = Rm++ = {y ∈ Rm | y ≻ 0}
do not intersect. The set D is open; C is an affine set. Hence by the result above, C
and D are disjoint if and only if there exists a separating hyperplane, i.e., a nonzero
λ ∈ Rm and µ ∈ R such that λT y ≤ µ on C and λT y ≥ µ on D.
Each of these conditions can be simplified. The first means λT (b−Ax) ≤ µ for all x.
This implies (as in example 2.19) that ATλ = 0 and λT b ≤ µ. The second inequality
means λT y ≥ µ for all y ≻ 0. This implies µ ≤ 0 and λ � 0, λ 6= 0.
Putting it all together, we find that the set of strict inequalities (2.17) is infeasible if
and only if there exists λ ∈ Rm such that

λ 6= 0, λ � 0, ATλ = 0, λT b ≤ 0. (2.18)
This is also a system of linear inequalities and linear equations in the variable λ ∈ Rm.
We say that (2.17) and (2.18) form a pair of alternatives: for any data A and b, exactly
one of them is solvable.

2.5.2 Supporting hyperplanes

Suppose C ⊆ Rn, and x0 is a point in its boundary bdC, i.e.,
x0 ∈ bdC = clC \ intC.

If a 6= 0 satisfies aTx ≤ aTx0 for all x ∈ C, then the hyperplane {x | aTx = aTx0}
is called a supporting hyperplane to C at the point x0. This is equivalent to saying



2.6 Dual cones and generalized inequalities 51

C

a

x0

Figure 2.21 The hyperplane {x | aTx = aTx0} supports C at x0.

that the point x0 and the set C are separated by the hyperplane {x | aTx = aTx0}.
The geometric interpretation is that the hyperplane {x | aTx = aTx0} is tangent
to C at x0, and the halfspace {x | aTx ≤ aTx0} contains C. This is illustrated in
figure 2.21.

A basic result, called the supporting hyperplane theorem, states that for any
nonempty convex set C, and any x0 ∈ bdC, there exists a supporting hyperplane to
C at x0. The supporting hyperplane theorem is readily proved from the separating
hyperplane theorem. We distinguish two cases. If the interior of C is nonempty,
the result follows immediately by applying the separating hyperplane theorem to
the sets {x0} and intC. If the interior of C is empty, then C must lie in an affine
set of dimension less than n, and any hyperplane containing that affine set contains
C and x0, and is a (trivial) supporting hyperplane.

There is also a partial converse of the supporting hyperplane theorem: If a set
is closed, has nonempty interior, and has a supporting hyperplane at every point
in its boundary, then it is convex. (See exercise 2.27.)

2.6 Dual cones and generalized inequalities

2.6.1 Dual cones

Let K be a cone. The set

K∗ = {y | xT y ≥ 0 for all x ∈ K} (2.19)
is called the dual cone of K. As the name suggests, K∗ is a cone, and is always
convex, even when the original cone K is not (see exercise 2.31).

Geometrically, y ∈ K∗ if and only if −y is the normal of a hyperplane that
supports K at the origin. This is illustrated in figure 2.22.

Example 2.22 Subspace. The dual cone of a subspace V ⊆ Rn (which is a cone) is
its orthogonal complement V ⊥ = {y | vT y = 0 for all v ∈ V }.



52 2 Convex sets

K Ky

z

Figure 2.22 Left. The halfspace with inward normal y contains the cone K,
so y ∈ K∗. Right. The halfspace with inward normal z does not contain K,
so z 6∈ K∗.

Example 2.23 Nonnegative orthant. The cone Rn+ is its own dual:

xT y ≥ 0 for all x � 0 ⇐⇒ y � 0.

We call such a cone self-dual.

Example 2.24 Positive semidefinite cone. On the set of symmetric n × n matrices
Sn, we use the standard inner product tr(XY ) =

∑n
i,j=1

XijYij (see §A.1.1). The
positive semidefinite cone Sn+ is self-dual, i.e., for X, Y ∈ Sn,

tr(XY ) ≥ 0 for all X � 0 ⇐⇒ Y � 0.

We will establish this fact.

Suppose Y 6∈ Sn+. Then there exists q ∈ Rn with

qTY q = tr(qqTY ) < 0.

Hence the positive semidefinite matrix X = qqT satisfies tr(XY ) < 0; it follows that
Y 6∈ (Sn+)∗.
Now suppose X, Y ∈ Sn+. We can express X in terms of its eigenvalue decomposition
as X =

∑n
i=1

λiqiq
T
i , where (the eigenvalues) λi ≥ 0, i = 1, . . . , n. Then we have

tr(Y X) = tr

(
Y

n∑
i=1

λiqiq
T
i

)
=

n∑
i=1

λiq
T
i Y qi ≥ 0.

This shows that Y ∈ (Sn+)∗.

Example 2.25 Dual of a norm cone. Let ‖ · ‖ be a norm on Rn. The dual of the
associated cone K = {(x, t) ∈ Rn+1 | ‖x‖ ≤ t} is the cone defined by the dual norm,
i.e.,

K∗ = {(u, v) ∈ Rn+1 | ‖u‖∗ ≤ v},



2.6 Dual cones and generalized inequalities 53

where the dual norm is given by ‖u‖∗ = sup{uTx | ‖x‖ ≤ 1} (see (A.1.6)).
To prove the result we have to show that

xTu+ tv ≥ 0 whenever ‖x‖ ≤ t ⇐⇒ ‖u‖∗ ≤ v. (2.20)

Let us start by showing that the righthand condition on (u, v) implies the lefthand
condition. Suppose ‖u‖∗ ≤ v, and ‖x‖ ≤ t for some t > 0. (If t = 0, x must be zero,
so obviously uTx + vt ≥ 0.) Applying the definition of the dual norm, and the fact
that ‖−x/t‖ ≤ 1, we have

uT (−x/t) ≤ ‖u‖∗ ≤ v,
and therefore uTx+ vt ≥ 0.
Next we show that the lefthand condition in (2.20) implies the righthand condition
in (2.20). Suppose ‖u‖∗ > v, i.e., that the righthand condition does not hold. Then
by the definition of the dual norm, there exists an x with ‖x‖ ≤ 1 and xTu > v.
Taking t = 1, we have

uT (−x) + v < 0,
which contradicts the lefthand condition in (2.20).

Dual cones satisfy several properties, such as:

• K∗ is closed and convex.
• K1 ⊆ K2 implies K∗2 ⊆ K∗1 .
• If K has nonempty interior, then K∗ is pointed.
• If the closure of K is pointed then K∗ has nonempty interior.
• K∗∗ is the closure of the convex hull of K. (Hence if K is convex and closed,
K∗∗ = K.)

(See exercise 2.31.) These properties show that if K is a proper cone, then so is its
dual K∗, and moreover, that K∗∗ = K.

2.6.2 Dual generalized inequalities

Now suppose that the convex coneK is proper, so it induces a generalized inequality
�K . Then its dual cone K∗ is also proper, and therefore induces a generalized
inequality. We refer to the generalized inequality �K∗ as the dual of the generalized
inequality �K .

Some important properties relating a generalized inequality and its dual are:

• x �K y if and only if λTx ≤ λT y for all λ �K∗ 0.
• x ≺K y if and only if λTx < λT y for all λ �K∗ 0, λ 6= 0.
Since K = K∗∗, the dual generalized inequality associated with �K∗ is �K , so

these properties hold if the generalized inequality and its dual are swapped. As a
specific example, we have λ �K∗ µ if and only if λTx ≤ µTx for all x �K 0.



54 2 Convex sets

Example 2.26 Theorem of alternatives for linear strict generalized inequalities. Sup-
pose K ⊆ Rm is a proper cone. Consider the strict generalized inequality

Ax ≺K b, (2.21)
where x ∈ Rn.
We will derive a theorem of alternatives for this inequality. Suppose it is infeasible,
i.e., the affine set {b − Ax | x ∈ Rn} does not intersect the open convex set intK.
Then there is a separating hyperplane, i.e., a nonzero λ ∈ Rm and µ ∈ R such that
λT (b− Ax) ≤ µ for all x, and λT y ≥ µ for all y ∈ intK. The first condition implies
ATλ = 0 and λT b ≤ µ. The second condition implies λT y ≥ µ for all y ∈ K, which
can only happen if λ ∈ K∗ and µ ≤ 0.
Putting it all together we find that if (2.21) is infeasible, then there exists λ such that

λ 6= 0, λ �K∗ 0, ATλ = 0, λT b ≤ 0. (2.22)
Now we show the converse: if (2.22) holds, then the inequality system (2.21) cannot
be feasible. Suppose that both inequality systems hold. Then we have λT (b−Ax) >
0, since λ 6= 0, λ �K∗ 0, and b − Ax ≻K 0. But using ATλ = 0 we find that
λT (b−Ax) = λT b ≤ 0, which is a contradiction.
Thus, the inequality systems (2.21) and (2.22) are alternatives: for any data A, b,
exactly one of them is feasible. (This generalizes the alternatives (2.17), (2.18) for
the special case K = Rm+ .)

2.6.3 Minimum and minimal elements via dual inequalities

We can use dual generalized inequalities to characterize minimum and minimal
elements of a (possibly nonconvex) set S ⊆ Rm with respect to the generalized
inequality induced by a proper cone K.

Dual characterization of minimum element

We first consider a characterization of the minimum element: x is the minimum
element of S, with respect to the generalized inequality �K , if and only if for all
λ ≻K∗ 0, x is the unique minimizer of λT z over z ∈ S. Geometrically, this means
that for any λ ≻K∗ 0, the hyperplane

{z | λT (z − x) = 0}
is a strict supporting hyperplane to S at x. (By strict supporting hyperplane, we
mean that the hyperplane intersects S only at the point x.) Note that convexity
of the set S is not required. This is illustrated in figure 2.23.

To show this result, suppose x is the minimum element of S, i.e., x �K z for
all z ∈ S, and let λ ≻K∗ 0. Let z ∈ S, z 6= x. Since x is the minimum element of
S, we have z − x �K 0. From λ ≻K∗ 0 and z − x �K 0, z − x 6= 0, we conclude
λT (z − x) > 0. Since z is an arbitrary element of S, not equal to x, this shows
that x is the unique minimizer of λT z over z ∈ S. Conversely, suppose that for all
λ ≻K∗ 0, x is the unique minimizer of λT z over z ∈ S, but x is not the minimum



2.6 Dual cones and generalized inequalities 55

x

S

Figure 2.23 Dual characterization of minimum element. The point x is the
minimum element of the set S with respect to R2+. This is equivalent to:

for every λ ≻ 0, the hyperplane {z | λT (z − x) = 0} strictly supports S at
x, i.e., contains S on one side, and touches it only at x.

element of S. Then there exists z ∈ S with z 6�K x. Since z− x 6�K 0, there exists
λ˜ �K∗ 0 with λ˜T (z−x) < 0. Hence λT (z−x) < 0 for λ ≻K∗ 0 in the neighborhood
of λ˜. This contradicts the assumption that x is the unique minimizer of λT z over
S.

Dual characterization of minimal elements

We now turn to a similar characterization of minimal elements. Here there is a gap
between the necessary and sufficient conditions. If λ ≻K∗ 0 and x minimizes λT z
over z ∈ S, then x is minimal. This is illustrated in figure 2.24.

To show this, suppose that λ ≻K∗ 0, and x minimizes λT z over S, but x is not
minimal, i.e., there exists a z ∈ S, z 6= x, and z �K x. Then λT (x− z) > 0, which
contradicts our assumption that x is the minimizer of λT z over S.

The converse is in general false: a point x can be minimal in S, but not a
minimizer of λT z over z ∈ S, for any λ, as shown in figure 2.25. This figure
suggests that convexity plays an important role in the converse, which is correct.
Provided the set S is convex, we can say that for any minimal element x there
exists a nonzero λ �K∗ 0 such that x minimizes λT z over z ∈ S.

To show this, suppose x is minimal, which means that ((x−K) \ {x})∩S = ∅.
Applying the separating hyperplane theorem to the convex sets (x−K) \ {x} and
S, we conclude that there is a λ 6= 0 and µ such that λT (x− y) ≤ µ for all y ∈ K,
and λT z ≥ µ for all z ∈ S. From the first inequality we conclude λ �K∗ 0. Since
x ∈ S and x ∈ x −K, we have λTx = µ, so the second inequality implies that µ
is the minimum value of λT z over S. Therefore, x is a minimizer of λT z over S,
where λ 6= 0, λ �K∗ 0.

This converse theorem cannot be strengthened to λ ≻K∗ 0. Examples show
that a point x can be a minimal point of a convex set S, but not a minimizer of



56 2 Convex sets

S
x1

x2

λ1

λ2

Figure 2.24 A set S ⊆ R2. Its set of minimal points, with respect to R2+, is
shown as the darker section of its (lower, left) boundary. The minimizer of
λT1 z over S is x1, and is minimal since λ1 ≻ 0. The minimizer of λT2 z over
S is x2, which is another minimal point of S, since λ2 ≻ 0.

S

x

Figure 2.25 The point x is a minimal element of S ⊆ R2 with respect to
R2+. However there exists no λ for which x minimizes λ

T z over z ∈ S.



2.6 Dual cones and generalized inequalities 57

S1 S2x1

x2

Figure 2.26 Left. The point x1 ∈ S1 is minimal, but is not a minimizer of
λT z over S1 for any λ ≻ 0. (It does, however, minimize λT z over z ∈ S1 for
λ = (1, 0).) Right. The point x2 ∈ S2 is not minimal, but it does minimize
λT z over z ∈ S2 for λ = (0, 1) � 0.

λT z over z ∈ S for any λ ≻K∗ 0. (See figure 2.26, left.) Nor is it true that any
minimizer of λT z over z ∈ S, with λ �K∗ 0, is minimal (see figure 2.26, right.)

Example 2.27 Pareto optimal production frontier. We consider a product which
requires n resources (such as labor, electricity, natural gas, water) to manufacture.
The product can be manufactured or produced in many ways. With each production
method, we associate a resource vector x ∈ Rn, where xi denotes the amount of
resource i consumed by the method to manufacture the product. We assume that xi ≥
0 (i.e., resources are consumed by the production methods) and that the resources
are valuable (so using less of any resource is preferred).

The production set P ⊆ Rn is defined as the set of all resource vectors x that
correspond to some production method.

Production methods with resource vectors that are minimal elements of P , with
respect to componentwise inequality, are called Pareto optimal or efficient. The set
of minimal elements of P is called the efficient production frontier.

We can give a simple interpretation of Pareto optimality. We say that one production
method, with resource vector x, is better than another, with resource vector y, if
xi ≤ yi for all i, and for some i, xi < yi. In other words, one production method
is better than another if it uses no more of each resource than another method, and
for at least one resource, actually uses less. This corresponds to x � y, x 6= y. Then
we can say: A production method is Pareto optimal or efficient if there is no better
production method.

We can find Pareto optimal production methods (i.e., minimal resource vectors) by
minimizing

λTx = λ1x1 + · · ·+ λnxn
over the set P of production vectors, using any λ that satisfies λ ≻ 0.
Here the vector λ has a simple interpretation: λi is the price of resource i. By
minimizing λTx over P we are finding the overall cheapest production method (for
the resource prices λi). As long as the prices are positive, the resulting production
method is guaranteed to be efficient.

These ideas are illustrated in figure 2.27.



58 2 Convex sets

x4x2

x1

x5

x3
λ

P

labor

fuel

Figure 2.27 The production set P , for a product that requires labor and
fuel to produce, is shown shaded. The two dark curves show the efficient
production frontier. The points x1, x2 and x3 are efficient. The points x4
and x5 are not (since in particular, x2 corresponds to a production method
that uses no more fuel, and less labor). The point x1 is also the minimum
cost production method for the price vector λ (which is positive). The point
x2 is efficient, but cannot be found by minimizing the total cost λ

Tx for any
price vector λ � 0.



Bibliography 59

Bibliography

Minkowski is generally credited with the first systematic study of convex sets, and the
introduction of fundamental concepts such as supporting hyperplanes and the supporting
hyperplane theorem, the Minkowski distance function (exercise 3.34), extreme points of
a convex set, and many others.

Some well known early surveys are Bonnesen and Fenchel [BF48], Eggleston [Egg58], Klee
[Kle63], and Valentine [Val64]. More recent books devoted to the geometry of convex sets
include Lay [Lay82] and Webster [Web94]. Klee [Kle71], Fenchel [Fen83], Tikhomorov
[Tik90], and Berger [Ber90] give very readable overviews of the history of convexity and
its applications throughout mathematics.

Linear inequalities and polyhedral sets are studied extensively in connection with the lin-
ear programming problem, for which we give references at the end of chapter 4. Some
landmark publications in the history of linear inequalities and linear programming are
Motzkin [Mot33], von Neumann and Morgenstern [vNM53], Kantorovich [Kan60], Koop-
mans [Koo51], and Dantzig [Dan63]. Dantzig [Dan63, Chapter 2] includes an historical
survey of linear inequalities, up to around 1963.

Generalized inequalities were introduced in nonlinear optimization during the 1960s (see
Luenberger [Lue69, §8.2] and Isii [Isi64]), and are used extensively in cone programming
(see the references in chapter 4). Bellman and Fan [BF63] is an early paper on sets of
generalized linear inequalities (with respect to the positive semidefinite cone).

For extensions and a proof of the separating hyperplane theorem we refer the reader
to Rockafellar [Roc70, part III], and Hiriart-Urruty and Lemare´chal [HUL93, volume
1, §III4]. Dantzig [Dan63, page 21] attributes the term theorem of the alternative to
von Neumann and Morgenstern [vNM53, page 138]. For more references on theorems of
alternatives, see chapter 5.

The terminology of example 2.27 (including Pareto optimality, efficient production, and
the price interpretation of λ) is discussed in detail by Luenberger [Lue95].

Convex geometry plays a prominent role in the classical theory of moments (Krein and
Nudelman [KN77], Karlin and Studden [KS66]). A famous example is the duality between
the cone of nonnegative polynomials and the cone of power moments; see exercise 2.37.



60 2 Convex sets

Exercises

Definition of convexity

2.1 Let C ⊆ Rn be a convex set, with x1, . . . , xk ∈ C, and let θ1, . . . , θk ∈ R satisfy θi ≥ 0,
θ1 + · · ·+ θk = 1. Show that θ1x1 + · · ·+ θkxk ∈ C. (The definition of convexity is that
this holds for k = 2; you must show it for arbitrary k.) Hint. Use induction on k.

2.2 Show that a set is convex if and only if its intersection with any line is convex. Show that
a set is affine if and only if its intersection with any line is affine.

2.3 Midpoint convexity. A set C is midpoint convex if whenever two points a, b are in C, the
average or midpoint (a+ b)/2 is in C. Obviously a convex set is midpoint convex. It can
be proved that under mild conditions midpoint convexity implies convexity. As a simple
case, prove that if C is closed and midpoint convex, then C is convex.

2.4 Show that the convex hull of a set S is the intersection of all convex sets that contain S.
(The same method can be used to show that the conic, or affine, or linear hull of a set S
is the intersection of all conic sets, or affine sets, or subspaces that contain S.)

Examples

2.5 What is the distance between two parallel hyperplanes {x ∈ Rn | aTx = b1} and {x ∈
Rn | aTx = b2}?

2.6 When does one halfspace contain another? Give conditions under which

{x | aTx ≤ b} ⊆ {x | a˜Tx ≤ b˜}
(where a 6= 0, a˜ 6= 0). Also find the conditions under which the two halfspaces are equal.

2.7 Voronoi description of halfspace. Let a and b be distinct points in Rn. Show that the set
of all points that are closer (in Euclidean norm) to a than b, i.e., {x | ‖x−a‖2 ≤ ‖x−b‖2},
is a halfspace. Describe it explicitly as an inequality of the form cTx ≤ d. Draw a picture.

2.8 Which of the following sets S are polyhedra? If possible, express S in the form S =
{x | Ax � b, Fx = g}.
(a) S = {y1a1 + y2a2 | − 1 ≤ y1 ≤ 1, − 1 ≤ y2 ≤ 1}, where a1, a2 ∈ Rn.
(b) S = {x ∈ Rn | x � 0, 1Tx = 1, ∑n

i=1
xiai = b1,

∑n
i=1

xia
2
i = b2}, where

a1, . . . , an ∈ R and b1, b2 ∈ R.
(c) S = {x ∈ Rn | x � 0, xT y ≤ 1 for all y with ‖y‖2 = 1}.
(d) S = {x ∈ Rn | x � 0, xT y ≤ 1 for all y with ∑n

i=1
|yi| = 1}.

2.9 Voronoi sets and polyhedral decomposition. Let x0, . . . , xK ∈ Rn. Consider the set of
points that are closer (in Euclidean norm) to x0 than the other xi, i.e.,

V = {x ∈ Rn | ‖x− x0‖2 ≤ ‖x− xi‖2, i = 1, . . . ,K}.
V is called the Voronoi region around x0 with respect to x1, . . . , xK .

(a) Show that V is a polyhedron. Express V in the form V = {x | Ax � b}.
(b) Conversely, given a polyhedron P with nonempty interior, show how to find x0, . . . , xK

so that the polyhedron is the Voronoi region of x0 with respect to x1, . . . , xK .

(c) We can also consider the sets

Vk = {x ∈ Rn | ‖x− xk‖2 ≤ ‖x− xi‖2, i 6= k}.
The set Vk consists of points inR

n for which the closest point in the set {x0, . . . , xK}
is xk.



Exercises 61

The sets V0, . . . , VK give a polyhedral decomposition of R
n. More precisely, the sets

Vk are polyhedra,
⋃K
k=0

Vk = R
n, and intVi ∩ intVj = ∅ for i 6= j, i.e., Vi and Vj

intersect at most along a boundary.

Suppose that P1, . . . , Pm are polyhedra such that
⋃m
i=1

Pi = R
n, and intPi ∩

intPj = ∅ for i 6= j. Can this polyhedral decomposition of Rn be described as
the Voronoi regions generated by an appropriate set of points?

2.10 Solution set of a quadratic inequality. Let C ⊆ Rn be the solution set of a quadratic
inequality,

C = {x ∈ Rn | xTAx+ bTx+ c ≤ 0},
with A ∈ Sn, b ∈ Rn, and c ∈ R.
(a) Show that C is convex if A � 0.
(b) Show that the intersection of C and the hyperplane defined by gTx+ h = 0 (where

g 6= 0) is convex if A+ λggT � 0 for some λ ∈ R.
Are the converses of these statements true?

2.11 Hyperbolic sets. Show that the hyperbolic set {x ∈ R2+ | x1x2 ≥ 1} is convex. As a
generalization, show that {x ∈ Rn+ |

∏n
i=1

xi ≥ 1} is convex. Hint. If a, b ≥ 0 and
0 ≤ θ ≤ 1, then aθb1−θ ≤ θa+ (1− θ)b; see §3.1.9.

2.12 Which of the following sets are convex?

(a) A slab, i.e., a set of the form {x ∈ Rn | α ≤ aTx ≤ β}.
(b) A rectangle, i.e., a set of the form {x ∈ Rn | αi ≤ xi ≤ βi, i = 1, . . . , n}. A rectangle

is sometimes called a hyperrectangle when n > 2.

(c) A wedge, i.e., {x ∈ Rn | aT1 x ≤ b1, aT2 x ≤ b2}.
(d) The set of points closer to a given point than a given set, i.e.,

{x | ‖x− x0‖2 ≤ ‖x− y‖2 for all y ∈ S}
where S ⊆ Rn.

(e) The set of points closer to one set than another, i.e.,

{x | dist(x, S) ≤ dist(x, T )},
where S, T ⊆ Rn, and

dist(x, S) = inf{‖x− z‖2 | z ∈ S}.
(f) [HUL93, volume 1, page 93] The set {x | x+ S2 ⊆ S1}, where S1, S2 ⊆ Rn with S1

convex.

(g) The set of points whose distance to a does not exceed a fixed fraction θ of the
distance to b, i.e., the set {x | ‖x − a‖2 ≤ θ‖x − b‖2}. You can assume a 6= b and
0 ≤ θ ≤ 1.

2.13 Conic hull of outer products. Consider the set of rank-k outer products, defined as
{XXT | X ∈ Rn×k, rankX = k}. Describe its conic hull in simple terms.

2.14 Expanded and restricted sets. Let S ⊆ Rn, and let ‖ · ‖ be a norm on Rn.
(a) For a ≥ 0 we define Sa as {x | dist(x, S) ≤ a}, where dist(x, S) = infy∈S ‖x − y‖.

We refer to Sa as S expanded or extended by a. Show that if S is convex, then Sa
is convex.

(b) For a ≥ 0 we define S−a = {x | B(x, a) ⊆ S}, where B(x, a) is the ball (in the norm
‖ · ‖), centered at x, with radius a. We refer to S−a as S shrunk or restricted by a,
since S−a consists of all points that are at least a distance a from R

n\S. Show that
if S is convex, then S−a is convex.



62 2 Convex sets

2.15 Some sets of probability distributions. Let x be a real-valued random variable with
prob(x = ai) = pi, i = 1, . . . , n, where a1 < a2 < · · · < an. Of course p ∈ Rn lies
in the standard probability simplex P = {p | 1T p = 1, p � 0}. Which of the following
conditions are convex in p? (That is, for which of the following conditions is the set of
p ∈ P that satisfy the condition convex?)
(a) α ≤ E f(x) ≤ β, where E f(x) is the expected value of f(x), i.e., E f(x) =∑n

i=1
pif(ai). (The function f : R→ R is given.)

(b) prob(x > α) ≤ β.
(c) E |x3| ≤ αE |x|.
(d) Ex2 ≤ α.
(e) Ex2 ≥ α.
(f) var(x) ≤ α, where var(x) = E(x−Ex)2 is the variance of x.
(g) var(x) ≥ α.
(h) quartile(x) ≥ α, where quartile(x) = inf{β | prob(x ≤ β) ≥ 0.25}.
(i) quartile(x) ≤ α.

Operations that preserve convexity

2.16 Show that if S1 and S2 are convex sets in R
m+n, then so is their partial sum

S = {(x, y1 + y2) | x ∈ Rm, y1, y2 ∈ Rn, (x, y1) ∈ S1, (x, y2) ∈ S2}.

2.17 Image of polyhedral sets under perspective function. In this problem we study the image
of hyperplanes, halfspaces, and polyhedra under the perspective function P (x, t) = x/t,
with domP = Rn ×R++. For each of the following sets C, give a simple description of

P (C) = {v/t | (v, t) ∈ C, t > 0}.
(a) The polyhedron C = conv{(v1, t1), . . . , (vK , tK)} where vi ∈ Rn and ti > 0.
(b) The hyperplane C = {(v, t) | fT v + gt = h} (with f and g not both zero).
(c) The halfspace C = {(v, t) | fT v + gt ≤ h} (with f and g not both zero).
(d) The polyhedron C = {(v, t) | Fv + gt � h}.

2.18 Invertible linear-fractional functions. Let f : Rn → Rn be the linear-fractional function
f(x) = (Ax+ b)/(cTx+ d), dom f = {x | cTx+ d > 0}.

Suppose the matrix

Q =

[
A b
cT d

]
is nonsingular. Show that f is invertible and that f−1 is a linear-fractional mapping.
Give an explicit expression for f−1 and its domain in terms of A, b, c, and d. Hint. It
may be easier to express f−1 in terms of Q.

2.19 Linear-fractional functions and convex sets. Let f : Rm → Rn be the linear-fractional
function

f(x) = (Ax+ b)/(cTx+ d), dom f = {x | cTx+ d > 0}.
In this problem we study the inverse image of a convex set C under f , i.e.,

f−1(C) = {x ∈ dom f | f(x) ∈ C}.
For each of the following sets C ⊆ Rn, give a simple description of f−1(C).



Exercises 63

(a) The halfspace C = {y | gT y ≤ h} (with g 6= 0).
(b) The polyhedron C = {y | Gy � h}.
(c) The ellipsoid {y | yTP−1y ≤ 1} (where P ∈ Sn++).
(d) The solution set of a linear matrix inequality, C = {y | y1A1 + · · · + ynAn � B},

where A1, . . . , An, B ∈ Sp.

Separation theorems and supporting hyperplanes

2.20 Strictly positive solution of linear equations. Suppose A ∈ Rm×n, b ∈ Rm, with b ∈ R(A).
Show that there exists an x satisfying

x ≻ 0, Ax = b
if and only if there exists no λ with

ATλ � 0, ATλ 6= 0, bTλ ≤ 0.
Hint. First prove the following fact from linear algebra: cTx = d for all x satisfying
Ax = b if and only if there is a vector λ such that c = ATλ, d = bTλ.

2.21 The set of separating hyperplanes. Suppose that C and D are disjoint subsets of Rn.
Consider the set of (a, b) ∈ Rn+1 for which aTx ≤ b for all x ∈ C, and aTx ≥ b for all
x ∈ D. Show that this set is a convex cone (which is the singleton {0} if there is no
hyperplane that separates C and D).

2.22 Finish the proof of the separating hyperplane theorem in §2.5.1: Show that a separating
hyperplane exists for two disjoint convex sets C and D. You can use the result proved
in §2.5.1, i.e., that a separating hyperplane exists when there exist points in the two sets
whose distance is equal to the distance between the two sets.

Hint. If C and D are disjoint convex sets, then the set {x− y | x ∈ C, y ∈ D} is convex
and does not contain the origin.

2.23 Give an example of two closed convex sets that are disjoint but cannot be strictly sepa-
rated.

2.24 Supporting hyperplanes.

(a) Express the closed convex set {x ∈ R2+ | x1x2 ≥ 1} as an intersection of halfspaces.
(b) Let C = {x ∈ Rn | ‖x‖∞ ≤ 1}, the ℓ∞-norm unit ball in Rn, and let xˆ be a point

in the boundary of C. Identify the supporting hyperplanes of C at xˆ explicitly.

2.25 Inner and outer polyhedral approximations. Let C ⊆ Rn be a closed convex set, and
suppose that x1, . . . , xK are on the boundary of C. Suppose that for each i, a

T
i (x−xi) = 0

defines a supporting hyperplane for C at xi, i.e., C ⊆ {x | aTi (x− xi) ≤ 0}. Consider the
two polyhedra

Pinner = conv{x1, . . . , xK}, Pouter = {x | aTi (x− xi) ≤ 0, i = 1, . . . ,K}.
Show that Pinner ⊆ C ⊆ Pouter. Draw a picture illustrating this.

2.26 Support function. The support function of a set C ⊆ Rn is defined as

SC(y) = sup{yTx | x ∈ C}.
(We allow SC(y) to take on the value +∞.) Suppose that C and D are closed convex sets
in Rn. Show that C = D if and only if their support functions are equal.

2.27 Converse supporting hyperplane theorem. Suppose the set C is closed, has nonempty
interior, and has a supporting hyperplane at every point in its boundary. Show that C is
convex.



64 2 Convex sets

Convex cones and generalized inequalities

2.28 Positive semidefinite cone for n = 1, 2, 3. Give an explicit description of the positive
semidefinite cone Sn+, in terms of the matrix coefficients and ordinary inequalities, for
n = 1, 2, 3. To describe a general element of Sn, for n = 1, 2, 3, use the notation

x1,

[
x1 x2
x2 x3

]
,

[
x1 x2 x3
x2 x4 x5
x3 x5 x6

]
.

2.29 Cones in R2. Suppose K ⊆ R2 is a closed convex cone.
(a) Give a simple description of K in terms of the polar coordinates of its elements

(x = r(cosφ, sinφ) with r ≥ 0).
(b) Give a simple description of K∗, and draw a plot illustrating the relation between

K and K∗.

(c) When is K pointed?

(d) When is K proper (hence, defines a generalized inequality)? Draw a plot illustrating
what x �K y means when K is proper.

2.30 Properties of generalized inequalities. Prove the properties of (nonstrict and strict) gen-
eralized inequalities listed in §2.4.1.

2.31 Properties of dual cones. Let K∗ be the dual cone of a convex cone K, as defined in (2.19).
Prove the following.

(a) K∗ is indeed a convex cone.

(b) K1 ⊆ K2 implies K∗2 ⊆ K∗1 .
(c) K∗ is closed.

(d) The interior of K∗ is given by intK∗ = {y | yTx > 0 for all x ∈ clK}.
(e) If K has nonempty interior then K∗ is pointed.

(f) K∗∗ is the closure of K. (Hence if K is closed, K∗∗ = K.)

(g) If the closure of K is pointed then K∗ has nonempty interior.

2.32 Find the dual cone of {Ax | x � 0}, where A ∈ Rm×n.
2.33 The monotone nonnegative cone. We define the monotone nonnegative cone as

Km+ = {x ∈ Rn | x1 ≥ x2 ≥ · · · ≥ xn ≥ 0}.
i.e., all nonnegative vectors with components sorted in nonincreasing order.

(a) Show that Km+ is a proper cone.

(b) Find the dual cone K∗m+. Hint. Use the identity

n∑
i=1

xiyi = (x1 − x2)y1 + (x2 − x3)(y1 + y2) + (x3 − x4)(y1 + y2 + y3) + · · ·

+ (xn−1 − xn)(y1 + · · ·+ yn−1) + xn(y1 + · · ·+ yn).

2.34 The lexicographic cone and ordering. The lexicographic cone is defined as

Klex = {0} ∪ {x ∈ Rn | x1 = · · · = xk = 0, xk+1 > 0, for some k, 0 ≤ k < n},
i.e., all vectors whose first nonzero coefficient (if any) is positive.

(a) Verify that Klex is a cone, but not a proper cone.



Exercises 65

(b) We define the lexicographic ordering on Rn as follows: x ≤lex y if and only if
y − x ∈ Klex. (Since Klex is not a proper cone, the lexicographic ordering is not a
generalized inequality.) Show that the lexicographic ordering is a linear ordering :
for any x, y ∈ Rn, either x ≤lex y or y ≤lex x. Therefore any set of vectors can be
sorted with respect to the lexicographic cone, which yields the familiar sorting used
in dictionaries.

(c) Find K∗lex.

2.35 Copositive matrices. A matrix X ∈ Sn is called copositive if zTXz ≥ 0 for all z � 0.
Verify that the set of copositive matrices is a proper cone. Find its dual cone.

2.36 Euclidean distance matrices. Let x1, . . . , xn ∈ Rk. The matrix D ∈ Sn defined by Dij =
‖xi− xj‖22 is called a Euclidean distance matrix. It satisfies some obvious properties such
as Dij = Dji, Dii = 0, Dij ≥ 0, and (from the triangle inequality) D1/2ik ≤ D1/2ij +D1/2jk .
We now pose the question: When is a matrix D ∈ Sn a Euclidean distance matrix (for
some points in Rk, for some k)? A famous result answers this question: D ∈ Sn is a
Euclidean distance matrix if and only if Dii = 0 and x

TDx ≤ 0 for all x with 1Tx = 0.
(See §8.3.3.)
Show that the set of Euclidean distance matrices is a convex cone.

2.37 Nonnegative polynomials and Hankel LMIs. Let Kpol be the set of (coefficients of) non-
negative polynomials of degree 2k on R:

Kpol = {x ∈ R2k+1 | x1 + x2t+ x3t2 + · · ·+ x2k+1t2k ≥ 0 for all t ∈ R}.

(a) Show that Kpol is a proper cone.

(b) A basic result states that a polynomial of degree 2k is nonnegative on R if and only
if it can be expressed as the sum of squares of two polynomials of degree k or less.
In other words, x ∈ Kpol if and only if the polynomial

p(t) = x1 + x2t+ x3t
2 + · · ·+ x2k+1t2k

can be expressed as
p(t) = r(t)2 + s(t)2,

where r and s are polynomials of degree k.

Use this result to show that

Kpol =

{
x ∈ R2k+1

∣∣∣∣∣ xi = ∑
m+n=i+1

Ymn for some Y ∈ Sk+1+
}
.

In other words, p(t) = x1 + x2t+ x3t
2 + · · ·+ x2k+1t2k is nonnegative if and only if

there exists a matrix Y ∈ Sk+1+ such that

x1 = Y11

x2 = Y12 + Y21

x3 = Y13 + Y22 + Y31
...

x2k+1 = Yk+1,k+1.

(c) Show that K∗pol = Khan where

Khan = {z ∈ R2k+1 | H(z) � 0}



66 2 Convex sets

and

H(z) =



z1 z2 z3 · · · zk zk+1
z2 z3 z4 · · · zk+1 zk+2
z3 z4 z5 · · · zk+2 zk+4
...

...
...

. . .
...

...
zk zk+1 zk+2 · · · z2k−1 z2k
zk+1 zk+2 zk+3 · · · z2k z2k+1

 .
(This is the Hankel matrix with coefficients z1, . . . , z2k+1.)

(d) Let Kmom be the conic hull of the set of all vectors of the form (1, t, t
2, . . . , t2k),

where t ∈ R. Show that y ∈ Kmom if and only if y1 ≥ 0 and

y = y1(1,Eu,Eu
2, . . . ,Eu2k)

for some random variable u. In other words, the elements of Kmom are nonnegative
multiples of the moment vectors of all possible distributions onR. Show thatKpol =
K∗mom.

(e) Combining the results of (c) and (d), conclude that Khan = clKmom.

As an example illustrating the relation between Kmom and Khan, take k = 2 and
z = (1, 0, 0, 0, 1). Show that z ∈ Khan, z 6∈ Kmom. Find an explicit sequence of
points in Kmom which converge to z.

2.38 [Roc70, pages 15, 61] Convex cones constructed from sets.

(a) The barrier cone of a set C is defined as the set of all vectors y such that yTx is
bounded above over x ∈ C. In other words, a nonzero vector y is in the barrier cone
if and only if it is the normal vector of a halfspace {x | yTx ≤ α} that contains C.
Verify that the barrier cone is a convex cone (with no assumptions on C).

(b) The recession cone (also called asymptotic cone) of a set C is defined as the set of
all vectors y such that for each x ∈ C, x − ty ∈ C for all t ≥ 0. Show that the
recession cone of a convex set is a convex cone. Show that if C is nonempty, closed,
and convex, then the recession cone of C is the dual of the barrier cone.

(c) The normal cone of a set C at a boundary point x0 is the set of all vectors y such
that yT (x − x0) ≤ 0 for all x ∈ C (i.e., the set of vectors that define a supporting
hyperplane to C at x0). Show that the normal cone is a convex cone (with no
assumptions on C). Give a simple description of the normal cone of a polyhedron
{x | Ax � b} at a point in its boundary.

2.39 Separation of cones. Let K and K˜ be two convex cones whose interiors are nonempty and
disjoint. Show that there is a nonzero y such that y ∈ K∗, −y ∈ K˜∗.



Chapter 3

Convex functions

3.1 Basic properties and examples

3.1.1 Definition

A function f : Rn → R is convex if dom f is a convex set and if for all x,
y ∈ dom f , and θ with 0 ≤ θ ≤ 1, we have

f(θx+ (1− θ)y) ≤ θf(x) + (1− θ)f(y). (3.1)

Geometrically, this inequality means that the line segment between (x, f(x)) and
(y, f(y)), which is the chord from x to y, lies above the graph of f (figure 3.1).
A function f is strictly convex if strict inequality holds in (3.1) whenever x 6= y
and 0 < θ < 1. We say f is concave if −f is convex, and strictly concave if −f is
strictly convex.

For an affine function we always have equality in (3.1), so all affine (and therefore
also linear) functions are both convex and concave. Conversely, any function that
is convex and concave is affine.

A function is convex if and only if it is convex when restricted to any line that
intersects its domain. In other words f is convex if and only if for all x ∈ dom f and

(x, f(x))

(y, f(y))

Figure 3.1 Graph of a convex function. The chord (i.e., line segment) be-
tween any two points on the graph lies above the graph.



68 3 Convex functions

all v, the function g(t) = f(x+ tv) is convex (on its domain, {t | x+ tv ∈ dom f}).
This property is very useful, since it allows us to check whether a function is convex
by restricting it to a line.

The analysis of convex functions is a well developed field, which we will not
pursue in any depth. One simple result, for example, is that a convex function is
continuous on the relative interior of its domain; it can have discontinuities only
on its relative boundary.

3.1.2 Extended-value extensions

It is often convenient to extend a convex function to all of Rn by defining its value
to be ∞ outside its domain. If f is convex we define its extended-value extension
f˜ : Rn → R ∪ {∞} by

f˜(x) =

{
f(x) x ∈ dom f
∞ x 6∈ dom f.

The extension f˜ is defined on all Rn, and takes values in R∪{∞}. We can recover
the domain of the original function f from the extension f˜ as dom f = {x | f˜(x) <
∞}.

The extension can simplify notation, since we do not need to explicitly describe
the domain, or add the qualifier ‘for all x ∈ dom f ’ every time we refer to f(x).
Consider, for example, the basic defining inequality (3.1). In terms of the extension
f˜ , we can express it as: for 0 < θ < 1,

f˜(θx+ (1− θ)y) ≤ θf˜(x) + (1− θ)f˜(y)

for any x and y. (For θ = 0 or θ = 1 the inequality always holds.) Of course here we
must interpret the inequality using extended arithmetic and ordering. For x and y
both in dom f , this inequality coincides with (3.1); if either is outside dom f , then
the righthand side is ∞, and the inequality therefore holds. As another example
of this notational device, suppose f1 and f2 are two convex functions on R

n. The
pointwise sum f = f1+f2 is the function with domain dom f = dom f1∩dom f2,
with f(x) = f1(x)+ f2(x) for any x ∈ dom f . Using extended-value extensions we
can simply say that for any x, f˜(x) = f˜1(x) + f˜2(x). In this equation the domain
of f has been automatically defined as dom f = dom f1∩dom f2, since f˜(x) =∞
whenever x 6∈ dom f1 or x 6∈ dom f2. In this example we are relying on extended
arithmetic to automatically define the domain.

In this book we will use the same symbol to denote a convex function and its
extension, whenever there is no harm from the ambiguity. This is the same as
assuming that all convex functions are implicitly extended, i.e., are defined as ∞
outside their domains.

Example 3.1 Indicator function of a convex set. Let C ⊆ Rn be a convex set, and
consider the (convex) function IC with domain C and IC(x) = 0 for all x ∈ C. In
other words, the function is identically zero on the set C. Its extended-value extension



3.1 Basic properties and examples 69

(x, f(x))

f(y)

f(x) +∇f(x)T (y − x)

Figure 3.2 If f is convex and differentiable, then f(x)+∇f(x)T (y−x) ≤ f(y)
for all x, y ∈ dom f .

is given by

I˜C(x) =

{
0 x ∈ C
∞ x 6∈ C.

The convex function I˜C is called the indicator function of the set C.

We can play several notational tricks with the indicator function I˜C . For example
the problem of minimizing a function f (defined on all of Rn, say) on the set C is the
same as minimizing the function f + I˜C over all of R

n. Indeed, the function f + I˜C
is (by our convention) f restricted to the set C.

In a similar way we can extend a concave function by defining it to be −∞
outside its domain.

3.1.3 First-order conditions

Suppose f is differentiable (i.e., its gradient ∇f exists at each point in dom f ,
which is open). Then f is convex if and only if dom f is convex and

f(y) ≥ f(x) +∇f(x)T (y − x) (3.2)

holds for all x, y ∈ dom f . This inequality is illustrated in figure 3.2.
The affine function of y given by f(x)+∇f(x)T (y−x) is, of course, the first-order

Taylor approximation of f near x. The inequality (3.2) states that for a convex
function, the first-order Taylor approximation is in fact a global underestimator of
the function. Conversely, if the first-order Taylor approximation of a function is
always a global underestimator of the function, then the function is convex.

The inequality (3.2) shows that from local information about a convex function
(i.e., its value and derivative at a point) we can derive global information (i.e., a
global underestimator of it). This is perhaps the most important property of convex
functions, and explains some of the remarkable properties of convex functions and
convex optimization problems. As one simple example, the inequality (3.2) shows
that if ∇f(x) = 0, then for all y ∈ dom f , f(y) ≥ f(x), i.e., x is a global minimizer
of the function f .



70 3 Convex functions

Strict convexity can also be characterized by a first-order condition: f is strictly
convex if and only if dom f is convex and for x, y ∈ dom f , x 6= y, we have

f(y) > f(x) +∇f(x)T (y − x). (3.3)
For concave functions we have the corresponding characterization: f is concave

if and only if dom f is convex and

f(y) ≤ f(x) +∇f(x)T (y − x)
for all x, y ∈ dom f .

Proof of first-order convexity condition

To prove (3.2), we first consider the case n = 1: We show that a differentiable
function f : R→ R is convex if and only if

f(y) ≥ f(x) + f ′(x)(y − x) (3.4)
for all x and y in dom f .

Assume first that f is convex and x, y ∈ dom f . Since dom f is convex (i.e.,
an interval), we conclude that for all 0 < t ≤ 1, x + t(y − x) ∈ dom f , and by
convexity of f ,

f(x+ t(y − x)) ≤ (1− t)f(x) + tf(y).
If we divide both sides by t, we obtain

f(y) ≥ f(x) + f(x+ t(y − x))− f(x)
t

,

and taking the limit as t→ 0 yields (3.4).
To show sufficiency, assume the function satisfies (3.4) for all x and y in dom f

(which is an interval). Choose any x 6= y, and 0 ≤ θ ≤ 1, and let z = θx+(1− θ)y.
Applying (3.4) twice yields

f(x) ≥ f(z) + f ′(z)(x− z), f(y) ≥ f(z) + f ′(z)(y − z).
Multiplying the first inequality by θ, the second by 1− θ, and adding them yields

θf(x) + (1− θ)f(y) ≥ f(z),
which proves that f is convex.

Now we can prove the general case, with f : Rn → R. Let x, y ∈ Rn and
consider f restricted to the line passing through them, i.e., the function defined by
g(t) = f(ty + (1− t)x), so g′(t) = ∇f(ty + (1− t)x)T (y − x).

First assume f is convex, which implies g is convex, so by the argument above
we have g(1) ≥ g(0) + g′(0), which means

f(y) ≥ f(x) +∇f(x)T (y − x).
Now assume that this inequality holds for any x and y, so if ty+(1− t)x ∈ dom f
and t˜y + (1− t˜)x ∈ dom f , we have

f(ty + (1− t)x) ≥ f(t˜y + (1− t˜)x) +∇f(t˜y + (1− t˜)x)T (y − x)(t− t˜),
i.e., g(t) ≥ g(t˜) + g′(t˜)(t− t˜). We have seen that this implies that g is convex.



3.1 Basic properties and examples 71

3.1.4 Second-order conditions

We now assume that f is twice differentiable, that is, its Hessian or second deriva-
tive ∇2f exists at each point in dom f , which is open. Then f is convex if and
only if dom f is convex and its Hessian is positive semidefinite: for all x ∈ dom f ,

∇2f(x) � 0.
For a function on R, this reduces to the simple condition f ′′(x) ≥ 0 (and dom f
convex, i.e., an interval), which means that the derivative is nondecreasing. The
condition ∇2f(x) � 0 can be interpreted geometrically as the requirement that the
graph of the function have positive (upward) curvature at x. We leave the proof
of the second-order condition as an exercise (exercise 3.8).

Similarly, f is concave if and only if dom f is convex and ∇2f(x) � 0 for
all x ∈ dom f . Strict convexity can be partially characterized by second-order
conditions. If ∇2f(x) ≻ 0 for all x ∈ dom f , then f is strictly convex. The
converse, however, is not true: for example, the function f : R → R given by
f(x) = x4 is strictly convex but has zero second derivative at x = 0.

Example 3.2 Quadratic functions. Consider the quadratic function f : Rn → R, with
dom f = Rn, given by

f(x) = (1/2)xTPx+ qTx+ r,

with P ∈ Sn, q ∈ Rn, and r ∈ R. Since ∇2f(x) = P for all x, f is convex if and only
if P � 0 (and concave if and only if P � 0).
For quadratic functions, strict convexity is easily characterized: f is strictly convex
if and only if P ≻ 0 (and strictly concave if and only if P ≺ 0).

Remark 3.1 The separate requirement that dom f be convex cannot be dropped from
the first- or second-order characterizations of convexity and concavity. For example,
the function f(x) = 1/x2, with dom f = {x ∈ R | x 6= 0}, satisfies f ′′(x) > 0 for all
x ∈ dom f , but is not a convex function.

3.1.5 Examples

We have already mentioned that all linear and affine functions are convex (and
concave), and have described the convex and concave quadratic functions. In this
section we give a few more examples of convex and concave functions. We start
with some functions on R, with variable x.

• Exponential. eax is convex on R, for any a ∈ R.
• Powers. xa is convex onR++ when a ≥ 1 or a ≤ 0, and concave for 0 ≤ a ≤ 1.
• Powers of absolute value. |x|p, for p ≥ 1, is convex on R.
• Logarithm. log x is concave on R++.



72 3 Convex functions

xy

f
(x
,y
)

−2
0

2

0

1

2
0

1

2

Figure 3.3 Graph of f(x, y) = x2/y.

• Negative entropy. x log x (either on R++, or on R+, defined as 0 for x = 0)
is convex.

Convexity or concavity of these examples can be shown by verifying the ba-
sic inequality (3.1), or by checking that the second derivative is nonnegative or
nonpositive. For example, with f(x) = x log x we have

f ′(x) = log x+ 1, f ′′(x) = 1/x,

so that f ′′(x) > 0 for x > 0. This shows that the negative entropy function is
(strictly) convex.

We now give a few interesting examples of functions on Rn.

• Norms. Every norm on Rn is convex.
• Max function. f(x) = max{x1, . . . , xn} is convex on Rn.
• Quadratic-over-linear function. The function f(x, y) = x2/y, with

dom f = R×R++ = {(x, y) ∈ R2 | y > 0},

is convex (figure 3.3).

• Log-sum-exp. The function f(x) = log (ex1 + · · ·+ exn) is convex on Rn.
This function can be interpreted as a differentiable (in fact, analytic) approx-
imation of the max function, since

max{x1, . . . , xn} ≤ f(x) ≤ max{x1, . . . , xn}+ log n

for all x. (The second inequality is tight when all components of x are equal.)
Figure 3.4 shows f for n = 2.



3.1 Basic properties and examples 73

xy

f
(x
,y
)

−2 0
2

−2
0

2

−2

0

2

4

Figure 3.4 Graph of f(x, y) = log(ex + ey).

• Geometric mean. The geometric mean f(x) = (∏ni=1 xi)1/n is concave on
dom f = Rn++.

• Log-determinant. The function f(X) = log detX is concave on dom f =
Sn++.

Convexity (or concavity) of these examples can be verified in several ways,
such as directly verifying the inequality (3.1), verifying that the Hessian is positive
semidefinite, or restricting the function to an arbitrary line and verifying convexity
of the resulting function of one variable.

Norms. If f : Rn → R is a norm, and 0 ≤ θ ≤ 1, then
f(θx+ (1− θ)y) ≤ f(θx) + f((1− θ)y) = θf(x) + (1− θ)f(y).

The inequality follows from the triangle inequality, and the equality follows from
homogeneity of a norm.

Max function. The function f(x) = maxi xi satisfies, for 0 ≤ θ ≤ 1,
f(θx+ (1− θ)y) = max

i
(θxi + (1− θ)yi)

≤ θmax
i

xi + (1− θ)max
i

yi

= θf(x) + (1− θ)f(y).

Quadratic-over-linear function. To show that the quadratic-over-linear function
f(x, y) = x2/y is convex, we note that (for y > 0),

∇2f(x, y) = 2
y3

[
y2 −xy
−xy x2

]
=

2

y3

[
y
−x

] [
y
−x

]T
� 0.



74 3 Convex functions

Log-sum-exp. The Hessian of the log-sum-exp function is

∇2f(x) = 1
(1T z)2

(
(1T z)diag(z)− zzT ) ,

where z = (ex1 , . . . , exn). To verify that ∇2f(x) � 0 we must show that for all v,
vT∇2f(x)v ≥ 0, i.e.,

vT∇2f(x)v = 1
(1T z)2

( n∑
i=1

zi

)(
n∑
i=1

v2i zi

)
−
(

n∑
i=1

vizi

)2 ≥ 0.
But this follows from the Cauchy-Schwarz inequality (aT a)(bT b) ≥ (aT b)2 applied
to the vectors with components ai = vi

√
zi, bi =

√
zi.

Geometric mean. In a similar way we can show that the geometric mean f(x) =

(
∏n

i=1 xi)
1/n

is concave on dom f = Rn++. Its Hessian ∇2f(x) is given by
∂2f(x)

∂x2k
= −(n− 1)(

∏n
i=1 xi)

1/n

n2x2k
,

∂2f(x)

∂xk∂xl
=

(
∏n

i=1 xi)
1/n

n2xkxl
for k 6= l,

and can be expressed as

∇2f(x) = −
∏n

i=1 x
1/n
i

n2
(
ndiag(1/x21, . . . , 1/x

2
n)− qqT

)
where qi = 1/xi. We must show that ∇2f(x) � 0, i.e., that

vT∇2f(x)v = −
∏n

i=1 x
1/n
i

n2

n n∑
i=1

v2i /x
2
i −

(
n∑
i=1

vi/xi

)2 ≤ 0
for all v. Again this follows from the Cauchy-Schwarz inequality (aT a)(bT b) ≥
(aT b)2, applied to the vectors a = 1 and bi = vi/xi.

Log-determinant. For the function f(X) = log detX, we can verify concavity by
considering an arbitrary line, given by X = Z + tV , where Z, V ∈ Sn. We define
g(t) = f(Z+ tV ), and restrict g to the interval of values of t for which Z+ tV ≻ 0.
Without loss of generality, we can assume that t = 0 is inside this interval, i.e.,
Z ≻ 0. We have

g(t) = log det(Z + tV )

= log det(Z1/2(I + tZ−1/2V Z−1/2)Z1/2)

=

n∑
i=1

log(1 + tλi) + log detZ

where λ1, . . . , λn are the eigenvalues of Z
−1/2V Z−1/2. Therefore we have

g′(t) =

n∑
i=1

λi
1 + tλi

, g′′(t) = −
n∑
i=1

λ2i
(1 + tλi)2

.

Since g′′(t) ≤ 0, we conclude that f is concave.



3.1 Basic properties and examples 75

3.1.6 Sublevel sets

The α-sublevel set of a function f : Rn → R is defined as
Cα = {x ∈ dom f | f(x) ≤ α}.

Sublevel sets of a convex function are convex, for any value of α. The proof is
immediate from the definition of convexity: if x, y ∈ Cα, then f(x) ≤ α and
f(y) ≤ α, and so f(θx+(1− θ)y) ≤ α for 0 ≤ θ ≤ 1, and hence θx+(1− θ)y ∈ Cα.

The converse is not true: a function can have all its sublevel sets convex, but
not be a convex function. For example, f(x) = −ex is not convex on R (indeed, it
is strictly concave) but all its sublevel sets are convex.

If f is concave, then its α-superlevel set, given by {x ∈ dom f | f(x) ≥ α}, is a
convex set. The sublevel set property is often a good way to establish convexity of
a set, by expressing it as a sublevel set of a convex function, or as the superlevel
set of a concave function.

Example 3.3 The geometric and arithmetic means of x ∈ Rn+ are, respectively,

G(x) =

(
n∏
i=1

xi

)1/n
, A(x) =

1

n

n∑
i=1

xi,

(where we take 01/n = 0 in our definition of G). The arithmetic-geometric mean
inequality states that G(x) ≤ A(x).
Suppose 0 ≤ α ≤ 1, and consider the set

{x ∈ Rn+ | G(x) ≥ αA(x)},
i.e., the set of vectors with geometric mean at least as large as a factor α times the
arithmetic mean. This set is convex, since it is the 0-superlevel set of the function
G(x)− αA(x), which is concave. In fact, the set is positively homogeneous, so it is a
convex cone.

3.1.7 Epigraph

The graph of a function f : Rn → R is defined as
{(x, f(x)) | x ∈ dom f},

which is a subset of Rn+1. The epigraph of a function f : Rn → R is defined as
epi f = {(x, t) | x ∈ dom f, f(x) ≤ t},

which is a subset of Rn+1. (‘Epi’ means ‘above’ so epigraph means ‘above the
graph’.) The definition is illustrated in figure 3.5.

The link between convex sets and convex functions is via the epigraph: A
function is convex if and only if its epigraph is a convex set. A function is concave
if and only if its hypograph, defined as

hypo f = {(x, t) | t ≤ f(x)},
is a convex set.



76 3 Convex functions

epi f

f

Figure 3.5 Epigraph of a function f , shown shaded. The lower boundary,
shown darker, is the graph of f .

Example 3.4 Matrix fractional function. The function f : Rn × Sn → R, defined as
f(x, Y ) = xTY −1x

is convex on dom f = Rn×Sn++. (This generalizes the quadratic-over-linear function
f(x, y) = x2/y, with dom f = R×R++.)
One easy way to establish convexity of f is via its epigraph:

epi f = {(x, Y, t) | Y ≻ 0, xTY −1x ≤ t}

=

{
(x, Y, t)

∣∣∣∣ [ Y xxT t
]
� 0, Y ≻ 0

}
,

using the Schur complement condition for positive semidefiniteness of a block matrix
(see §A.5.5). The last condition is a linear matrix inequality in (x, Y, t), and therefore
epi f is convex.

For the special case n = 1, the matrix fractional function reduces to the quadratic-
over-linear function x2/y, and the associated LMI representation is[

y x
x t

]
� 0, y > 0

(the graph of which is shown in figure 3.3).

Many results for convex functions can be proved (or interpreted) geometrically
using epigraphs, and applying results for convex sets. As an example, consider the
first-order condition for convexity:

f(y) ≥ f(x) +∇f(x)T (y − x),
where f is convex and x, y ∈ dom f . We can interpret this basic inequality
geometrically in terms of epi f . If (y, t) ∈ epi f , then

t ≥ f(y) ≥ f(x) +∇f(x)T (y − x).



3.1 Basic properties and examples 77

epi f

(∇f(x),−1)

(x, f(x))

Figure 3.6 For a differentiable convex function f , the vector (∇f(x),−1)
defines a supporting hyperplane to the epigraph of f at x.

We can express this as:

(y, t) ∈ epi f =⇒
[ ∇f(x)

−1
]T ([

y
t

]
−
[

x
f(x)

])
≤ 0.

This means that the hyperplane defined by (∇f(x),−1) supports epi f at the
boundary point (x, f(x)); see figure 3.6.

3.1.8 Jensen’s inequality and extensions

The basic inequality (3.1), i.e.,

f(θx+ (1− θ)y) ≤ θf(x) + (1− θ)f(y),
is sometimes called Jensen’s inequality. It is easily extended to convex combinations
of more than two points: If f is convex, x1, . . . , xk ∈ dom f , and θ1, . . . , θk ≥ 0
with θ1 + · · ·+ θk = 1, then

f(θ1x1 + · · ·+ θkxk) ≤ θ1f(x1) + · · ·+ θkf(xk).
As in the case of convex sets, the inequality extends to infinite sums, integrals, and
expected values. For example, if p(x) ≥ 0 on S ⊆ dom f , ∫

S
p(x) dx = 1, then

f

(∫
S

p(x)x dx

)
≤
∫
S

f(x)p(x) dx,

provided the integrals exist. In the most general case we can take any probability
measure with support in dom f . If x is a random variable such that x ∈ dom f
with probability one, and f is convex, then we have

f(Ex) ≤ E f(x), (3.5)
provided the expectations exist. We can recover the basic inequality (3.1) from
this general form, by taking the random variable x to have support {x1, x2}, with



78 3 Convex functions

prob(x = x1) = θ, prob(x = x2) = 1− θ. Thus the inequality (3.5) characterizes
convexity: If f is not convex, there is a random variable x, with x ∈ dom f with
probability one, such that f(Ex) > E f(x).

All of these inequalities are now called Jensen’s inequality, even though the
inequality studied by Jensen was the very simple one

f

(
x+ y

2

)
≤ f(x) + f(y)

2
.

Remark 3.2 We can interpret (3.5) as follows. Suppose x ∈ dom f ⊆ Rn and z is
any zero mean random vector in Rn. Then we have

E f(x+ z) ≥ f(x).
Thus, randomization or dithering (i.e., adding a zero mean random vector to the
argument) cannot decrease the value of a convex function on average.

3.1.9 Inequalities

Many famous inequalities can be derived by applying Jensen’s inequality to some
appropriate convex function. (Indeed, convexity and Jensen’s inequality can be
made the foundation of a theory of inequalities.) As a simple example, consider
the arithmetic-geometric mean inequality:√

ab ≤ (a+ b)/2 (3.6)
for a, b ≥ 0. The function − log x is convex; Jensen’s inequality with θ = 1/2 yields

− log
(
a+ b

2

)
≤ − log a− log b

2
.

Taking the exponential of both sides yields (3.6).
As a less trivial example we prove Ho¨lder’s inequality: for p > 1, 1/p+1/q = 1,

and x, y ∈ Rn,
n∑
i=1

xiyi ≤
(

n∑
i=1

|xi|p
)1/p( n∑

i=1

|yi|q
)1/q

.

By convexity of − log x, and Jensen’s inequality with general θ, we obtain the more
general arithmetic-geometric mean inequality

aθb1−θ ≤ θa+ (1− θ)b,
valid for a, b ≥ 0 and 0 ≤ θ ≤ 1. Applying this with

a =
|xi|p∑n
j=1 |xj |p

, b =
|yi|q∑n
j=1 |yj |q

, θ = 1/p,

yields (
|xi|p∑n
j=1 |xj |p

)1/p( |yi|q∑n
j=1 |yj |q

)1/q
≤ |xi|

p

p
∑n

j=1 |xj |p
+

|yi|q
q
∑n

j=1 |yj |q
.

Summing over i then yields Ho¨lder’s inequality.



3.2 Operations that preserve convexity 79

3.2 Operations that preserve convexity

In this section we describe some operations that preserve convexity or concavity
of functions, or allow us to construct new convex and concave functions. We start
with some simple operations such as addition, scaling, and pointwise supremum,
and then describe some more sophisticated operations (some of which include the
simple operations as special cases).

3.2.1 Nonnegative weighted sums

Evidently if f is a convex function and α ≥ 0, then the function αf is convex.
If f1 and f2 are both convex functions, then so is their sum f1 + f2. Combining
nonnegative scaling and addition, we see that the set of convex functions is itself a
convex cone: a nonnegative weighted sum of convex functions,

f = w1f1 + · · ·+ wmfm,

is convex. Similarly, a nonnegative weighted sum of concave functions is concave. A
nonnegative, nonzero weighted sum of strictly convex (concave) functions is strictly
convex (concave).

These properties extend to infinite sums and integrals. For example if f(x, y)
is convex in x for each y ∈ A, and w(y) ≥ 0 for each y ∈ A, then the function g
defined as

g(x) =

∫
A

w(y)f(x, y) dy

is convex in x (provided the integral exists).

The fact that convexity is preserved under nonnegative scaling and addition is
easily verified directly, or can be seen in terms of the associated epigraphs. For
example, if w ≥ 0 and f is convex, we have

epi(wf) =

[
I 0
0 w

]
epi f,

which is convex because the image of a convex set under a linear mapping is convex.

3.2.2 Composition with an affine mapping

Suppose f : Rn → R, A ∈ Rn×m, and b ∈ Rn. Define g : Rm → R by

g(x) = f(Ax+ b),

with dom g = {x | Ax+ b ∈ dom f}. Then if f is convex, so is g; if f is concave,
so is g.



80 3 Convex functions

3.2.3 Pointwise maximum and supremum

If f1 and f2 are convex functions then their pointwise maximum f , defined by

f(x) = max{f1(x), f2(x)},
with dom f = dom f1 ∩dom f2, is also convex. This property is easily verified: if
0 ≤ θ ≤ 1 and x, y ∈ dom f , then

f(θx+ (1− θ)y) = max{f1(θx+ (1− θ)y), f2(θx+ (1− θ)y)}
≤ max{θf1(x) + (1− θ)f1(y), θf2(x) + (1− θ)f2(y)}
≤ θmax{f1(x), f2(x)}+ (1− θ)max{f1(y), f2(y)}
= θf(x) + (1− θ)f(y),

which establishes convexity of f . It is easily shown that if f1, . . . , fm are convex,
then their pointwise maximum

f(x) = max{f1(x), . . . , fm(x)}
is also convex.

Example 3.5 Piecewise-linear functions. The function

f(x) = max{aT1 x+ b1, . . . , aTLx+ bL}
defines a piecewise-linear (or really, affine) function (with L or fewer regions). It is
convex since it is the pointwise maximum of affine functions.

The converse can also be shown: any piecewise-linear convex function with L or fewer
regions can be expressed in this form. (See exercise 3.29.)

Example 3.6 Sum of r largest components. For x ∈ Rn we denote by x[i] the ith
largest component of x, i.e.,

x[1] ≥ x[2] ≥ · · · ≥ x[n]
are the components of x sorted in nonincreasing order. Then the function

f(x) =

r∑
i=1

x[i],

i.e., the sum of the r largest elements of x, is a convex function. This can be seen by
writing it as

f(x) =

r∑
i=1

x[i] = max{xi1 + · · ·+ xir | 1 ≤ i1 < i2 < · · · < ir ≤ n},

i.e., the maximum of all possible sums of r different components of x. Since it is the
pointwise maximum of n!/(r!(n− r)!) linear functions, it is convex.
As an extension it can be shown that the function

∑r
i=1

wix[i] is convex, provided
w1 ≥ w2 ≥ · · · ≥ wr ≥ 0. (See exercise 3.19.)



3.2 Operations that preserve convexity 81

The pointwise maximum property extends to the pointwise supremum over an
infinite set of convex functions. If for each y ∈ A, f(x, y) is convex in x, then the
function g, defined as

g(x) = sup
y∈A

f(x, y) (3.7)

is convex in x. Here the domain of g is

dom g = {x | (x, y) ∈ dom f for all y ∈ A, sup
y∈A

f(x, y) <∞}.

Similarly, the pointwise infimum of a set of concave functions is a concave function.
In terms of epigraphs, the pointwise supremum of functions corresponds to the

intersection of epigraphs: with f , g, and A as defined in (3.7), we have
epi g =

⋂
y∈A

epi f(·, y).

Thus, the result follows from the fact that the intersection of a family of convex
sets is convex.

Example 3.7 Support function of a set. Let C ⊆ Rn, with C 6= ∅. The support
function SC associated with the set C is defined as

SC(x) = sup{xT y | y ∈ C}
(and, naturally, domSC = {x | supy∈C xT y <∞}).
For each y ∈ C, xT y is a linear function of x, so SC is the pointwise supremum of a
family of linear functions, hence convex.

Example 3.8 Distance to farthest point of a set. Let C ⊆ Rn. The distance (in any
norm) to the farthest point of C,

f(x) = sup
y∈C

‖x− y‖,

is convex. To see this, note that for any y, the function ‖x− y‖ is convex in x. Since
f is the pointwise supremum of a family of convex functions (indexed by y ∈ C), it
is a convex function of x.

Example 3.9 Least-squares cost as a function of weights. Let a1, . . . , an ∈ Rm. In a
weighted least-squares problem we minimize the objective function

∑n
i=1

wi(a
T
i x −

bi)
2 over x ∈ Rm. We refer to wi as weights, and allow negative wi (which opens the

possibility that the objective function is unbounded below).

We define the (optimal) weighted least-squares cost as

g(w) = inf
x

n∑
i=1

wi(a
T
i x− bi)2,

with domain

dom g =

{
w

∣∣∣∣∣ infx
n∑
i=1

wi(a
T
i x− bi)2 > −∞

}
.



82 3 Convex functions

Since g is the infimum of a family of linear functions of w (indexed by x ∈ Rm), it is
a concave function of w.

We can derive an explicit expression for g, at least on part of its domain. Let
W = diag(w), the diagonal matrix with elements w1, . . . , wn, and let A ∈ Rn×m
have rows aTi , so we have

g(w) = inf
x
(Ax− b)TW (Ax− b) = inf

x
(xTATWAx− 2bTWAx+ bTWb).

From this we see that if ATWA 6� 0, the quadratic function is unbounded below
in x, so g(w) = −∞, i.e., w 6∈ dom g. We can give a simple expression for g
when ATWA ≻ 0 (which defines a strict linear matrix inequality), by analytically
minimizing the quadratic function:

g(w) = bTWb− bTWA(ATWA)−1ATWb

=

n∑
i=1

wib
2
i −

n∑
i=1

w2i b
2
i a

T
i

(
n∑
j=1

wjaja
T
j

)−1
ai.

Concavity of g from this expression is not immediately obvious (but does follow, for
example, from convexity of the matrix fractional function; see example 3.4).

Example 3.10 Maximum eigenvalue of a symmetric matrix. The function f(X) =
λmax(X), with dom f = S

m, is convex. To see this, we express f as

f(X) = sup{yTXy | ‖y‖2 = 1},
i.e., as the pointwise supremum of a family of linear functions of X (i.e., yTXy)
indexed by y ∈ Rm.

Example 3.11 Norm of a matrix. Consider f(X) = ‖X‖2 with dom f = Rp×q,
where ‖ · ‖2 denotes the spectral norm or maximum singular value. Convexity of f
follows from

f(X) = sup{uTXv | ‖u‖2 = 1, ‖v‖2 = 1},
which shows it is the pointwise supremum of a family of linear functions of X.

As a generalization suppose ‖ · ‖a and ‖ · ‖b are norms on Rp and Rq, respectively.
The induced norm of a matrix X ∈ Rp×q is defined as

‖X‖a,b = sup
v 6=0

‖Xv‖a
‖v‖b .

(This reduces to the spectral norm when both norms are Euclidean.) The induced
norm can be expressed as

‖X‖a,b = sup{‖Xv‖a | ‖v‖b = 1}
= sup{uTXv | ‖u‖a∗ = 1, ‖v‖b = 1},

where ‖ · ‖a∗ is the dual norm of ‖ · ‖a, and we use the fact that
‖z‖a = sup{uT z | ‖u‖a∗ = 1}.

Since we have expressed ‖X‖a,b as a supremum of linear functions of X, it is a convex
function.



3.2 Operations that preserve convexity 83

Representation as pointwise supremum of affine functions

The examples above illustrate a good method for establishing convexity of a func-
tion: by expressing it as the pointwise supremum of a family of affine functions.
Except for a technical condition, a converse holds: almost every convex function
can be expressed as the pointwise supremum of a family of affine functions. For
example, if f : Rn → R is convex, with dom f = Rn, then we have

f(x) = sup{g(x) | g affine, g(z) ≤ f(z) for all z}.

In other words, f is the pointwise supremum of the set of all affine global under-
estimators of it. We give the proof of this result below, and leave the case where
dom f 6= Rn as an exercise (exercise 3.28).

Suppose f is convex with dom f = Rn. The inequality

f(x) ≥ sup{g(x) | g affine, g(z) ≤ f(z) for all z}

is clear, since if g is any affine underestimator of f , we have g(x) ≤ f(x). To
establish equality, we will show that for each x ∈ Rn, there is an affine function g,
which is a global underestimator of f , and satisfies g(x) = f(x).

The epigraph of f is, of course, a convex set. Hence we can find a supporting
hyperplane to it at (x, f(x)), i.e., a ∈ Rn and b ∈ R with (a, b) 6= 0 and[

a
b

]T [
x− z

f(x)− t
]
≤ 0

for all (z, t) ∈ epi f . This means that

aT (x− z) + b(f(x)− f(z)− s) ≤ 0 (3.8)

for all z ∈ dom f = Rn and all s ≥ 0 (since (z, t) ∈ epi f means t = f(z) + s for
some s ≥ 0). For the inequality (3.8) to hold for all s ≥ 0, we must have b ≥ 0.
If b = 0, then the inequality (3.8) reduces to aT (x − z) ≤ 0 for all z ∈ Rn, which
implies a = 0 and contradicts (a, b) 6= 0. We conclude that b > 0, i.e., that the
supporting hyperplane is not vertical.

Using the fact that b > 0 we rewrite (3.8) for s = 0 as

g(z) = f(x) + (a/b)T (x− z) ≤ f(z)

for all z. The function g is an affine underestimator of f , and satisfies g(x) = f(x).

3.2.4 Composition

In this section we examine conditions on h : Rk → R and g : Rn → Rk that
guarantee convexity or concavity of their composition f = h ◦ g : Rn → R, defined
by

f(x) = h(g(x)), dom f = {x ∈ dom g | g(x) ∈ domh}.



84 3 Convex functions

Scalar composition

We first consider the case k = 1, so h : R → R and g : Rn → R. We can restrict
ourselves to the case n = 1 (since convexity is determined by the behavior of a
function on arbitrary lines that intersect its domain).

To discover the composition rules, we start by assuming that h and g are twice
differentiable, with dom g = domh = R. In this case, convexity of f reduces to
f ′′ ≥ 0 (meaning, f ′′(x) ≥ 0 for all x ∈ R).

The second derivative of the composition function f = h ◦ g is given by
f ′′(x) = h′′(g(x))g′(x)2 + h′(g(x))g′′(x). (3.9)

Now suppose, for example, that g is convex (so g′′ ≥ 0) and h is convex and
nondecreasing (so h′′ ≥ 0 and h′ ≥ 0). It follows from (3.9) that f ′′ ≥ 0, i.e., f is
convex. In a similar way, the expression (3.9) gives the results:

f is convex if h is convex and nondecreasing, and g is convex,

f is convex if h is convex and nonincreasing, and g is concave,

f is concave if h is concave and nondecreasing, and g is concave,

f is concave if h is concave and nonincreasing, and g is convex.

(3.10)

These statements are valid when the functions g and h are twice differentiable and
have domains that are all of R. It turns out that very similar composition rules
hold in the general case n > 1, without assuming differentiability of h and g, or
that dom g = Rn and domh = R:

f is convex if h is convex, h˜ is nondecreasing, and g is convex,

f is convex if h is convex, h˜ is nonincreasing, and g is concave,

f is concave if h is concave, h˜ is nondecreasing, and g is concave,

f is concave if h is concave, h˜ is nonincreasing, and g is convex.

(3.11)

Here h˜ denotes the extended-value extension of the function h, which assigns the
value ∞ (−∞) to points not in domh for h convex (concave). The only difference
between these results, and the results in (3.10), is that we require that the extended-
value extension function h˜ be nonincreasing or nondecreasing, on all of R.

To understand what this means, suppose h is convex, so h˜ takes on the value∞
outside domh. To say that h˜ is nondecreasing means that for any x, y ∈ R, with
x < y, we have h˜(x) ≤ h˜(y). In particular, this means that if y ∈ domh, then x ∈
domh. In other words, the domain of h extends infinitely in the negative direction;
it is either R, or an interval of the form (−∞, a) or (−∞, a]. In a similar way, to
say that h is convex and h˜ is nonincreasing means that h is nonincreasing and
domh extends infinitely in the positive direction. This is illustrated in figure 3.7.

Example 3.12 Some simple examples will illustrate the conditions on h that appear
in the composition theorems.

• The function h(x) = log x, with domh = R++, is concave and satisfies h˜
nondecreasing.



3.2 Operations that preserve convexity 85

x

epi f

0 10

1

x

epi f

0 10

1

Figure 3.7 Left. The function x2, with domain R+, is convex and nonde-
creasing on its domain, but its extended-value extension is not nondecreas-
ing. Right. The function max{x, 0}2, with domain R, is convex, and its
extended-value extension is nondecreasing.

• The function h(x) = x1/2, with domh = R+, is concave and satisfies the
condition h˜ nondecreasing.

• The function h(x) = x3/2, with domh = R+, is convex but does not satisfy the
condition h˜ nondecreasing. For example, we have h˜(−1) =∞, but h˜(1) = 1.

• The function h(x) = x3/2 for x ≥ 0, and h(x) = 0 for x < 0, with domh = R,
is convex and does satisfy the condition h˜ nondecreasing.

The composition results (3.11) can be proved directly, without assuming dif-
ferentiability, or using the formula (3.9). As an example, we will prove the fol-
lowing composition theorem: if g is convex, h is convex, and h˜ is nondecreasing,
then f = h ◦ g is convex. Assume that x, y ∈ dom f , and 0 ≤ θ ≤ 1. Since
x, y ∈ dom f , we have that x, y ∈ dom g and g(x), g(y) ∈ domh. Since dom g
is convex, we conclude that θx + (1 − θ)y ∈ dom g, and from convexity of g, we
have

g(θx+ (1− θ)y) ≤ θg(x) + (1− θ)g(y). (3.12)
Since g(x), g(y) ∈ domh, we conclude that θg(x) + (1 − θ)g(y) ∈ domh, i.e.,
the righthand side of (3.12) is in domh. Now we use the assumption that h˜
is nondecreasing, which means that its domain extends infinitely in the negative
direction. Since the righthand side of (3.12) is in domh, we conclude that the
lefthand side, i.e., g(θx+(1−θ)y) ∈ domh. This means that θx+(1−θ)y ∈ dom f .
At this point, we have shown that dom f is convex.

Now using the fact that h˜ is nondecreasing and the inequality (3.12), we get

h(g(θx+ (1− θ)y)) ≤ h(θg(x) + (1− θ)g(y)). (3.13)

From convexity of h, we have

h(θg(x) + (1− θ)g(y)) ≤ θh(g(x)) + (1− θ)h(g(y)). (3.14)



86 3 Convex functions

Putting (3.13) and (3.14) together, we have

h(g(θx+ (1− θ)y)) ≤ θh(g(x)) + (1− θ)h(g(y)).

which proves the composition theorem.

Example 3.13 Simple composition results.

• If g is convex then exp g(x) is convex.
• If g is concave and positive, then log g(x) is concave.
• If g is concave and positive, then 1/g(x) is convex.
• If g is convex and nonnegative and p ≥ 1, then g(x)p is convex.
• If g is convex then − log(−g(x)) is convex on {x | g(x) < 0}.

Remark 3.3 The requirement that monotonicity hold for the extended-value extension
h˜, and not just the function h, cannot be removed. For example, consider the function
g(x) = x2, with dom g = R, and h(x) = 0, with domh = [1, 2]. Here g is convex,
and h is convex and nondecreasing. But the function f = h ◦ g, given by

f(x) = 0, dom f = [−
√
2,−1] ∪ [1,

√
2],

is not convex, since its domain is not convex. Here, of course, the function h˜ is not
nondecreasing.

Vector composition

We now turn to the more complicated case when k ≥ 1. Suppose

f(x) = h(g(x)) = h(g1(x), . . . , gk(x)),

with h : Rk → R, gi : Rn → R. Again without loss of generality we can assume n =
1. As in the case k = 1, we start by assuming the functions are twice differentiable,
with dom g = R and domh = Rk, in order to discover the composition rules. We
have

f ′′(x) = g′(x)T∇2h(g(x))g′(x) +∇h(g(x))T g′′(x), (3.15)
which is the vector analog of (3.9). Again the issue is to determine conditions under
which f ′′(x) ≥ 0 for all x (or f ′′(x) ≤ 0 for all x for concavity). From (3.15) we
can derive many rules, for example:

f is convex if h is convex, h is nondecreasing in each argument,
and gi are convex,

f is convex if h is convex, h is nonincreasing in each argument,
and gi are concave,

f is concave if h is concave, h is nondecreasing in each argument,
and gi are concave.



3.2 Operations that preserve convexity 87

As in the scalar case, similar composition results hold in general, with n > 1, no as-
sumption of differentiability of h or g, and general domains. For the general results,
the monotonicity condition on h must hold for the extended-value extension h˜.

To understand the meaning of the condition that the extended-value exten-
sion h˜ be monotonic, we consider the case where h : Rk → R is convex, and h˜
nondecreasing, i.e., whenever u � v, we have h˜(u) ≤ h˜(v). This implies that if
v ∈ domh, then so is u: the domain of h must extend infinitely in the −Rk+
directions. We can express this compactly as domh−Rk+ = domh.

Example 3.14 Vector composition examples.

• Let h(z) = z[1]+ · · ·+z[r], the sum of the r largest components of z ∈ Rk. Then
h is convex and nondecreasing in each argument. Suppose g1, . . . , gk are convex
functions on Rn. Then the composition function f = h ◦ g, i.e., the pointwise
sum of the r largest gi’s, is convex.

• The function h(z) = log(∑k
i=1

ezi) is convex and nondecreasing in each argu-

ment, so log(
∑k

i=1
egi) is convex whenever gi are.

• For 0 < p ≤ 1, the function h(z) = (∑k
i=1

zpi )
1/p on Rk+ is concave, and

its extension (which has the value −∞ for z 6� 0) is nondecreasing in each
component. So if gi are concave and nonnegative, we conclude that f(x) =

(
∑k

i=1
gi(x)

p)1/p is concave.

• Suppose p ≥ 1, and g1, . . . , gk are convex and nonnegative. Then the function
(
∑k

i=1
gi(x)

p)1/p is convex.

To show this, we consider the function h : Rk → R defined as

h(z) =

(
k∑
i=1

max{zi, 0}p
)1/p

,

with domh = Rk, so h = h˜. This function is convex, and nondecreasing, so
we conclude h(g(x)) is a convex function of x. For z � 0, we have h(z) =
(
∑k

i=1
zpi )

1/p, so our conclusion is that (
∑k

i=1
gi(x)

p)1/p is convex.

• The geometric mean h(z) = (∏k
i=1

zi)
1/k on Rk+ is concave and its extension

is nondecreasing in each argument. It follows that if g1, . . . , gk are nonnegative
concave functions, then so is their geometric mean, (

∏k
i=1

gi)
1/k.

3.2.5 Minimization

We have seen that the maximum or supremum of an arbitrary family of convex
functions is convex. It turns out that some special forms of minimization also yield
convex functions. If f is convex in (x, y), and C is a convex nonempty set, then
the function

g(x) = inf
y∈C

f(x, y) (3.16)



88 3 Convex functions

is convex in x, provided g(x) > −∞ for all x. The domain of g is the projection of
dom f on its x-coordinates, i.e.,

dom g = {x | (x, y) ∈ dom f for some y ∈ C}.
We prove this by verifying Jensen’s inequality for x1, x2 ∈ dom g. Let ǫ > 0.

Then there are y1, y2 ∈ C such that f(xi, yi) ≤ g(xi) + ǫ for i = 1, 2. Now let
θ ∈ [0, 1]. We have

g(θx1 + (1− θ)x2) = inf
y∈C

f(θx1 + (1− θ)x2, y)
≤ f(θx1 + (1− θ)x2, θy1 + (1− θ)y2)
≤ θf(x1, y1) + (1− θ)f(x2, y2)
≤ θg(x1) + (1− θ)g(x2) + ǫ.

Since this holds for any ǫ > 0, we have

g(θx1 + (1− θ)x2) ≤ θg(x1) + (1− θ)g(x2).
The result can also be seen in terms of epigraphs. With f , g, and C defined as

in (3.16), and assuming the infimum over y ∈ C is attained for each x, we have
epi g = {(x, t) | (x, y, t) ∈ epi f for some y ∈ C}.

Thus epi g is convex, since it is the projection of a convex set on some of its
components.

Example 3.15 Schur complement. Suppose the quadratic function

f(x, y) = xTAx+ 2xTBy + yTCy,

(where A and C are symmetric) is convex in (x, y), which means[
A B
BT C

]
� 0.

We can express g(x) = infy f(x, y) as

g(x) = xT (A−BC†BT )x,
where C† is the pseudo-inverse of C (see §A.5.4). By the minimization rule, g is
convex, so we conclude that A−BC†BT � 0.
If C is invertible, i.e., C ≻ 0, then the matrix A − BC−1BT is called the Schur
complement of C in the matrix [

A B
BT C

]
(see §A.5.5).

Example 3.16 Distance to a set. The distance of a point x to a set S ⊆ Rn, in the
norm ‖ · ‖, is defined as

dist(x, S) = inf
y∈S

‖x− y‖.
The function ‖x−y‖ is convex in (x, y), so if the set S is convex, the distance function
dist(x, S) is a convex function of x.



3.2 Operations that preserve convexity 89

Example 3.17 Suppose h is convex. Then the function g defined as

g(x) = inf{h(y) | Ay = x}

is convex. To see this, we define f by

f(x, y) =

{
h(y) if Ay = x
∞ otherwise,

which is convex in (x, y). Then g is the minimum of f over y, and hence is convex.
(It is not hard to show directly that g is convex.)

3.2.6 Perspective of a function

If f : Rn → R, then the perspective of f is the function g : Rn+1 → R defined by

g(x, t) = tf(x/t),

with domain

dom g = {(x, t) | x/t ∈ dom f, t > 0}.
The perspective operation preserves convexity: If f is a convex function, then so
is its perspective function g. Similarly, if f is concave, then so is g.

This can be proved several ways, for example, direct verification of the defining
inequality (see exercise 3.33). We give a short proof here using epigraphs and the
perspective mapping on Rn+1 described in §2.3.3 (which will also explain the name
‘perspective’). For t > 0 we have

(x, t, s) ∈ epi g ⇐⇒ tf(x/t) ≤ s
⇐⇒ f(x/t) ≤ s/t
⇐⇒ (x/t, s/t) ∈ epi f.

Therefore epi g is the inverse image of epi f under the perspective mapping that
takes (u, v, w) to (u,w)/v. It follows (see §2.3.3) that epi g is convex, so the function
g is convex.

Example 3.18 Euclidean norm squared. The perspective of the convex function
f(x) = xTx on Rn is

g(x, t) = t(x/t)T (x/t) =
xTx

t
,

which is convex in (x, t) for t > 0.

We can deduce convexity of g using several other methods. First, we can express g as
the sum of the quadratic-over-linear functions x2i /t, which were shown to be convex
in §3.1.5. We can also express g as a special case of the matrix fractional function
xT (tI)−1x (see example 3.4).



90 3 Convex functions

Example 3.19 Negative logarithm. Consider the convex function f(x) = − log x on
R++. Its perspective is

g(x, t) = −t log(x/t) = t log(t/x) = t log t− t log x,
and is convex on R2++. The function g is called the relative entropy of t and x. For
x = 1, g reduces to the negative entropy function.

From convexity of g we can establish convexity or concavity of several interesting
related functions. First, the relative entropy of two vectors u, v ∈ Rn++, defined as

n∑
i=1

ui log(ui/vi),

is convex in (u, v), since it is a sum of relative entropies of ui, vi.

A closely related function is the Kullback-Leibler divergence between u, v ∈ Rn++,
given by

Dkl(u, v) =

n∑
i=1

(ui log(ui/vi)− ui + vi) , (3.17)

which is convex, since it is the relative entropy plus a linear function of (u, v). The
Kullback-Leibler divergence satisfies Dkl(u, v) ≥ 0, and Dkl(u, v) = 0 if and only if
u = v, and so can be used as a measure of deviation between two positive vectors; see
exercise 3.13. (Note that the relative entropy and the Kullback-Leibler divergence
are the same when u and v are probability vectors, i.e., satisfy 1Tu = 1T v = 1.)

If we take vi = 1
Tu in the relative entropy function, we obtain the concave (and

homogeneous) function of u ∈ Rn++ given by
n∑
i=1

ui log(1
Tu/ui) = (1

Tu)

n∑
i=1

zi log(1/zi),

where z = u/(1Tu), which is called the normalized entropy function. The vector
z = u/1Tu is a normalized vector or probability distribution, since its components
sum to one; the normalized entropy of u is 1Tu times the entropy of this normalized
distribution.

Example 3.20 Suppose f : Rm → R is convex, and A ∈ Rm×n, b ∈ Rm, c ∈ Rn,
and d ∈ R. We define

g(x) = (cTx+ d)f
(
(Ax+ b)/(cTx+ d)

)
,

with
dom g = {x | cTx+ d > 0, (Ax+ b)/(cTx+ d) ∈ dom f}.

Then g is convex.

3.3 The conjugate function

In this section we introduce an operation that will play an important role in later
chapters.



3.3 The conjugate function 91

f(x)

(0,−f∗(y))

xy

x

Figure 3.8 A function f : R → R, and a value y ∈ R. The conjugate
function f∗(y) is the maximum gap between the linear function yx and
f(x), as shown by the dashed line in the figure. If f is differentiable, this
occurs at a point x where f ′(x) = y.

3.3.1 Definition and examples

Let f : Rn → R. The function f∗ : Rn → R, defined as

f∗(y) = sup
x∈dom f

(
yTx− f(x)) , (3.18)

is called the conjugate of the function f . The domain of the conjugate function
consists of y ∈ Rn for which the supremum is finite, i.e., for which the difference
yTx− f(x) is bounded above on dom f . This definition is illustrated in figure 3.8.

We see immediately that f∗ is a convex function, since it is the pointwise
supremum of a family of convex (indeed, affine) functions of y. This is true whether
or not f is convex. (Note that when f is convex, the subscript x ∈ dom f is not
necessary since, by convention, yTx− f(x) = −∞ for x 6∈ dom f .)

We start with some simple examples, and then describe some rules for conjugat-
ing functions. This allows us to derive an analytical expression for the conjugate
of many common convex functions.

Example 3.21 We derive the conjugates of some convex functions on R.

• Affine function. f(x) = ax + b. As a function of x, yx − ax − b is bounded if
and only if y = a, in which case it is constant. Therefore the domain of the
conjugate function f∗ is the singleton {a}, and f∗(a) = −b.

• Negative logarithm. f(x) = − log x, with dom f = R++. The function xy+log x
is unbounded above if y ≥ 0 and reaches its maximum at x = −1/y otherwise.
Therefore, dom f∗ = {y | y < 0} = −R++ and f∗(y) = − log(−y)−1 for y < 0.

• Exponential. f(x) = ex. xy − ex is unbounded if y < 0. For y > 0, xy − ex
reaches its maximum at x = log y, so we have f∗(y) = y log y − y. For y = 0,



92 3 Convex functions

f∗(y) = supx−ex = 0. In summary, dom f∗ = R+ and f∗(y) = y log y − y
(with the interpretation 0 log 0 = 0).

• Negative entropy. f(x) = x log x, with dom f = R+ (and f(0) = 0). The
function xy − x log x is bounded above on R+ for all y, hence dom f∗ = R. It
attains its maximum at x = ey−1, and substituting we find f∗(y) = ey−1.

• Inverse. f(x) = 1/x on R++. For y > 0, yx − 1/x is unbounded above. For
y = 0 this function has supremum 0; for y < 0 the supremum is attained at
x = (−y)−1/2. Therefore we have f∗(y) = −2(−y)1/2, with dom f∗ = −R+.

Example 3.22 Strictly convex quadratic function. Consider f(x) = 1
2
xTQx, with

Q ∈ Sn++. The function yTx− 12xTQx is bounded above as a function of x for all y.
It attains its maximum at x = Q−1y, so

f∗(y) =
1

2
yTQ−1y.

Example 3.23 Log-determinant. We consider f(X) = log detX−1 on Sn++. The
conjugate function is defined as

f∗(Y ) = sup
X≻0

(tr(Y X) + log detX) ,

since tr(Y X) is the standard inner product on Sn. We first show that tr(Y X) +
log detX is unbounded above unless Y ≺ 0. If Y 6≺ 0, then Y has an eigenvector v,
with ‖v‖2 = 1, and eigenvalue λ ≥ 0. Taking X = I + tvvT we find that

tr(Y X) + log detX = trY + tλ+ log det(I + tvvT ) = trY + tλ+ log(1 + t),

which is unbounded above as t→∞.
Now consider the case Y ≺ 0. We can find the maximizing X by setting the gradient
with respect to X equal to zero:

∇X (tr(Y X) + log detX) = Y +X−1 = 0

(see §A.4.1), which yields X = −Y −1 (which is, indeed, positive definite). Therefore
we have

f∗(Y ) = log det(−Y )−1 − n,
with dom f∗ = −Sn++.

Example 3.24 Indicator function. Let IS be the indicator function of a (not neces-
sarily convex) set S ⊆ Rn, i.e., IS(x) = 0 on dom IS = S. Its conjugate is

I∗S(y) = sup
x∈S

yTx,

which is the support function of the set S.



3.3 The conjugate function 93

Example 3.25 Log-sum-exp function. To derive the conjugate of the log-sum-exp
function f(x) = log(

∑n
i=1

exi), we first determine the values of y for which the

maximum over x of yTx − f(x) is attained. By setting the gradient with respect to
x equal to zero, we obtain the condition

yi =
exi∑n
j=1

exj
, i = 1, . . . , n.

These equations are solvable for x if and only if y ≻ 0 and 1T y = 1. By substituting
the expression for yi into y

Tx−f(x) we obtain f∗(y) =∑n
i=1

yi log yi. This expression

for f∗ is still correct if some components of y are zero, as long as y � 0 and 1T y = 1,
and we interpret 0 log 0 as 0.

In fact the domain of f∗ is exactly given by 1T y = 1, y � 0. To show this, suppose
that a component of y is negative, say, yk < 0. Then we can show that y

Tx− f(x) is
unbounded above by choosing xk = −t, and xi = 0, i 6= k, and letting t go to infinity.
If y � 0 but 1T y 6= 1, we choose x = t1, so that

yTx− f(x) = t1T y − t− log n.
If 1T y > 1, this grows unboundedly as t → ∞; if 1T y < 1, it grows unboundedly as
t→ −∞.
In summary,

f∗(y) =

{ ∑n
i=1

yi log yi if y � 0 and 1T y = 1
∞ otherwise.

In other words, the conjugate of the log-sum-exp function is the negative entropy
function, restricted to the probability simplex.

Example 3.26 Norm. Let ‖ · ‖ be a norm on Rn, with dual norm ‖ · ‖∗. We will
show that the conjugate of f(x) = ‖x‖ is

f∗(y) =

{
0 ‖y‖∗ ≤ 1
∞ otherwise,

i.e., the conjugate of a norm is the indicator function of the dual norm unit ball.

If ‖y‖∗ > 1, then by definition of the dual norm, there is a z ∈ Rn with ‖z‖ ≤ 1 and
yT z > 1. Taking x = tz and letting t→∞, we have

yTx− ‖x‖ = t(yT z − ‖z‖)→∞,
which shows that f∗(y) =∞. Conversely, if ‖y‖∗ ≤ 1, then we have yTx ≤ ‖x‖‖y‖∗
for all x, which implies for all x, yTx − ‖x‖ ≤ 0. Therefore x = 0 is the value that
maximizes yTx− ‖x‖, with maximum value 0.

Example 3.27 Norm squared. Now consider the function f(x) = (1/2)‖x‖2, where ‖·‖
is a norm, with dual norm ‖·‖∗. We will show that its conjugate is f∗(y) = (1/2)‖y‖2∗.
From yTx ≤ ‖y‖∗‖x‖, we conclude

yTx− (1/2)‖x‖2 ≤ ‖y‖∗‖x‖ − (1/2)‖x‖2



94 3 Convex functions

for all x. The righthand side is a quadratic function of ‖x‖, which has maximum
value (1/2)‖y‖2∗. Therefore for all x, we have

yTx− (1/2)‖x‖2 ≤ (1/2)‖y‖2∗,
which shows that f∗(y) ≤ (1/2)‖y‖2∗.
To show the other inequality, let x be any vector with yTx = ‖y‖∗‖x‖, scaled so that
‖x‖ = ‖y‖∗. Then we have, for this x,

yTx− (1/2)‖x‖2 = (1/2)‖y‖2∗,
which shows that f∗(y) ≥ (1/2)‖y‖2∗.

Example 3.28 Revenue and profit functions. We consider a business or enterprise that
consumes n resources and produces a product that can be sold. We let r = (r1, . . . , rn)
denote the vector of resource quantities consumed, and S(r) denote the sales revenue
derived from the product produced (as a function of the resources consumed). Now
let pi denote the price (per unit) of resource i, so the total amount paid for resources
by the enterprise is pT r. The profit derived by the firm is then S(r)− pT r. Let us fix
the prices of the resources, and ask what is the maximum profit that can be made, by
wisely choosing the quantities of resources consumed. This maximum profit is given
by

M(p) = sup
r

(
S(r)− pT r

)
.

The functionM(p) gives the maximum profit attainable, as a function of the resource
prices. In terms of conjugate functions, we can express M as

M(p) = (−S)∗(−p).
Thus the maximum profit (as a function of resource prices) is closely related to the
conjugate of gross sales (as a function of resources consumed).

3.3.2 Basic properties

Fenchel’s inequality

From the definition of conjugate function, we immediately obtain the inequality

f(x) + f∗(y) ≥ xT y
for all x, y. This is called Fenchel’s inequality (or Young’s inequality when f is
differentiable).

For example with f(x) = (1/2)xTQx, where Q ∈ Sn++, we obtain the inequality
xT y ≤ (1/2)xTQx+ (1/2)yTQ−1y.

Conjugate of the conjugate

The examples above, and the name ‘conjugate’, suggest that the conjugate of the
conjugate of a convex function is the original function. This is the case provided a
technical condition holds: if f is convex, and f is closed (i.e., epi f is a closed set;
see §A.3.3), then f∗∗ = f . For example, if dom f = Rn, then we have f∗∗ = f ,
i.e., the conjugate of the conjugate of f is f again (see exercise 3.39).



3.4 Quasiconvex functions 95

Differentiable functions

The conjugate of a differentiable function f is also called the Legendre transform
of f . (To distinguish the general definition from the differentiable case, the term
Fenchel conjugate is sometimes used instead of conjugate.)

Suppose f is convex and differentiable, with dom f = Rn. Any maximizer x∗

of yTx− f(x) satisfies y = ∇f(x∗), and conversely, if x∗ satisfies y = ∇f(x∗), then
x∗ maximizes yTx− f(x). Therefore, if y = ∇f(x∗), we have

f∗(y) = x∗T∇f(x∗)− f(x∗).

This allows us to determine f∗(y) for any y for which we can solve the gradient
equation y = ∇f(z) for z.

We can express this another way. Let z ∈ Rn be arbitrary and define y = ∇f(z).
Then we have

f∗(y) = zT∇f(z)− f(z).

Scaling and composition with affine transformation

For a > 0 and b ∈ R, the conjugate of g(x) = af(x) + b is g∗(y) = af∗(y/a)− b.
Suppose A ∈ Rn×n is nonsingular and b ∈ Rn. Then the conjugate of g(x) =

f(Ax+ b) is
g∗(y) = f∗(A−T y)− bTA−T y,

with dom g∗ = AT dom f∗.

Sums of independent functions

If f(u, v) = f1(u) + f2(v), where f1 and f2 are convex functions with conjugates
f∗1 and f

∗
2 , respectively, then

f∗(w, z) = f∗1 (w) + f
∗
2 (z).

In other words, the conjugate of the sum of independent convex functions is the sum
of the conjugates. (‘Independent’ means they are functions of different variables.)

3.4 Quasiconvex functions

3.4.1 Definition and examples

A function f : Rn → R is called quasiconvex (or unimodal) if its domain and all
its sublevel sets

Sα = {x ∈ dom f | f(x) ≤ α},
for α ∈ R, are convex. A function is quasiconcave if −f is quasiconvex, i.e., every
superlevel set {x | f(x) ≥ α} is convex. A function that is both quasiconvex and
quasiconcave is called quasilinear. If a function f is quasilinear, then its domain,
and every level set {x | f(x) = α} is convex.



96 3 Convex functions

α

β

a b c

Figure 3.9 A quasiconvex function on R. For each α, the α-sublevel set Sα
is convex, i.e., an interval. The sublevel set Sα is the interval [a, b]. The
sublevel set Sβ is the interval (−∞, c].

For a function onR, quasiconvexity requires that each sublevel set be an interval
(including, possibly, an infinite interval). An example of a quasiconvex function on
R is shown in figure 3.9.

Convex functions have convex sublevel sets, and so are quasiconvex. But simple
examples, such as the one shown in figure 3.9, show that the converse is not true.

Example 3.29 Some examples on R:

• Logarithm. log x on R++ is quasiconvex (and quasiconcave, hence quasilinear).
• Ceiling function. ceil(x) = inf{z ∈ Z | z ≥ x} is quasiconvex (and quasicon-
cave).

These examples show that quasiconvex functions can be concave, or discontinuous.
We now give some examples on Rn.

Example 3.30 Length of a vector. We define the length of x ∈ Rn as the largest
index of a nonzero component, i.e.,

f(x) = max{i | xi 6= 0}.
(We define the length of the zero vector to be zero.) This function is quasiconvex on
Rn, since its sublevel sets are subspaces:

f(x) ≤ α ⇐⇒ xi = 0 for i = ⌊α⌋+ 1, . . . , n.

Example 3.31 Consider f : R2 → R, with dom f = R2+ and f(x1, x2) = x1x2. This
function is neither convex nor concave since its Hessian

∇2f(x) =
[
0 1
1 0

]



3.4 Quasiconvex functions 97

is indefinite; it has one positive and one negative eigenvalue. The function f is
quasiconcave, however, since the superlevel sets

{x ∈ R2+ | x1x2 ≥ α}

are convex sets for all α. (Note, however, that f is not quasiconcave on R2.)

Example 3.32 Linear-fractional function. The function

f(x) =
aTx+ b

cTx+ d
,

with dom f = {x | cTx+ d > 0}, is quasiconvex, and quasiconcave, i.e., quasilinear.
Its α-sublevel set is

Sα = {x | cTx+ d > 0, (aTx+ b)/(cTx+ d) ≤ α}
= {x | cTx+ d > 0, aTx+ b ≤ α(cTx+ d)},

which is convex, since it is the intersection of an open halfspace and a closed halfspace.
(The same method can be used to show its superlevel sets are convex.)

Example 3.33 Distance ratio function. Suppose a, b ∈ Rn, and define

f(x) =
‖x− a‖2
‖x− b‖2 ,

i.e., the ratio of the Euclidean distance to a to the distance to b. Then f is quasiconvex
on the halfspace {x | ‖x − a‖2 ≤ ‖x − b‖2}. To see this, we consider the α-sublevel
set of f , with α ≤ 1 since f(x) ≤ 1 on the halfspace {x | ‖x− a‖2 ≤ ‖x− b‖2}. This
sublevel set is the set of points satisfying

‖x− a‖2 ≤ α‖x− b‖2.

Squaring both sides, and rearranging terms, we see that this is equivalent to

(1− α2)xTx− 2(a− α2b)Tx+ aT a− α2bT b ≤ 0.

This describes a convex set (in fact a Euclidean ball) if α ≤ 1.

Example 3.34 Internal rate of return. Let x = (x0, x1, . . . , xn) denote a cash flow
sequence over n periods, where xi > 0 means a payment to us in period i, and xi < 0
means a payment by us in period i. We define the present value of a cash flow, with
interest rate r ≥ 0, to be

PV(x, r) =

n∑
i=0

(1 + r)−ixi.

(The factor (1 + r)−i is a discount factor for a payment by or to us in period i.)

Now we consider cash flows for which x0 < 0 and x0 + x1 + · · · + xn > 0. This
means that we start with an investment of |x0| in period 0, and that the total of the



98 3 Convex functions

remaining cash flow, x1 + · · · + xn, (not taking any discount factors into account)
exceeds our initial investment.

For such a cash flow, PV(x, 0) > 0 and PV(x, r) → x0 < 0 as r → ∞, so it follows
that for at least one r ≥ 0, we have PV(x, r) = 0. We define the internal rate of
return of the cash flow as the smallest interest rate r ≥ 0 for which the present value
is zero:

IRR(x) = inf{r ≥ 0 | PV(x, r) = 0}.
Internal rate of return is a quasiconcave function of x (restricted to x0 < 0, x1+ · · ·+
xn > 0). To see this, we note that

IRR(x) ≥ R ⇐⇒ PV(x, r) > 0 for 0 ≤ r < R.
The lefthand side defines the R-superlevel set of IRR. The righthand side is the
intersection of the sets {x | PV(x, r) > 0}, indexed by r, over the range 0 ≤ r < R.
For each r, PV(x, r) > 0 defines an open halfspace, so the righthand side defines a
convex set.

3.4.2 Basic properties

The examples above show that quasiconvexity is a considerable generalization of
convexity. Still, many of the properties of convex functions hold, or have analogs,
for quasiconvex functions. For example, there is a variation on Jensen’s inequality
that characterizes quasiconvexity: A function f is quasiconvex if and only if dom f
is convex and for any x, y ∈ dom f and 0 ≤ θ ≤ 1,

f(θx+ (1− θ)y) ≤ max{f(x), f(y)}, (3.19)

i.e., the value of the function on a segment does not exceed the maximum of
its values at the endpoints. The inequality (3.19) is sometimes called Jensen’s
inequality for quasiconvex functions, and is illustrated in figure 3.10.

Example 3.35 Cardinality of a nonnegative vector. The cardinality or size of a
vector x ∈ Rn is the number of nonzero components, and denoted card(x). The
function card is quasiconcave on Rn+ (but not R

n). This follows immediately from
the modified Jensen inequality

card(x+ y) ≥ min{card(x), card(y)},
which holds for x, y � 0.

Example 3.36 Rank of positive semidefinite matrix. The function rankX is quasi-
concave on Sn+. This follows from the modified Jensen inequality (3.19),

rank(X + Y ) ≥ min{rankX, rankY }
which holds for X, Y ∈ Sn+. (This can be considered an extension of the previous
example, since rank(diag(x)) = card(x) for x � 0.)



3.4 Quasiconvex functions 99

(x, f(x))

(y, f(y))
max{f(x), f(y)}

Figure 3.10 A quasiconvex function on R. The value of f between x and y
is no more than max{f(x), f(y)}.

Like convexity, quasiconvexity is characterized by the behavior of a function f
on lines: f is quasiconvex if and only if its restriction to any line intersecting its
domain is quasiconvex. In particular, quasiconvexity of a function can be verified by
restricting it to an arbitrary line, and then checking quasiconvexity of the resulting
function on R.

Quasiconvex functions on R

We can give a simple characterization of quasiconvex functions on R. We consider
continuous functions, since stating the conditions in the general case is cumbersome.
A continuous function f : R → R is quasiconvex if and only if at least one of the
following conditions holds:

• f is nondecreasing

• f is nonincreasing

• there is a point c ∈ dom f such that for t ≤ c (and t ∈ dom f), f is
nonincreasing, and for t ≥ c (and t ∈ dom f), f is nondecreasing.

The point c can be chosen as any point which is a global minimizer of f . Figure 3.11
illustrates this.

3.4.3 Differentiable quasiconvex functions

First-order conditions

Suppose f : Rn → R is differentiable. Then f is quasiconvex if and only if dom f
is convex and for all x, y ∈ dom f

f(y) ≤ f(x) =⇒ ∇f(x)T (y − x) ≤ 0. (3.20)



100 3 Convex functions

c
t

Figure 3.11 A quasiconvex function on R. The function is nonincreasing for
t ≤ c and nondecreasing for t ≥ c.

x
∇f(x)

Figure 3.12 Three level curves of a quasiconvex function f are shown. The
vector ∇f(x) defines a supporting hyperplane to the sublevel set {z | f(z) ≤
f(x)} at x.

This is the analog of inequality (3.2), for quasiconvex functions. We leave the proof
as an exercise (exercise 3.43).

The condition (3.20) has a simple geometric interpretation when ∇f(x) 6= 0. It
states that ∇f(x) defines a supporting hyperplane to the sublevel set {y | f(y) ≤
f(x)}, at the point x, as illustrated in figure 3.12.

While the first-order condition for convexity (3.2), and the first-order condition
for quasiconvexity (3.20) are similar, there are some important differences. For
example, if f is convex and ∇f(x) = 0, then x is a global minimizer of f . But this
statement is false for quasiconvex functions: it is possible that ∇f(x) = 0, but x
is not a global minimizer of f .



3.4 Quasiconvex functions 101

Second-order conditions

Now suppose f is twice differentiable. If f is quasiconvex, then for all x ∈ dom f ,
and all y ∈ Rn, we have

yT∇f(x) = 0 =⇒ yT∇2f(x)y ≥ 0. (3.21)
For a quasiconvex function on R, this reduces to the simple condition

f ′(x) = 0 =⇒ f ′′(x) ≥ 0,
i.e., at any point with zero slope, the second derivative is nonnegative. For a
quasiconvex function on Rn, the interpretation of the condition (3.21) is a bit
more complicated. As in the case n = 1, we conclude that whenever ∇f(x) = 0,
we must have ∇2f(x) � 0. When ∇f(x) 6= 0, the condition (3.21) means that
∇2f(x) is positive semidefinite on the (n− 1)-dimensional subspace ∇f(x)⊥. This
implies that ∇2f(x) can have at most one negative eigenvalue.

As a (partial) converse, if f satisfies

yT∇f(x) = 0 =⇒ yT∇2f(x)y > 0 (3.22)
for all x ∈ dom f and all y ∈ Rn, y 6= 0, then f is quasiconvex. This condition is
the same as requiring ∇2f(x) to be positive definite for any point with ∇f(x) = 0,
and for all other points, requiring ∇2f(x) to be positive definite on the (n − 1)-
dimensional subspace ∇f(x)⊥.

Proof of second-order conditions for quasiconvexity

By restricting the function to an arbitrary line, it suffices to consider the case in
which f : R→ R.

We first show that if f : R → R is quasiconvex on an interval (a, b), then it
must satisfy (3.21), i.e., if f ′(c) = 0 with c ∈ (a, b), then we must have f ′′(c) ≥ 0. If
f ′(c) = 0 with c ∈ (a, b), f ′′(c) < 0, then for small positive ǫ we have f(c−ǫ) < f(c)
and f(c + ǫ) < f(c). It follows that the sublevel set {x | f(x) ≤ f(c) − ǫ} is
disconnected for small positive ǫ, and therefore not convex, which contradicts our
assumption that f is quasiconvex.

Now we show that if the condition (3.22) holds, then f is quasiconvex. Assume
that (3.22) holds, i.e., for each c ∈ (a, b) with f ′(c) = 0, we have f ′′(c) > 0. This
means that whenever the function f ′ crosses the value 0, it is strictly increasing.
Therefore it can cross the value 0 at most once. If f ′ does not cross the value
0 at all, then f is either nonincreasing or nondecreasing on (a, b), and therefore
quasiconvex. Otherwise it must cross the value 0 exactly once, say at c ∈ (a, b).
Since f ′′(c) > 0, it follows that f ′(t) ≤ 0 for a < t ≤ c, and f ′(t) ≥ 0 for c ≤ t < b.
This shows that f is quasiconvex.

3.4.4 Operations that preserve quasiconvexity

Nonnegative weighted maximum

A nonnegative weighted maximum of quasiconvex functions, i.e.,

f = max{w1f1, . . . , wmfm},



102 3 Convex functions

with wi ≥ 0 and fi quasiconvex, is quasiconvex. The property extends to the
general pointwise supremum

f(x) = sup
y∈C

(w(y)g(x, y))

where w(y) ≥ 0 and g(x, y) is quasiconvex in x for each y. This fact can be easily
verified: f(x) ≤ α if and only if

w(y)g(x, y) ≤ α for all y ∈ C,

i.e., the α-sublevel set of f is the intersection of the α-sublevel sets of the functions
w(y)g(x, y) in the variable x.

Example 3.37 Generalized eigenvalue. The maximum generalized eigenvalue of a
pair of symmetric matrices (X,Y ), with Y ≻ 0, is defined as

λmax(X,Y ) = sup
u 6=0

uTXu

uTY u
= sup{λ | det(λY −X) = 0}.

(See §A.5.3). This function is quasiconvex on dom f = Sn × Sn++.
To see this we consider the expression

λmax(X,Y ) = sup
u 6=0

uTXu

uTY u
.

For each u 6= 0, the function uTXu/uTY u is linear-fractional in (X,Y ), hence a
quasiconvex function of (X,Y ). We conclude that λmax is quasiconvex, since it is the
supremum of a family of quasiconvex functions.

Composition

If g : Rn → R is quasiconvex and h : R → R is nondecreasing, then f = h ◦ g is
quasiconvex.

The composition of a quasiconvex function with an affine or linear-fractional
transformation yields a quasiconvex function. If f is quasiconvex, then g(x) =
f(Ax+ b) is quasiconvex, and g˜(x) = f((Ax+ b)/(cTx+ d)) is quasiconvex on the
set

{x | cTx+ d > 0, (Ax+ b)/(cTx+ d) ∈ dom f}.

Minimization

If f(x, y) is quasiconvex jointly in x and y and C is a convex set, then the function

g(x) = inf
y∈C

f(x, y)

is quasiconvex.
To show this, we need to show that {x | g(x) ≤ α} is convex, where α ∈ R is

arbitrary. From the definition of g, g(x) ≤ α if and only if for any ǫ > 0 there exists



3.4 Quasiconvex functions 103

a y ∈ C with f(x, y) ≤ α + ǫ. Now let x1 and x2 be two points in the α-sublevel
set of g. Then for any ǫ > 0, there exists y1, y2 ∈ C with

f(x1, y1) ≤ α+ ǫ, f(x2, y2) ≤ α+ ǫ,

and since f is quasiconvex in x and y, we also have

f(θx1 + (1− θ)x2, θy1 + (1− θ)y2) ≤ α+ ǫ,

for 0 ≤ θ ≤ 1. Hence g(θx1 + (1− θ)x2) ≤ α, which proves that {x | g(x) ≤ α} is
convex.

3.4.5 Representation via family of convex functions

In the sequel, it will be convenient to represent the sublevel sets of a quasiconvex
function f (which are convex) via inequalities of convex functions. We seek a family
of convex functions φt : R

n → R, indexed by t ∈ R, with

f(x) ≤ t ⇐⇒ φt(x) ≤ 0, (3.23)

i.e., the t-sublevel set of the quasiconvex function f is the 0-sublevel set of the
convex function φt. Evidently φt must satisfy the property that for all x ∈ Rn,
φt(x) ≤ 0 =⇒ φs(x) ≤ 0 for s ≥ t. This is satisfied if for each x, φt(x) is a
nonincreasing function of t, i.e., φs(x) ≤ φt(x) whenever s ≥ t.

To see that such a representation always exists, we can take

φt(x) =

{
0 f(x) ≤ t
∞ otherwise,

i.e., φt is the indicator function of the t-sublevel of f . Obviously this representation
is not unique; for example if the sublevel sets of f are closed, we can take

φt(x) = dist (x, {z | f(z) ≤ t}) .

We are usually interested in a family φt with nice properties, such as differentia-
bility.

Example 3.38 Convex over concave function. Suppose p is a convex function, q is a
concave function, with p(x) ≥ 0 and q(x) > 0 on a convex set C. Then the function
f defined by f(x) = p(x)/q(x), on C, is quasiconvex.

Here we have

f(x) ≤ t ⇐⇒ p(x)− tq(x) ≤ 0,
so we can take φt(x) = p(x) − tq(x) for t ≥ 0. For each t, φt is convex and for each
x, φt(x) is decreasing in t.



104 3 Convex functions

3.5 Log-concave and log-convex functions

3.5.1 Definition

A function f : Rn → R is logarithmically concave or log-concave if f(x) > 0
for all x ∈ dom f and log f is concave. It is said to be logarithmically convex
or log-convex if log f is convex. Thus f is log-convex if and only if 1/f is log-
concave. It is convenient to allow f to take on the value zero, in which case we
take log f(x) = −∞. In this case we say f is log-concave if the extended-value
function log f is concave.

We can express log-concavity directly, without logarithms: a function f : Rn →
R, with convex domain and f(x) > 0 for all x ∈ dom f , is log-concave if and only
if for all x, y ∈ dom f and 0 ≤ θ ≤ 1, we have

f(θx+ (1− θ)y) ≥ f(x)θf(y)1−θ.
In particular, the value of a log-concave function at the average of two points is at
least the geometric mean of the values at the two points.

From the composition rules we know that eh is convex if h is convex, so a log-
convex function is convex. Similarly, a nonnegative concave function is log-concave.
It is also clear that a log-convex function is quasiconvex and a log-concave function
is quasiconcave, since the logarithm is monotone increasing.

Example 3.39 Some simple examples of log-concave and log-convex functions.

• Affine function. f(x) = aTx+ b is log-concave on {x | aTx+ b > 0}.
• Powers. f(x) = xa, on R++, is log-convex for a ≤ 0, and log-concave for a ≥ 0.
• Exponentials. f(x) = eax is log-convex and log-concave.
• The cumulative distribution function of a Gaussian density,

Φ(x) =
1√
2π

∫ x
−∞

e−u
2/2 du,

is log-concave (see exercise 3.54).

• Gamma function. The Gamma function,

Γ(x) =

∫ ∞
0

ux−1e−u du,

is log-convex for x ≥ 1 (see exercise 3.52).
• Determinant. detX is log concave on Sn++.
• Determinant over trace. detX/ trX is log concave on Sn++ (see exercise 3.49).

Example 3.40 Log-concave density functions. Many common probability density
functions are log-concave. Two examples are the multivariate normal distribution,

f(x) =
1√

(2π)n detΣ
e−

1
2
(x−x¯)TΣ−1(x−x¯)



3.5 Log-concave and log-convex functions 105

(where x¯ ∈ Rn and Σ ∈ Sn++), and the exponential distribution on Rn+,

f(x) =

(
n∏
i=1

λi

)
e−λ

T x

(where λ ≻ 0). Another example is the uniform distribution over a convex set C,

f(x) =

{
1/α x ∈ C
0 x 6∈ C

where α = vol(C) is the volume (Lebesgue measure) of C. In this case log f takes
on the value −∞ outside C, and − logα on C, hence is concave.
As a more exotic example consider the Wishart distribution, defined as follows. Let
x1, . . . , xp ∈ Rn be independent Gaussian random vectors with zero mean and co-
variance Σ ∈ Sn, with p > n. The random matrix X =∑p

i=1
xix

T
i has the Wishart

density

f(X) = a (detX)(p−n−1)/2 e−
1
2
tr(Σ−1X),

with dom f = Sn++, and a is a positive constant. The Wishart density is log-concave,
since

log f(X) = log a+
p− n− 1

2
log detX − 1

2
tr(Σ−1X),

which is a concave function of X.

3.5.2 Properties

Twice differentiable log-convex/concave functions

Suppose f is twice differentiable, with dom f convex, so

∇2 log f(x) = 1
f(x)

∇2f(x)− 1
f(x)2

∇f(x)∇f(x)T .

We conclude that f is log-convex if and only if for all x ∈ dom f ,
f(x)∇2f(x) � ∇f(x)∇f(x)T ,

and log-concave if and only if for all x ∈ dom f ,
f(x)∇2f(x) � ∇f(x)∇f(x)T .

Multiplication, addition, and integration

Log-convexity and log-concavity are closed under multiplication and positive scal-
ing. For example, if f and g are log-concave, then so is the pointwise product
h(x) = f(x)g(x), since log h(x) = log f(x) + log g(x), and log f(x) and log g(x) are
concave functions of x.

Simple examples show that the sum of log-concave functions is not, in general,
log-concave. Log-convexity, however, is preserved under sums. Let f and g be log-
convex functions, i.e., F = log f and G = log g are convex. From the composition
rules for convex functions, it follows that

log (expF + expG) = log(f + g)



106 3 Convex functions

is convex. Therefore the sum of two log-convex functions is log-convex.
More generally, if f(x, y) is log-convex in x for each y ∈ C then

g(x) =

∫
C

f(x, y) dy

is log-convex.

Example 3.41 Laplace transform of a nonnegative function and the moment and
cumulant generating functions. Suppose p : Rn → R satisfies p(x) ≥ 0 for all x. The
Laplace transform of p,

P (z) =

∫
p(x)e−z

T x dx,

is log-convex on Rn. (Here domP is, naturally, {z | P (z) <∞}.)
Now suppose p is a density, i.e., satisfies

∫
p(x) dx = 1. The function M(z) = P (−z)

is called the moment generating function of the density. It gets its name from the fact
that the moments of the density can be found from the derivatives of the moment
generating function, evaluated at z = 0, e.g.,

∇M(0) = E v, ∇2M(0) = E vvT ,

where v is a random variable with density p.

The function logM(z), which is convex, is called the cumulant generating function
for p, since its derivatives give the cumulants of the density. For example, the first
and second derivatives of the cumulant generating function, evaluated at zero, are
the mean and covariance of the associated random variable:

∇ logM(0) = E v, ∇2 logM(0) = E(v −E v)(v −E v)T .

Integration of log-concave functions

In some special cases log-concavity is preserved by integration. If f : Rn×Rm → R
is log-concave, then

g(x) =

∫
f(x, y) dy

is a log-concave function of x (on Rn). (The integration here is over Rm.) A proof
of this result is not simple; see the references.

This result has many important consequences, some of which we describe in
the rest of this section. It implies, for example, that marginal distributions of log-
concave probability densities are log-concave. It also implies that log-concavity is
closed under convolution, i.e., if f and g are log-concave on Rn, then so is the
convolution

(f ∗ g)(x) =
∫
f(x− y)g(y) dy.

(To see this, note that g(y) and f(x−y) are log-concave in (x, y), hence the product
f(x− y)g(y) is; then the integration result applies.)



3.5 Log-concave and log-convex functions 107

Suppose C ⊆ Rn is a convex set and w is a random vector in Rn with log-
concave probability density p. Then the function

f(x) = prob(x+ w ∈ C)

is log-concave in x. To see this, express f as

f(x) =

∫
g(x+ w)p(w) dw,

where g is defined as

g(u) =

{
1 u ∈ C
0 u 6∈ C,

(which is log-concave) and apply the integration result.

Example 3.42 The cumulative distribution function of a probability density function
f : Rn → R is defined as

F (x) = prob(w � x) =
∫ xn
−∞

· · ·
∫ x1
−∞

f(z) dz1 · · · dzn,

where w is a random variable with density f . If f is log-concave, then F is log-
concave. We have already encountered a special case: the cumulative distribution
function of a Gaussian random variable,

f(x) =
1√
2π

∫ x
−∞

e−t
2/2 dt,

is log-concave. (See example 3.39 and exercise 3.54.)

Example 3.43 Yield function. Let x ∈ Rn denote the nominal or target value of a
set of parameters of a product that is manufactured. Variation in the manufacturing
process causes the parameters of the product, when manufactured, to have the value
x + w, where w ∈ Rn is a random vector that represents manufacturing variation,
and is usually assumed to have zero mean. The yield of the manufacturing process,
as a function of the nominal parameter values, is given by

Y (x) = prob(x+ w ∈ S),

where S ⊆ Rn denotes the set of acceptable parameter values for the product, i.e.,
the product specifications.

If the density of the manufacturing error w is log-concave (for example, Gaussian) and
the set S of product specifications is convex, then the yield function Y is log-concave.
This implies that the α-yield region, defined as the set of nominal parameters for
which the yield exceeds α, is convex. For example, the 95% yield region

{x | Y (x) ≥ 0.95} = {x | log Y (x) ≥ log 0.95}

is convex, since it is a superlevel set of the concave function log Y .



108 3 Convex functions

Example 3.44 Volume of polyhedron. Let A ∈ Rm×n. Define
Pu = {x ∈ Rn | Ax � u}.

Then its volume volPu is a log-concave function of u.

To prove this, note that the function

Ψ(x, u) =

{
1 Ax � u
0 otherwise,

is log-concave. By the integration result, we conclude that∫
Ψ(x, u) dx = volPu

is log-concave.

3.6 Convexity with respect to generalized inequalities

We now consider generalizations of the notions of monotonicity and convexity, using
generalized inequalities instead of the usual ordering on R.

3.6.1 Monotonicity with respect to a generalized inequality

Suppose K ⊆ Rn is a proper cone with associated generalized inequality �K . A
function f : Rn → R is called K-nondecreasing if

x �K y =⇒ f(x) ≤ f(y),
and K-increasing if

x �K y, x 6= y =⇒ f(x) < f(y).
We define K-nonincreasing and K-decreasing functions in a similar way.

Example 3.45 Monotone vector functions. A function f : Rn → R is nondecreasing
with respect to Rn+ if and only if

x1 ≤ y1, . . . , xn ≤ yn =⇒ f(x) ≤ f(y)
for all x, y. This is the same as saying that f , when restricted to any component xi
(i.e., xi is considered the variable while xj for j 6= i are fixed), is nondecreasing.

Example 3.46 Matrix monotone functions. A function f : Sn → R is called ma-
trix monotone (increasing, decreasing) if it is monotone with respect to the posi-
tive semidefinite cone. Some examples of matrix monotone functions of the variable
X ∈ Sn:



3.6 Convexity with respect to generalized inequalities 109

• tr(WX), where W ∈ Sn, is matrix nondecreasing if W � 0, and matrix in-
creasing if W ≻ 0 (it is matrix nonincreasing if W � 0, and matrix decreasing
if W ≺ 0).

• tr(X−1) is matrix decreasing on Sn++.
• detX is matrix increasing on Sn++, and matrix nondecreasing on Sn+.

Gradient conditions for monotonicity

Recall that a differentiable function f : R→ R, with convex (i.e., interval) domain,
is nondecreasing if and only if f ′(x) ≥ 0 for all x ∈ dom f , and increasing if
f ′(x) > 0 for all x ∈ dom f (but the converse is not true). These conditions
are readily extended to the case of monotonicity with respect to a generalized
inequality. A differentiable function f , with convex domain, is K-nondecreasing if
and only if

∇f(x) �K∗ 0 (3.24)
for all x ∈ dom f . Note the difference with the simple scalar case: the gradi-
ent must be nonnegative in the dual inequality. For the strict case, we have the
following: If

∇f(x) ≻K∗ 0 (3.25)
for all x ∈ dom f , then f is K-increasing. As in the scalar case, the converse is
not true.

Let us prove these first-order conditions for monotonicity. First, assume that
f satisfies (3.24) for all x, but is not K-nondecreasing, i.e., there exist x, y with
x �K y and f(y) < f(x). By differentiability of f there exists a t ∈ [0, 1] with

d

dt
f(x+ t(y − x)) = ∇f(x+ t(y − x))T (y − x) < 0.

Since y − x ∈ K this means
∇f(x+ t(y − x)) 6∈ K∗,

which contradicts our assumption that (3.24) is satisfied everywhere. In a similar
way it can be shown that (3.25) implies f is K-increasing.

It is also straightforward to see that it is necessary that (3.24) hold everywhere.
Assume (3.24) does not hold for x = z. By the definition of dual cone this means
there exists a v ∈ K with

∇f(z)T v < 0.
Now consider h(t) = f(z + tv) as a function of t. We have h′(0) = ∇f(z)T v < 0,
and therefore there exists t > 0 with h(t) = f(z + tv) < h(0) = f(z), which means
f is not K-nondecreasing.

3.6.2 Convexity with respect to a generalized inequality

Suppose K ⊆ Rm is a proper cone with associated generalized inequality �K . We
say f : Rn → Rm is K-convex if for all x, y, and 0 ≤ θ ≤ 1,

f(θx+ (1− θ)y) �K θf(x) + (1− θ)f(y).



110 3 Convex functions

The function is strictly K-convex if

f(θx+ (1− θ)y) ≺K θf(x) + (1− θ)f(y)

for all x 6= y and 0 < θ < 1. These definitions reduce to ordinary convexity and
strict convexity when m = 1 (and K = R+).

Example 3.47 Convexity with respect to componentwise inequality. A function f :
Rn → Rm is convex with respect to componentwise inequality (i.e., the generalized
inequality induced by Rm+ ) if and only if for all x, y and 0 ≤ θ ≤ 1,

f(θx+ (1− θ)y) � θf(x) + (1− θ)f(y),

i.e., each component fi is a convex function. The function f is strictly convex with
respect to componentwise inequality if and only if each component fi is strictly con-
vex.

Example 3.48 Matrix convexity. Suppose f is a symmetric matrix valued function,
i.e., f : Rn → Sm. The function f is convex with respect to matrix inequality if

f(θx+ (1− θ)y) � θf(x) + (1− θ)f(y)

for any x and y, and for θ ∈ [0, 1]. This is sometimes called matrix convexity. An
equivalent definition is that the scalar function zT f(x)z is convex for all vectors z.
(This is often a good way to prove matrix convexity). A matrix function is strictly
matrix convex if

f(θx+ (1− θ)y) ≺ θf(x) + (1− θ)f(y)
when x 6= y and 0 < θ < 1, or, equivalently, if zT fz is strictly convex for every z 6= 0.
Some examples:

• The function f(X) = XXT where X ∈ Rn×m is matrix convex, since for
fixed z the function zTXXT z = ‖XT z‖22 is a convex quadratic function of (the
components of) X. For the same reason, f(X) = X2 is matrix convex on Sn.

• The function Xp is matrix convex on Sn++ for 1 ≤ p ≤ 2 or −1 ≤ p ≤ 0, and
matrix concave for 0 ≤ p ≤ 1.

• The function f(X) = eX is not matrix convex on Sn, for n ≥ 2.

Many of the results for convex functions have extensions to K-convex functions.
As a simple example, a function is K-convex if and only if its restriction to any
line in its domain is K-convex. In the rest of this section we list a few results for
K-convexity that we will use later; more results are explored in the exercises.

Dual characterization of K-convexity

A function f isK-convex if and only if for every w �K∗ 0, the (real-valued) function
wT f is convex (in the ordinary sense); f is strictly K-convex if and only if for every
nonzero w �K∗ 0 the function wT f is strictly convex. (These follow directly from
the definitions and properties of dual inequality.)



3.6 Convexity with respect to generalized inequalities 111

Differentiable K-convex functions

A differentiable function f is K-convex if and only if its domain is convex, and for
all x, y ∈ dom f ,

f(y) �K f(x) +Df(x)(y − x).
(Here Df(x) ∈ Rm×n is the derivative or Jacobian matrix of f at x; see §A.4.1.)
The function f is strictly K-convex if and only if for all x, y ∈ dom f with x 6= y,

f(y) ≻K f(x) +Df(x)(y − x).

Composition theorem

Many of the results on composition can be generalized toK-convexity. For example,
if g : Rn → Rp is K-convex, h : Rp → R is convex, and h˜ (the extended-value
extension of h) is K-nondecreasing, then h ◦ g is convex. This generalizes the fact
that a nondecreasing convex function of a convex function is convex. The condition
that h˜ be K-nondecreasing implies that domh−K = domh.

Example 3.49 The quadratic matrix function g : Rm×n → Sn defined by
g(X) = XTAX +BTX +XTB + C,

where A ∈ Sm, B ∈ Rm×n, and C ∈ Sn, is convex when A � 0.
The function h : Sn → R defined by h(Y ) = − log det(−Y ) is convex and increasing
on domh = −Sn++.
By the composition theorem, we conclude that

f(X) = − log det(−(XTAX +BTX +XTB + C))
is convex on

dom f = {X ∈ Rm×n | XTAX +BTX +XTB + C ≺ 0}.
This generalizes the fact that

− log(−(ax2 + bx+ c))
is convex on

{x ∈ R | ax2 + bx+ c < 0},
provided a ≥ 0.



112 3 Convex functions

Bibliography

The standard reference on convex analysis is Rockafellar [Roc70]. Other books on convex
functions are Stoer and Witzgall [SW70], Roberts and Varberg [RV73], Van Tiel [vT84],
Hiriart-Urruty and Lemare´chal [HUL93], Ekeland and Te´mam [ET99], Borwein and Lewis
[BL00], Florenzano and Le Van [FL01], Barvinok [Bar02], and Bertsekas, Nedic´, and
Ozdaglar [Ber03]. Most nonlinear programming texts also include chapters on convex
functions (see, for example, Mangasarian [Man94], Bazaraa, Sherali, and Shetty [BSS93],
Bertsekas [Ber99], Polyak [Pol87], and Peressini, Sullivan, and Uhl [PSU88]).

Jensen’s inequality appears in [Jen06]. A general study of inequalities, in which Jensen’s
inequality plays a central role, is presented by Hardy, Littlewood, and Po´lya [HLP52],
and Beckenbach and Bellman [BB65].

The term perspective function is from Hiriart-Urruty and Lemare´chal [HUL93, volume
1, page 100]. For the definitions in example 3.19 (relative entropy and Kullback-Leibler
divergence), and the related exercise 3.13, see Cover and Thomas [CT91].

Some important early references on quasiconvex functions (as well as other extensions of
convexity) are Nikaidoˆ [Nik54], Mangasarian [Man94, chapter 9], Arrow and Enthoven
[AE61], Ponstein [Pon67], and Luenberger [Lue68]. For a more comprehensive reference
list, we refer to Bazaraa, Sherali, and Shetty [BSS93, page 126].

Pre´kopa [Pre´80] gives a survey of log-concave functions. Log-convexity of the Laplace
transform is mentioned in Barndorff-Nielsen [BN78, §7]. For a proof of the integration
result of log-concave functions, see Pre´kopa [Pre´71, Pre´73].

Generalized inequalities are used extensively in the recent literature on cone programming,
starting with Nesterov and Nemirovski [NN94, page 156]; see also Ben-Tal and Nemirovski
[BTN01] and the references at the end of chapter 4. Convexity with respect to generalized
inequalities also appears in the work of Luenberger [Lue69, §8.2] and Isii [Isi64]. Matrix
monotonicity and matrix convexity are attributed to Lo¨wner [Lo¨w34], and are discussed
in detail by Davis [Dav63], Roberts and Varberg [RV73, page 216] and Marshall and
Olkin [MO79, §16E]. For the result on convexity and concavity of the function Xp in
example 3.48, see Bondar [Bon94, theorem 16.1]. For a simple example that demonstrates
that eX is not matrix convex, see Marshall and Olkin [MO79, page 474].



Exercises 113

Exercises

Definition of convexity

3.1 Suppose f : R→ R is convex, and a, b ∈ dom f with a < b.
(a) Show that

f(x) ≤ b− x
b− af(a) +

x− a
b− a f(b)

for all x ∈ [a, b].
(b) Show that

f(x)− f(a)
x− a ≤

f(b)− f(a)
b− a ≤

f(b)− f(x)
b− x

for all x ∈ (a, b). Draw a sketch that illustrates this inequality.
(c) Suppose f is differentiable. Use the result in (b) to show that

f ′(a) ≤ f(b)− f(a)
b− a ≤ f

′(b).

Note that these inequalities also follow from (3.2):

f(b) ≥ f(a) + f ′(a)(b− a), f(a) ≥ f(b) + f ′(b)(a− b).

(d) Suppose f is twice differentiable. Use the result in (c) to show that f ′′(a) ≥ 0 and
f ′′(b) ≥ 0.

3.2 Level sets of convex, concave, quasiconvex, and quasiconcave functions. Some level sets
of a function f are shown below. The curve labeled 1 shows {x | f(x) = 1}, etc.

1

2

3

Could f be convex (concave, quasiconvex, quasiconcave)? Explain your answer. Repeat
for the level curves shown below.

1 2 3 4 5 6



114 3 Convex functions

3.3 Inverse of an increasing convex function. Suppose f : R → R is increasing and convex
on its domain (a, b). Let g denote its inverse, i.e., the function with domain (f(a), f(b))
and g(f(x)) = x for a < x < b. What can you say about convexity or concavity of g?

3.4 [RV73, page 15] Show that a continuous function f : Rn → R is convex if and only if for
every line segment, its average value on the segment is less than or equal to the average
of its values at the endpoints of the segment: For every x, y ∈ Rn,∫ 1

0

f(x+ λ(y − x)) dλ ≤ f(x) + f(y)
2

.

3.5 [RV73, page 22] Running average of a convex function. Suppose f : R → R is convex,
with R+ ⊆ dom f . Show that its running average F , defined as

F (x) =
1

x

∫ x
0

f(t) dt, domF = R++,

is convex. Hint. For each s, f(sx) is convex in x, so
∫ 1
0
f(sx) ds is convex.

3.6 Functions and epigraphs. When is the epigraph of a function a halfspace? When is the
epigraph of a function a convex cone? When is the epigraph of a function a polyhedron?

3.7 Suppose f : Rn → R is convex with dom f = Rn, and bounded above on Rn. Show that
f is constant.

3.8 Second-order condition for convexity. Prove that a twice differentiable function f is convex
if and only if its domain is convex and ∇2f(x) � 0 for all x ∈ dom f . Hint. First consider
the case f : R→ R. You can use the first-order condition for convexity (which was proved
on page 70).

3.9 Second-order conditions for convexity on an affine set. Let F ∈ Rn×m, xˆ ∈ Rn. The
restriction of f : Rn → R to the affine set {Fz + xˆ | z ∈ Rm} is defined as the function
f˜ : Rm → R with

f˜(z) = f(Fz + xˆ), dom f˜ = {z | Fz + xˆ ∈ dom f}.
Suppose f is twice differentiable with a convex domain.

(a) Show that f˜ is convex if and only if for all z ∈ dom f˜

FT∇2f(Fz + xˆ)F � 0.

(b) Suppose A ∈ Rp×n is a matrix whose nullspace is equal to the range of F , i.e.,
AF = 0 and rankA = n − rankF . Show that f˜ is convex if and only if for all
z ∈ dom f˜ there exists a λ ∈ R such that

∇2f(Fz + xˆ) + λATA � 0.
Hint. Use the following result: If B ∈ Sn and A ∈ Rp×n, then xTBx ≥ 0 for all
x ∈ N (A) if and only if there exists a λ such that B + λATA � 0.

3.10 An extension of Jensen’s inequality. One interpretation of Jensen’s inequality is that
randomization or dithering hurts, i.e., raises the average value of a convex function: For
f convex and v a zero mean random variable, we have E f(x0 + v) ≥ f(x0). This leads
to the following conjecture. If f is convex, then the larger the variance of v, the larger
E f(x0 + v).

(a) Give a counterexample that shows that this conjecture is false. Find zero mean
random variables v and w, with var(v) > var(w), a convex function f , and a point
x0, such that E f(x0 + v) < E f(x0 + w).



Exercises 115

(b) The conjecture is true when v and w are scaled versions of each other. Show that
E f(x0 + tv) is monotone increasing in t ≥ 0, when f is convex and v is zero mean.

3.11 Monotone mappings. A function ψ : Rn → Rn is called monotone if for all x, y ∈ domψ,

(ψ(x)− ψ(y))T (x− y) ≥ 0.
(Note that ‘monotone’ as defined here is not the same as the definition given in §3.6.1.
Both definitions are widely used.) Suppose f : Rn → R is a differentiable convex function.
Show that its gradient ∇f is monotone. Is the converse true, i.e., is every monotone
mapping the gradient of a convex function?

3.12 Suppose f : Rn → R is convex, g : Rn → R is concave, dom f = dom g = Rn, and
for all x, g(x) ≤ f(x). Show that there exists an affine function h such that for all x,
g(x) ≤ h(x) ≤ f(x). In other words, if a concave function g is an underestimator of a
convex function f , then we can fit an affine function between f and g.

3.13 Kullback-Leibler divergence and the information inequality. Let Dkl be the Kullback-
Leibler divergence, as defined in (3.17). Prove the information inequality : Dkl(u, v) ≥ 0
for all u, v ∈ Rn++. Also show that Dkl(u, v) = 0 if and only if u = v.
Hint. The Kullback-Leibler divergence can be expressed as

Dkl(u, v) = f(u)− f(v)−∇f(v)T (u− v),
where f(v) =

∑n
i=1

vi log vi is the negative entropy of v.

3.14 Convex-concave functions and saddle-points. We say the function f : Rn × Rm → R
is convex-concave if f(x, z) is a concave function of z, for each fixed x, and a convex
function of x, for each fixed z. We also require its domain to have the product form
dom f = A×B, where A ⊆ Rn and B ⊆ Rm are convex.
(a) Give a second-order condition for a twice differentiable function f : Rn ×Rm → R

to be convex-concave, in terms of its Hessian ∇2f(x, z).
(b) Suppose that f : Rn×Rm → R is convex-concave and differentiable, with∇f(x˜, z˜) =

0. Show that the saddle-point property holds: for all x, z, we have

f(x˜, z) ≤ f(x˜, z˜) ≤ f(x, z˜).
Show that this implies that f satisfies the strong max-min property :

sup
z

inf
x

f(x, z) = inf
x

sup
z

f(x, z)

(and their common value is f(x˜, z˜)).

(c) Now suppose that f : Rn ×Rm → R is differentiable, but not necessarily convex-
concave, and the saddle-point property holds at x˜, z˜:

f(x˜, z) ≤ f(x˜, z˜) ≤ f(x, z˜)
for all x, z. Show that ∇f(x˜, z˜) = 0.

Examples

3.15 A family of concave utility functions. For 0 < α ≤ 1 let

uα(x) =
xα − 1
α

,

with domuα = R+. We also define u0(x) = log x (with domu0 = R++).

(a) Show that for x > 0, u0(x) = limα→0 uα(x).



116 3 Convex functions

(b) Show that uα are concave, monotone increasing, and all satisfy uα(1) = 0.

These functions are often used in economics to model the benefit or utility of some quantity
of goods or money. Concavity of uα means that the marginal utility (i.e., the increase
in utility obtained for a fixed increase in the goods) decreases as the amount of goods
increases. In other words, concavity models the effect of satiation.

3.16 For each of the following functions determine whether it is convex, concave, quasiconvex,
or quasiconcave.

(a) f(x) = ex − 1 on R.
(b) f(x1, x2) = x1x2 on R

2
++.

(c) f(x1, x2) = 1/(x1x2) on R
2
++.

(d) f(x1, x2) = x1/x2 on R
2
++.

(e) f(x1, x2) = x
2
1/x2 on R×R++.

(f) f(x1, x2) = x
α
1 x

1−α
2 , where 0 ≤ α ≤ 1, on R2++.

3.17 Suppose p < 1, p 6= 0. Show that the function

f(x) =

(
n∑
i=1

xpi

)1/p
with dom f = Rn++ is concave. This includes as special cases f(x) = (

∑n
i=1

x
1/2
i )

2 and

the harmonic mean f(x) = (
∑n

i=1
1/xi)

−1. Hint. Adapt the proofs for the log-sum-exp
function and the geometric mean in §3.1.5.

3.18 Adapt the proof of concavity of the log-determinant function in §3.1.5 to show the follow-
ing.

(a) f(X) = tr
(
X−1

)
is convex on dom f = Sn++.

(b) f(X) = (detX)1/n is concave on dom f = Sn++.

3.19 Nonnegative weighted sums and integrals.

(a) Show that f(x) =
∑r

i=1
αix[i] is a convex function of x, where α1 ≥ α2 ≥ · · · ≥

αr ≥ 0, and x[i] denotes the ith largest component of x. (You can use the fact that
f(x) =

∑k
i=1

x[i] is convex on R
n.)

(b) Let T (x, ω) denote the trigonometric polynomial

T (x, ω) = x1 + x2 cosω + x3 cos 2ω + · · ·+ xn cos(n− 1)ω.
Show that the function

f(x) = −
∫ 2π
0

log T (x, ω) dω

is convex on {x ∈ Rn | T (x, ω) > 0, 0 ≤ ω ≤ 2π}.
3.20 Composition with an affine function. Show that the following functions f : Rn → R are

convex.

(a) f(x) = ‖Ax− b‖, where A ∈ Rm×n, b ∈ Rm, and ‖ · ‖ is a norm on Rm.
(b) f(x) = − (det(A0 + x1A1 + · · ·+ xnAn))1/m, on {x | A0 + x1A1 + · · ·+ xnAn ≻ 0},

where Ai ∈ Sm.
(c) f(X) = tr (A0 + x1A1 + · · ·+ xnAn)−1, on {x | A0+x1A1+ · · ·+xnAn ≻ 0}, where

Ai ∈ Sm. (Use the fact that tr(X−1) is convex on Sm++; see exercise 3.18.)



Exercises 117

3.21 Pointwise maximum and supremum. Show that the following functions f : Rn → R are
convex.

(a) f(x) = maxi=1,...,k ‖A(i)x− b(i)‖, where A(i) ∈ Rm×n, b(i) ∈ Rm and ‖ · ‖ is a norm
on Rm.

(b) f(x) =
∑r

i=1
|x|[i] on Rn, where |x| denotes the vector with |x|i = |xi| (i.e., |x| is

the absolute value of x, componentwise), and |x|[i] is the ith largest component of
|x|. In other words, |x|[1], |x|[2], . . . , |x|[n] are the absolute values of the components
of x, sorted in nonincreasing order.

3.22 Composition rules. Show that the following functions are convex.

(a) f(x) = − log(− log(∑m
i=1

ea
T
i
x+bi)) on dom f = {x | ∑m

i=1
ea

T
i
x+bi < 1}. You can

use the fact that log(
∑n

i=1
eyi) is convex.

(b) f(x, u, v) = −√uv − xTx on dom f = {(x, u, v) | uv > xTx, u, v > 0}. Use the
fact that xTx/u is convex in (x, u) for u > 0, and that −√x1x2 is convex on R2++.

(c) f(x, u, v) = − log(uv − xTx) on dom f = {(x, u, v) | uv > xTx, u, v > 0}.
(d) f(x, t) = −(tp−‖x‖pp)1/p where p > 1 and dom f = {(x, t) | t ≥ ‖x‖p}. You can use

the fact that ‖x‖pp/up−1 is convex in (x, u) for u > 0 (see exercise 3.23), and that
−x1/py1−1/p is convex on R2+ (see exercise 3.16).

(e) f(x, t) = − log(tp − ‖x‖pp) where p > 1 and dom f = {(x, t) | t > ‖x‖p}. You can
use the fact that ‖x‖pp/up−1 is convex in (x, u) for u > 0 (see exercise 3.23).

3.23 Perspective of a function.

(a) Show that for p > 1,

f(x, t) =
|x1|p + · · ·+ |xn|p

tp−1
=
‖x‖pp
tp−1

is convex on {(x, t) | t > 0}.
(b) Show that

f(x) =
‖Ax+ b‖22
cTx+ d

is convex on {x | cTx+ d > 0}, where A ∈ Rm×n, b ∈ Rm, c ∈ Rn and d ∈ R.
3.24 Some functions on the probability simplex. Let x be a real-valued random variable which

takes values in {a1, . . . , an} where a1 < a2 < · · · < an, with prob(x = ai) = pi,
i = 1, . . . , n. For each of the following functions of p (on the probability simplex {p ∈
Rn+ | 1T p = 1}), determine if the function is convex, concave, quasiconvex, or quasicon-
cave.

(a) Ex.

(b) prob(x ≥ α).
(c) prob(α ≤ x ≤ β).
(d)

∑n
i=1

pi log pi, the negative entropy of the distribution.

(e) varx = E(x−Ex)2.
(f) quartile(x) = inf{β | prob(x ≤ β) ≥ 0.25}.
(g) The cardinality of the smallest set A ⊆ {a1, . . . , an} with probability ≥ 90%. (By

cardinality we mean the number of elements in A.)
(h) The minimum width interval that contains 90% of the probability, i.e.,

inf {β − α | prob(α ≤ x ≤ β) ≥ 0.9} .



118 3 Convex functions

3.25 Maximum probability distance between distributions. Let p, q ∈ Rn represent two proba-
bility distributions on {1, . . . , n} (so p, q � 0, 1T p = 1T q = 1). We define the maximum
probability distance dmp(p, q) between p and q as the maximum difference in probability
assigned by p and q, over all events:

dmp(p, q) = max{|prob(p, C)− prob(q, C)| | C ⊆ {1, . . . , n}}.
Here prob(p, C) is the probability of C, under the distribution p, i.e., prob(p, C) =∑

i∈C
pi.

Find a simple expression for dmp, involving ‖p− q‖1 =
∑n

i=1
|pi − qi|, and show that dmp

is a convex function on Rn ×Rn. (Its domain is {(p, q) | p, q � 0, 1T p = 1T q = 1}, but
it has a natural extension to all of Rn ×Rn.)

3.26 More functions of eigenvalues. Let λ1(X) ≥ λ2(X) ≥ · · · ≥ λn(X) denote the eigenvalues
of a matrix X ∈ Sn. We have already seen several functions of the eigenvalues that are
convex or concave functions of X.

• The maximum eigenvalue λ1(X) is convex (example 3.10). The minimum eigenvalue
λn(X) is concave.

• The sum of the eigenvalues (or trace), trX = λ1(X) + · · ·+ λn(X), is linear.
• The sum of the inverses of the eigenvalues (or trace of the inverse), tr(X−1) =∑n

i=1
1/λi(X), is convex on S

n
++ (exercise 3.18).

• The geometric mean of the eigenvalues, (detX)1/n = (∏n
i=1

λi(X))
1/n, and the

logarithm of the product of the eigenvalues, log detX =
∑n

i=1
log λi(X), are concave

on X ∈ Sn++ (exercise 3.18 and page 74).
In this problem we explore some more functions of eigenvalues, by exploiting variational
characterizations.

(a) Sum of k largest eigenvalues. Show that
∑k

i=1
λi(X) is convex on S

n. Hint. [HJ85,
page 191] Use the variational characterization

k∑
i=1

λi(X) = sup{tr(V TXV ) | V ∈ Rn×k, V TV = I}.

(b) Geometric mean of k smallest eigenvalues. Show that (
∏n

i=n−k+1
λi(X))

1/k is con-

cave on Sn++. Hint. [MO79, page 513] For X ≻ 0, we have(
n∏

i=n−k+1

λi(X)

)1/k
=

1

k
inf{tr(V TXV ) | V ∈ Rn×k, detV TV = 1}.

(c) Log of product of k smallest eigenvalues. Show that
∑n

i=n−k+1
log λi(X) is concave

on Sn++. Hint. [MO79, page 513] For X ≻ 0,
n∏

i=n−k+1

λi(X) = inf

{
k∏
i=1

(V TXV )ii

∣∣∣∣∣ V ∈ Rn×k, V TV = I
}
.

3.27 Diagonal elements of Cholesky factor. Each X ∈ Sn++ has a unique Cholesky factorization
X = LLT , where L is lower triangular, with Lii > 0. Show that Lii is a concave function
of X (with domain Sn++).

Hint. Lii can be expressed as Lii = (w − zTY −1z)1/2, where[
Y z
zT w

]
is the leading i× i submatrix of X.



Exercises 119

Operations that preserve convexity

3.28 Expressing a convex function as the pointwise supremum of a family of affine functions.
In this problem we extend the result proved on page 83 to the case where dom f 6= Rn.
Let f : Rn → R be a convex function. Define f˜ : Rn → R as the pointwise supremum of
all affine functions that are global underestimators of f :

f˜(x) = sup{g(x) | g affine, g(z) ≤ f(z) for all z}.
(a) Show that f(x) = f˜(x) for x ∈ int dom f .
(b) Show that f = f˜ if f is closed (i.e., epi f is a closed set; see §A.3.3).

3.29 Representation of piecewise-linear convex functions. A function f : Rn → R, with
dom f = Rn, is called piecewise-linear if there exists a partition of Rn as

R
n = X1 ∪X2 ∪ · · · ∪XL,

where intXi 6= ∅ and intXi ∩ intXj = ∅ for i 6= j, and a family of affine functions
aT1 x+ b1, . . . , a

T
Lx+ bL such that f(x) = a

T
i x+ bi for x ∈ Xi.

Show that this means that f(x) = max{aT1 x+ b1, . . . , aTLx+ bL}.
3.30 Convex hull or envelope of a function. The convex hull or convex envelope of a function

f : Rn → R is defined as
g(x) = inf{t | (x, t) ∈ conv epi f}.

Geometrically, the epigraph of g is the convex hull of the epigraph of f .

Show that g is the largest convex underestimator of f . In other words, show that if h is
convex and satisfies h(x) ≤ f(x) for all x, then h(x) ≤ g(x) for all x.

3.31 [Roc70, page 35] Largest homogeneous underestimator. Let f be a convex function. Define
the function g as

g(x) = inf
α>0

f(αx)

α
.

(a) Show that g is homogeneous (g(tx) = tg(x) for all t ≥ 0).
(b) Show that g is the largest homogeneous underestimator of f : If h is homogeneous

and h(x) ≤ f(x) for all x, then we have h(x) ≤ g(x) for all x.
(c) Show that g is convex.

3.32 Products and ratios of convex functions. In general the product or ratio of two convex
functions is not convex. However, there are some results that apply to functions on R.
Prove the following.

(a) If f and g are convex, both nondecreasing (or nonincreasing), and positive functions
on an interval, then fg is convex.

(b) If f , g are concave, positive, with one nondecreasing and the other nonincreasing,
then fg is concave.

(c) If f is convex, nondecreasing, and positive, and g is concave, nonincreasing, and
positive, then f/g is convex.

3.33 Direct proof of perspective theorem. Give a direct proof that the perspective function g,
as defined in §3.2.6, of a convex function f is convex: Show that dom g is a convex set,
and that for (x, t), (y, s) ∈ dom g, and 0 ≤ θ ≤ 1, we have

g(θx+ (1− θ)y, θt+ (1− θ)s) ≤ θg(x, t) + (1− θ)g(y, s).
3.34 The Minkowski function. The Minkowski function of a convex set C is defined as

MC(x) = inf{t > 0 | t−1x ∈ C}.



120 3 Convex functions

(a) Draw a picture giving a geometric interpretation of how to find MC(x).

(b) Show that MC is homogeneous, i.e., MC(αx) = αMC(x) for α ≥ 0.
(c) What is domMC?

(d) Show that MC is a convex function.

(e) Suppose C is also closed, bounded, symmetric (if x ∈ C then −x ∈ C), and has
nonempty interior. Show that MC is a norm. What is the corresponding unit ball?

3.35 Support function calculus. Recall that the support function of a set C ⊆ Rn is defined as
SC(y) = sup{yTx | x ∈ C}. On page 81 we showed that SC is a convex function.
(a) Show that SB = SconvB .

(b) Show that SA+B = SA + SB .

(c) Show that SA∪B = max{SA, SB}.
(d) Let B be closed and convex. Show that A ⊆ B if and only if SA(y) ≤ SB(y) for all

y.

Conjugate functions

3.36 Derive the conjugates of the following functions.

(a) Max function. f(x) = maxi=1,...,n xi on R
n.

(b) Sum of largest elements. f(x) =
∑r

i=1
x[i] on R

n.

(c) Piecewise-linear function on R. f(x) = maxi=1,...,m(aix + bi) on R. You can
assume that the ai are sorted in increasing order, i.e., a1 ≤ · · · ≤ am, and that none
of the functions aix + bi is redundant, i.e., for each k there is at least one x with
f(x) = akx+ bk.

(d) Power function. f(x) = xp on R++, where p > 1. Repeat for p < 0.

(e) Negative geometric mean. f(x) = −(∏xi)1/n on Rn++.
(f) Negative generalized logarithm for second-order cone. f(x, t) = − log(t2 − xTx) on

{(x, t) ∈ Rn ×R | ‖x‖2 < t}.
3.37 Show that the conjugate of f(X) = tr(X−1) with dom f = Sn++ is given by

f∗(Y ) = −2 tr(−Y )1/2, dom f∗ = −Sn+.

Hint. The gradient of f is ∇f(X) = −X−2.
3.38 Young’s inequality. Let f : R→ R be an increasing function, with f(0) = 0, and let g be

its inverse. Define F and G as

F (x) =

∫ x
0

f(a) da, G(y) =

∫ y
0

g(a) da.

Show that F and G are conjugates. Give a simple graphical interpretation of Young’s
inequality,

xy ≤ F (x) +G(y).
3.39 Properties of conjugate functions.

(a) Conjugate of convex plus affine function. Define g(x) = f(x) + cTx+ d, where f is
convex. Express g∗ in terms of f∗ (and c, d).

(b) Conjugate of perspective. Express the conjugate of the perspective of a convex
function f in terms of f∗.



Exercises 121

(c) Conjugate and minimization. Let f(x, z) be convex in (x, z) and define g(x) =
infz f(x, z). Express the conjugate g

∗ in terms of f∗.

As an application, express the conjugate of g(x) = infz{h(z) | Az+ b = x}, where h
is convex, in terms of h∗, A, and b.

(d) Conjugate of conjugate. Show that the conjugate of the conjugate of a closed convex
function is itself: f = f∗∗ if f is closed and convex. (A function is closed if its
epigraph is closed; see §A.3.3.) Hint. Show that f∗∗ is the pointwise supremum of
all affine global underestimators of f . Then apply the result of exercise 3.28.

3.40 Gradient and Hessian of conjugate function. Suppose f : Rn → R is convex and twice
continuously differentiable. Suppose y¯ and x¯ are related by y¯ = ∇f(x¯), and that∇2f(x¯) ≻
0.

(a) Show that ∇f∗(y¯) = x¯.
(b) Show that ∇2f∗(y¯) = ∇2f(x¯)−1.

3.41 Conjugate of negative normalized entropy. Show that the conjugate of the negative nor-
malized entropy

f(x) =

n∑
i=1

xi log(xi/1
Tx),

with dom f = Rn++, is given by

f∗(y) =

{
0

∑n
i=1

eyi ≤ 1
+∞ otherwise.

Quasiconvex functions

3.42 Approximation width. Let f0, . . . , fn : R→ R be given continuous functions. We consider
the problem of approximating f0 as a linear combination of f1, . . . , fn. For x ∈ Rn, we
say that f = x1f1 + · · · + xnfn approximates f0 with tolerance ǫ > 0 over the interval
[0, T ] if |f(t)− f0(t)| ≤ ǫ for 0 ≤ t ≤ T . Now we choose a fixed tolerance ǫ > 0 and define
the approximation width as the largest T such that f approximates f0 over the interval
[0, T ]:

W (x) = sup{T | |x1f1(t) + · · ·+ xnfn(t)− f0(t)| ≤ ǫ for 0 ≤ t ≤ T}.
Show that W is quasiconcave.

3.43 First-order condition for quasiconvexity. Prove the first-order condition for quasiconvexity
given in §3.4.3: A differentiable function f : Rn → R, with dom f convex, is quasiconvex
if and only if for all x, y ∈ dom f ,

f(y) ≤ f(x) =⇒ ∇f(x)T (y − x) ≤ 0.
Hint. It suffices to prove the result for a function on R; the general result follows by
restriction to an arbitrary line.

3.44 Second-order conditions for quasiconvexity. In this problem we derive alternate repre-
sentations of the second-order conditions for quasiconvexity given in §3.4.3. Prove the
following.

(a) A point x ∈ dom f satisfies (3.21) if and only if there exists a σ such that
∇2f(x) + σ∇f(x)∇f(x)T � 0. (3.26)

It satisfies (3.22) for all y 6= 0 if and only if there exists a σ such
∇2f(x) + σ∇f(x)∇f(x)T ≻ 0. (3.27)

Hint. We can assume without loss of generality that ∇2f(x) is diagonal.



122 3 Convex functions

(b) A point x ∈ dom f satisfies (3.21) if and only if either ∇f(x) = 0 and ∇2f(x) � 0,
or ∇f(x) 6= 0 and the matrix

H(x) =

[
∇2f(x) ∇f(x)
∇f(x)T 0

]
has exactly one negative eigenvalue. It satisfies (3.22) for all y 6= 0 if and only if
H(x) has exactly one nonpositive eigenvalue.

Hint. You can use the result of part (a). The following result, which follows from
the eigenvalue interlacing theorem in linear algebra, may also be useful: If B ∈ Sn
and a ∈ Rn, then

λn

([
B a
aT 0

])
≥ λn(B).

3.45 Use the first and second-order conditions for quasiconvexity given in §3.4.3 to verify
quasiconvexity of the function f(x) = −x1x2, with dom f = R2++.

3.46 Quasilinear functions with domain Rn. A function on R that is quasilinear (i.e., qua-
siconvex and quasiconcave) is monotone, i.e., either nondecreasing or nonincreasing. In
this problem we consider a generalization of this result to functions on Rn.

Suppose the function f : Rn → R is quasilinear and continuous with dom f = Rn. Show
that it can be expressed as f(x) = g(aTx), where g : R → R is monotone and a ∈ Rn.
In other words, a quasilinear function with domain Rn must be a monotone function of
a linear function. (The converse is also true.)

Log-concave and log-convex functions

3.47 Suppose f : Rn → R is differentiable, dom f is convex, and f(x) > 0 for all x ∈ dom f .
Show that f is log-concave if and only if for all x, y ∈ dom f ,

f(y)

f(x)
≤ exp

(
∇f(x)T (y − x)

f(x)

)
.

3.48 Show that if f : Rn → R is log-concave and a ≥ 0, then the function g = f − a is
log-concave, where dom g = {x ∈ dom f | f(x) > a}.

3.49 Show that the following functions are log-concave.

(a) Logistic function: f(x) = ex/(1 + ex) with dom f = R.

(b) Harmonic mean:

f(x) =
1

1/x1 + · · ·+ 1/xn , dom f = R
n
++.

(c) Product over sum:

f(x) =

∏n
i=1

xi∑n
i=1

xi
, dom f = Rn++.

(d) Determinant over trace:

f(X) =
detX

trX
, dom f = Sn++.



Exercises 123

3.50 Coefficients of a polynomial as a function of the roots. Show that the coefficients of a
polynomial with real negative roots are log-concave functions of the roots. In other words,
the functions ai : R

n → R, defined by the identity

sn + a1(λ)s
n−1 + · · ·+ an−1(λ)s+ an(λ) = (s− λ1)(s− λ2) · · · (s− λn),

are log-concave on −Rn++.
Hint. The function

Sk(x) =
∑

1≤i1<i2<···<ik≤n

xi1xi2 · · ·xik ,

with domSk ∈ Rn+ and 1 ≤ k ≤ n, is called the kth elementary symmetric function on
Rn. It can be shown that S

1/k
k is concave (see [ML57]).

3.51 [BL00, page 41] Let p be a polynomial on R, with all its roots real. Show that it is
log-concave on any interval on which it is positive.

3.52 [MO79, §3.E.2] Log-convexity of moment functions. Suppose f : R → R is nonnegative
with R+ ⊆ dom f . For x ≥ 0 define

φ(x) =

∫ ∞
0

uxf(u) du.

Show that φ is a log-convex function. (If x is a positive integer, and f is a probability
density function, then φ(x) is the xth moment of the distribution.)

Use this to show that the Gamma function,

Γ(x) =

∫ ∞
0

ux−1e−u du,

is log-convex for x ≥ 1.
3.53 Suppose x and y are independent random vectors in Rn, with log-concave probability

density functions f and g, respectively. Show that the probability density function of the
sum z = x+ y is log-concave.

3.54 Log-concavity of Gaussian cumulative distribution function. The cumulative distribution
function of a Gaussian random variable,

f(x) =
1√
2π

∫ x
−∞

e−t
2/2 dt,

is log-concave. This follows from the general result that the convolution of two log-concave
functions is log-concave. In this problem we guide you through a simple self-contained
proof that f is log-concave. Recall that f is log-concave if and only if f ′′(x)f(x) ≤ f ′(x)2
for all x.

(a) Verify that f ′′(x)f(x) ≤ f ′(x)2 for x ≥ 0. That leaves us the hard part, which is to
show the inequality for x < 0.

(b) Verify that for any t and x we have t2/2 ≥ −x2/2 + xt.
(c) Using part (b) show that e−t

2/2 ≤ ex2/2−xt. Conclude that, for x < 0,∫ x
−∞

e−t
2/2 dt ≤ ex2/2

∫ x
−∞

e−xt dt.

(d) Use part (c) to verify that f ′′(x)f(x) ≤ f ′(x)2 for x ≤ 0.



124 3 Convex functions

3.55 Log-concavity of the cumulative distribution function of a log-concave probability density.
In this problem we extend the result of exercise 3.54. Let g(t) = exp(−h(t)) be a differ-
entiable log-concave probability density function, and let

f(x) =

∫ x
−∞

g(t) dt =

∫ x
−∞

e−h(t) dt

be its cumulative distribution. We will show that f is log-concave, i.e., it satisfies
f ′′(x)f(x) ≤ (f ′(x))2 for all x.
(a) Express the derivatives of f in terms of the function h. Verify that f ′′(x)f(x) ≤

(f ′(x))2 if h′(x) ≥ 0.
(b) Assume that h′(x) < 0. Use the inequality

h(t) ≥ h(x) + h′(x)(t− x)
(which follows from convexity of h), to show that∫ x

−∞

e−h(t) dt ≤ e
−h(x)

−h′(x) .

Use this inequality to verify that f ′′(x)f(x) ≤ (f ′(x))2 if h′(x) < 0.
3.56 More log-concave densities. Show that the following densities are log-concave.

(a) [MO79, page 493] The gamma density, defined by

f(x) =
αλ

Γ(λ)
xλ−1e−αx,

with dom f = R+. The parameters λ and α satisfy λ ≥ 1, α > 0.
(b) [MO79, page 306] The Dirichlet density

f(x) =
Γ(1Tλ)

Γ(λ1) · · ·Γ(λn+1)x
λ1−1
1 · · ·xλn−1n

(
1−

n∑
i=1

xi

)λn+1−1
with dom f = {x ∈ Rn++ | 1Tx < 1}. The parameter λ satisfies λ � 1.

Convexity with respect to a generalized inequality

3.57 Show that the function f(X) = X−1 is matrix convex on Sn++.

3.58 Schur complement. Suppose X ∈ Sn partitioned as

X =

[
A B
BT C

]
,

where A ∈ Sk. The Schur complement of X (with respect to A) is S = C − BTA−1B
(see §A.5.5). Show that the Schur complement, viewed as a function from Sn into Sn−k,
is matrix concave on Sn++.

3.59 Second-order conditions for K-convexity. Let K ⊆ Rm be a proper convex cone, with
associated generalized inequality �K . Show that a twice differentiable function f : Rn →
Rm, with convex domain, is K-convex if and only if for all x ∈ dom f and all y ∈ Rn,

n∑
i,j=1

∂2f(x)

∂xi∂xj
yiyj �K 0,

i.e., the second derivative is a K-nonnegative bilinear form. (Here ∂2f/∂xi∂xj ∈ Rm,
with components ∂2fk/∂xi∂xj , for k = 1, . . . ,m; see §A.4.1.)



Exercises 125

3.60 Sublevel sets and epigraph of K-convex functions. Let K ⊆ Rm be a proper convex cone
with associated generalized inequality �K , and let f : Rn → Rm. For α ∈ Rm, the
α-sublevel set of f (with respect to �K) is defined as

Cα = {x ∈ Rn | f(x) �K α}.
The epigraph of f , with respect to �K , is defined as the set

epiKf = {(x, t) ∈ Rn+m | f(x) �K t}.
Show the following:

(a) If f is K-convex, then its sublevel sets Cα are convex for all α.

(b) f is K-convex if and only if epiK f is a convex set.





Chapter 4

Convex optimization problems

4.1 Optimization problems

4.1.1 Basic terminology

We use the notation

minimize f0(x)
subject to fi(x) ≤ 0, i = 1, . . . ,m

hi(x) = 0, i = 1, . . . , p
(4.1)

to describe the problem of finding an x that minimizes f0(x) among all x that satisfy
the conditions fi(x) ≤ 0, i = 1, . . . ,m, and hi(x) = 0, i = 1, . . . , p. We call x ∈ Rn
the optimization variable and the function f0 : R

n → R the objective function or
cost function. The inequalities fi(x) ≤ 0 are called inequality constraints, and the
corresponding functions fi : R

n → R are called the inequality constraint functions.
The equations hi(x) = 0 are called the equality constraints, and the functions
hi : R

n → R are the equality constraint functions. If there are no constraints (i.e.,
m = p = 0) we say the problem (4.1) is unconstrained.

The set of points for which the objective and all constraint functions are defined,

D =
m⋂
i=0

dom fi ∩
p⋂
i=1

domhi,

is called the domain of the optimization problem (4.1). A point x ∈ D is feasible
if it satisfies the constraints fi(x) ≤ 0, i = 1, . . . ,m, and hi(x) = 0, i = 1, . . . , p.
The problem (4.1) is said to be feasible if there exists at least one feasible point,
and infeasible otherwise. The set of all feasible points is called the feasible set or
the constraint set.

The optimal value p⋆ of the problem (4.1) is defined as

p⋆ = inf {f0(x) | fi(x) ≤ 0, i = 1, . . . ,m, hi(x) = 0, i = 1, . . . , p} .
We allow p⋆ to take on the extended values ±∞. If the problem is infeasible, we
have p⋆ =∞ (following the standard convention that the infimum of the empty set



128 4 Convex optimization problems

is∞). If there are feasible points xk with f0(xk)→ −∞ as k →∞, then p⋆ = −∞,
and we say the problem (4.1) is unbounded below.

Optimal and locally optimal points

We say x⋆ is an optimal point, or solves the problem (4.1), if x⋆ is feasible and
f0(x

⋆) = p⋆. The set of all optimal points is the optimal set, denoted

Xopt = {x | fi(x) ≤ 0, i = 1, . . . ,m, hi(x) = 0, i = 1, . . . , p, f0(x) = p⋆}.
If there exists an optimal point for the problem (4.1), we say the optimal value
is attained or achieved, and the problem is solvable. If Xopt is empty, we say
the optimal value is not attained or not achieved. (This always occurs when the
problem is unbounded below.) A feasible point x with f0(x) ≤ p⋆ + ǫ (where
ǫ > 0) is called ǫ-suboptimal, and the set of all ǫ-suboptimal points is called the
ǫ-suboptimal set for the problem (4.1).

We say a feasible point x is locally optimal if there is an R > 0 such that

f0(x) = inf{f0(z) | fi(z) ≤ 0, i = 1, . . . ,m,
hi(z) = 0, i = 1, . . . , p, ‖z − x‖2 ≤ R},

or, in other words, x solves the optimization problem

minimize f0(z)
subject to fi(z) ≤ 0, i = 1, . . . ,m

hi(z) = 0, i = 1, . . . , p
‖z − x‖2 ≤ R

with variable z. Roughly speaking, this means x minimizes f0 over nearby points
in the feasible set. The term ‘globally optimal’ is sometimes used for ‘optimal’
to distinguish between ‘locally optimal’ and ‘optimal’. Throughout this book,
however, optimal will mean globally optimal.

If x is feasible and fi(x) = 0, we say the ith inequality constraint fi(x) ≤ 0 is
active at x. If fi(x) < 0, we say the constraint fi(x) ≤ 0 is inactive. (The equality
constraints are active at all feasible points.) We say that a constraint is redundant
if deleting it does not change the feasible set.

Example 4.1 We illustrate these definitions with a few simple unconstrained opti-
mization problems with variable x ∈ R, and dom f0 = R++.
• f0(x) = 1/x: p⋆ = 0, but the optimal value is not achieved.
• f0(x) = − log x: p⋆ = −∞, so this problem is unbounded below.
• f0(x) = x log x: p⋆ = −1/e, achieved at the (unique) optimal point x⋆ = 1/e.

Feasibility problems

If the objective function is identically zero, the optimal value is either zero (if the
feasible set is nonempty) or ∞ (if the feasible set is empty). We call this the



4.1 Optimization problems 129

feasibility problem, and will sometimes write it as

find x
subject to fi(x) ≤ 0, i = 1, . . . ,m

hi(x) = 0, i = 1, . . . , p.

The feasibility problem is thus to determine whether the constraints are consistent,
and if so, find a point that satisfies them.

4.1.2 Expressing problems in standard form

We refer to (4.1) as an optimization problem in standard form. In the standard
form problem we adopt the convention that the righthand side of the inequality
and equality constraints are zero. This can always be arranged by subtracting any
nonzero righthand side: we represent the equality constraint gi(x) = g˜i(x), for
example, as hi(x) = 0, where hi(x) = gi(x) − g˜i(x). In a similar way we express
inequalities of the form fi(x) ≥ 0 as −fi(x) ≤ 0.

Example 4.2 Box constraints. Consider the optimization problem

minimize f0(x)
subject to li ≤ xi ≤ ui, i = 1, . . . , n,

where x ∈ Rn is the variable. The constraints are called variable bounds (since they
give lower and upper bounds for each xi) or box constraints (since the feasible set is
a box).

We can express this problem in standard form as

minimize f0(x)
subject to li − xi ≤ 0, i = 1, . . . , n

xi − ui ≤ 0, i = 1, . . . , n.

There are 2n inequality constraint functions:

fi(x) = li − xi, i = 1, . . . , n,

and

fi(x) = xi−n − ui−n, i = n+ 1, . . . , 2n.

Maximization problems

We concentrate on the minimization problem by convention. We can solve the
maximization problem

maximize f0(x)
subject to fi(x) ≤ 0, i = 1, . . . ,m

hi(x) = 0, i = 1, . . . , p
(4.2)



130 4 Convex optimization problems

by minimizing the function −f0 subject to the constraints. By this correspondence
we can define all the terms above for the maximization problem (4.2). For example
the optimal value of (4.2) is defined as

p⋆ = sup{f0(x) | fi(x) ≤ 0, i = 1, . . . ,m, hi(x) = 0, i = 1, . . . , p},
and a feasible point x is ǫ-suboptimal if f0(x) ≥ p⋆ − ǫ. When the maximization
problem is considered, the objective is sometimes called the utility or satisfaction
level instead of the cost.

4.1.3 Equivalent problems

In this book we will use the notion of equivalence of optimization problems in an
informal way. We call two problems equivalent if from a solution of one, a solution
of the other is readily found, and vice versa. (It is possible, but complicated, to
give a formal definition of equivalence.)

As a simple example, consider the problem

minimize f˜(x) = α0f0(x)

subject to f˜i(x) = αifi(x) ≤ 0, i = 1, . . . ,m
h˜i(x) = βihi(x) = 0, i = 1, . . . , p,

(4.3)

where αi > 0, i = 0, . . . ,m, and βi 6= 0, i = 1, . . . , p. This problem is obtained from
the standard form problem (4.1) by scaling the objective and inequality constraint
functions by positive constants, and scaling the equality constraint functions by
nonzero constants. As a result, the feasible sets of the problem (4.3) and the original
problem (4.1) are identical. A point x is optimal for the original problem (4.1) if
and only if it is optimal for the scaled problem (4.3), so we say the two problems are
equivalent. The two problems (4.1) and (4.3) are not, however, the same (unless
αi and βi are all equal to one), since the objective and constraint functions differ.

We now describe some general transformations that yield equivalent problems.

Change of variables

Suppose φ : Rn → Rn is one-to-one, with image covering the problem domain D,
i.e., φ(domφ) ⊇ D. We define functions f˜i and h˜i as

f˜i(z) = fi(φ(z)), i = 0, . . . ,m, h˜i(z) = hi(φ(z)), i = 1, . . . , p.

Now consider the problem

minimize f˜0(z)

subject to f˜i(z) ≤ 0, i = 1, . . . ,m
h˜i(z) = 0, i = 1, . . . , p,

(4.4)

with variable z. We say that the standard form problem (4.1) and the problem (4.4)
are related by the change of variable or substitution of variable x = φ(z).

The two problems are clearly equivalent: if x solves the problem (4.1), then
z = φ−1(x) solves the problem (4.4); if z solves the problem (4.4), then x = φ(z)
solves the problem (4.1).



4.1 Optimization problems 131

Transformation of objective and constraint functions

Suppose that ψ0 : R → R is monotone increasing, ψ1, . . . , ψm : R → R satisfy
ψi(u) ≤ 0 if and only if u ≤ 0, and ψm+1, . . . , ψm+p : R → R satisfy ψi(u) = 0 if
and only if u = 0. We define functions f˜i and h˜i as the compositions

f˜i(x) = ψi(fi(x)), i = 0, . . . ,m, h˜i(x) = ψm+i(hi(x)), i = 1, . . . , p.

Evidently the associated problem

minimize f˜0(x)

subject to f˜i(x) ≤ 0, i = 1, . . . ,m
h˜i(x) = 0, i = 1, . . . , p

and the standard form problem (4.1) are equivalent; indeed, the feasible sets are
identical, and the optimal points are identical. (The example (4.3) above, in which
the objective and constraint functions are scaled by appropriate constants, is the
special case when all ψi are linear.)

Example 4.3 Least-norm and least-norm-squared problems. As a simple example
consider the unconstrained Euclidean norm minimization problem

minimize ‖Ax− b‖2, (4.5)
with variable x ∈ Rn. Since the norm is always nonnegative, we can just as well solve
the problem

minimize ‖Ax− b‖22 = (Ax− b)T (Ax− b), (4.6)
in which we minimize the square of the Euclidean norm. The problems (4.5) and (4.6)
are clearly equivalent; the optimal points are the same. The two problems are not
the same, however. For example, the objective in (4.5) is not differentiable at any
x with Ax − b = 0, whereas the objective in (4.6) is differentiable for all x (in fact,
quadratic).

Slack variables

One simple transformation is based on the observation that fi(x) ≤ 0 if and only if
there is an si ≥ 0 that satisfies fi(x)+ si = 0. Using this transformation we obtain
the problem

minimize f0(x)
subject to si ≥ 0, i = 1, . . . ,m

fi(x) + si = 0, i = 1, . . . ,m
hi(x) = 0, i = 1, . . . , p,

(4.7)

where the variables are x ∈ Rn and s ∈ Rm. This problem has n +m variables,
m inequality constraints (the nonnegativity constraints on si), and m+ p equality
constraints. The new variable si is called the slack variable associated with the
original inequality constraint fi(x) ≤ 0. Introducing slack variables replaces each
inequality constraint with an equality constraint, and a nonnegativity constraint.

The problem (4.7) is equivalent to the original standard form problem (4.1).
Indeed, if (x, s) is feasible for the problem (4.7), then x is feasible for the original



132 4 Convex optimization problems

problem, since si = −fi(x) ≥ 0. Conversely, if x is feasible for the original problem,
then (x, s) is feasible for the problem (4.7), where we take si = −fi(x). Similarly,
x is optimal for the original problem (4.1) if and only if (x, s) is optimal for the
problem (4.7), where si = −fi(x).

Eliminating equality constraints

If we can explicitly parametrize all solutions of the equality constraints

hi(x) = 0, i = 1, . . . , p, (4.8)

using some parameter z ∈ Rk, then we can eliminate the equality constraints
from the problem, as follows. Suppose the function φ : Rk → Rn is such that
x satisfies (4.8) if and only if there is some z ∈ Rk such that x = φ(z). The
optimization problem

minimize f˜0(z) = f0(φ(z))

subject to f˜i(z) = fi(φ(z)) ≤ 0, i = 1, . . . ,m
is then equivalent to the original problem (4.1). This transformed problem has
variable z ∈ Rk, m inequality constraints, and no equality constraints. If z is
optimal for the transformed problem, then x = φ(z) is optimal for the original
problem. Conversely, if x is optimal for the original problem, then (since x is
feasible) there is at least one z such that x = φ(z). Any such z is optimal for the
transformed problem.

Eliminating linear equality constraints

The process of eliminating variables can be described more explicitly, and easily
carried out numerically, when the equality constraints are all linear, i.e., have the
form Ax = b. If Ax = b is inconsistent, i.e., b 6∈ R(A), then the original problem is
infeasible. Assuming this is not the case, let x0 denote any solution of the equality
constraints. Let F ∈ Rn×k be any matrix with R(F ) = N (A), so the general
solution of the linear equations Ax = b is given by Fz + x0, where z ∈ Rk. (We
can choose F to be full rank, in which case we have k = n− rankA.)

Substituting x = Fz + x0 into the original problem yields the problem

minimize f0(Fz + x0)
subject to fi(Fz + x0) ≤ 0, i = 1, . . . ,m,

with variable z, which is equivalent to the original problem, has no equality con-
straints, and rankA fewer variables.

Introducing equality constraints

We can also introduce equality constraints and new variables into a problem. In-
stead of describing the general case, which is complicated and not very illuminating,
we give a typical example that will be useful later. Consider the problem

minimize f0(A0x+ b0)
subject to fi(Aix+ bi) ≤ 0, i = 1, . . . ,m

hi(x) = 0, i = 1, . . . , p,



4.1 Optimization problems 133

where x ∈ Rn, Ai ∈ Rki×n, and fi : Rki → R. In this problem the objective
and constraint functions are given as compositions of the functions fi with affine
transformations defined by Aix+ bi.

We introduce new variables yi ∈ Rki , as well as new equality constraints yi =
Aix+ bi, for i = 0, . . . ,m, and form the equivalent problem

minimize f0(y0)
subject to fi(yi) ≤ 0, i = 1, . . . ,m

yi = Aix+ bi, i = 0, . . . ,m
hi(x) = 0, i = 1, . . . , p.

This problem has k0 + · · ·+ km new variables,

y0 ∈ Rk0 , . . . , ym ∈ Rkm ,

and k0 + · · ·+ km new equality constraints,

y0 = A0x+ b0, . . . , ym = Amx+ bm.

The objective and inequality constraints in this problem are independent, i.e., in-
volve different optimization variables.

Optimizing over some variables

We always have

inf
x,y

f(x, y) = inf
x
f˜(x)

where f˜(x) = infy f(x, y). In other words, we can always minimize a function by
first minimizing over some of the variables, and then minimizing over the remaining
ones. This simple and general principle can be used to transform problems into
equivalent forms. The general case is cumbersome to describe and not illuminating,
so we describe instead an example.

Suppose the variable x ∈ Rn is partitioned as x = (x1, x2), with x1 ∈ Rn1 ,
x2 ∈ Rn2 , and n1 + n2 = n. We consider the problem

minimize f0(x1, x2)
subject to fi(x1) ≤ 0, i = 1, . . . ,m1

f˜i(x2) ≤ 0, i = 1, . . . ,m2,
(4.9)

in which the constraints are independent, in the sense that each constraint function
depends on x1 or x2. We first minimize over x2. Define the function f˜0 of x1 by

f˜0(x1) = inf{f0(x1, z) | f˜i(z) ≤ 0, i = 1, . . . ,m2}.

The problem (4.9) is then equivalent to

minimize f˜0(x1)
subject to fi(x1) ≤ 0, i = 1, . . . ,m1. (4.10)



134 4 Convex optimization problems

Example 4.4 Minimizing a quadratic function with constraints on some variables.
Consider a problem with strictly convex quadratic objective, with some of the vari-
ables unconstrained:

minimize xT1 P11x1 + 2x
T
1 P12x2 + x

T
2 P22x2

subject to fi(x1) ≤ 0, i = 1, . . . ,m,
where P11 and P22 are symmetric. Here we can analytically minimize over x2:

inf
x2

(
xT1 P11x1 + 2x

T
1 P12x2 + x

T
2 P22x2

)
= xT1

(
P11 − P12P−122 PT12

)
x1

(see §A.5.5). Therefore the original problem is equivalent to
minimize xT1

(
P11 − P12P−122 PT12

)
x1

subject to fi(x1) ≤ 0, i = 1, . . . ,m.

Epigraph problem form

The epigraph form of the standard problem (4.1) is the problem

minimize t
subject to f0(x)− t ≤ 0

fi(x) ≤ 0, i = 1, . . . ,m
hi(x) = 0, i = 1, . . . , p,

(4.11)

with variables x ∈ Rn and t ∈ R. We can easily see that it is equivalent to the
original problem: (x, t) is optimal for (4.11) if and only if x is optimal for (4.1)
and t = f0(x). Note that the objective function of the epigraph form problem is a
linear function of the variables x, t.

The epigraph form problem (4.11) can be interpreted geometrically as an op-
timization problem in the ‘graph space’ (x, t): we minimize t over the epigraph of
f0, subject to the constraints on x. This is illustrated in figure 4.1.

Implicit and explicit constraints

By a simple trick already mentioned in §3.1.2, we can include any of the constraints
implicitly in the objective function, by redefining its domain. As an extreme ex-
ample, the standard form problem can be expressed as the unconstrained problem

minimize F (x), (4.12)

where we define the function F as f0, but with domain restricted to the feasible
set:

domF = {x ∈ dom f0 | fi(x) ≤ 0, i = 1, . . . ,m, hi(x) = 0, i = 1, . . . , p},
and F (x) = f0(x) for x ∈ domF . (Equivalently, we can define F (x) to have value
∞ for x not feasible.) The problems (4.1) and (4.12) are clearly equivalent: they
have the same feasible set, optimal points, and optimal value.

Of course this transformation is nothing more than a notational trick. Making
the constraints implicit has not made the problem any easier to analyze or solve,



4.1 Optimization problems 135

t

x

epi f0

(x⋆, t⋆)

Figure 4.1 Geometric interpretation of epigraph form problem, for a prob-
lem with no constraints. The problem is to find the point in the epigraph
(shown shaded) that minimizes t, i.e., the ‘lowest’ point in the epigraph.
The optimal point is (x⋆, t⋆).

even though the problem (4.12) is, at least nominally, unconstrained. In some ways
the transformation makes the problem more difficult. Suppose, for example, that
the objective f0 in the original problem is differentiable, so in particular its domain
is open. The restricted objective function F is probably not differentiable, since
its domain is likely not to be open.

Conversely, we will encounter problems with implicit constraints, which we can
then make explicit. As a simple example, consider the unconstrained problem

minimize f(x) (4.13)

where the function f is given by

f(x) =

{
xTx Ax = b
∞ otherwise.

Thus, the objective function is equal to the quadratic form xTx on the affine set
defined by Ax = b, and ∞ off the affine set. Since we can clearly restrict our
attention to points that satisfy Ax = b, we say that the problem (4.13) has an
implicit equality constraint Ax = b hidden in the objective. We can make the
implicit equality constraint explicit, by forming the equivalent problem

minimize xTx
subject to Ax = b.

(4.14)

While the problems (4.13) and (4.14) are clearly equivalent, they are not the same.
The problem (4.13) is unconstrained, but its objective function is not differentiable.
The problem (4.14), however, has an equality constraint, but its objective and
constraint functions are differentiable.



136 4 Convex optimization problems

4.1.4 Parameter and oracle problem descriptions

For a problem in the standard form (4.1), there is still the question of how the
objective and constraint functions are specified. In many cases these functions
have some analytical or closed form, i.e., are given by a formula or expression that
involves the variable x as well as some parameters. Suppose, for example, the
objective is quadratic, so it has the form f0(x) = (1/2)x

TPx+ qTx+ r. To specify
the objective function we give the coefficients (also called problem parameters or
problem data) P ∈ Sn, q ∈ Rn, and r ∈ R. We call this a parameter problem
description, since the specific problem to be solved (i.e., the problem instance) is
specified by giving the values of the parameters that appear in the expressions for
the objective and constraint functions.

In other cases the objective and constraint functions are described by oracle
models (which are also called black box or subroutine models). In an oracle model,
we do not know f explicitly, but can evaluate f(x) (and usually also some deriva-
tives) at any x ∈ dom f . This is referred to as querying the oracle, and is usually
associated with some cost, such as time. We are also given some prior information
about the function, such as convexity and a bound on its values. As a concrete
example of an oracle model, consider an unconstrained problem, in which we are
to minimize the function f . The function value f(x) and its gradient ∇f(x) are
evaluated in a subroutine. We can call the subroutine at any x ∈ dom f , but do
not have access to its source code. Calling the subroutine with argument x yields
(when the subroutine returns) f(x) and ∇f(x). Note that in the oracle model,
we never really know the function; we only know the function value (and some
derivatives) at the points where we have queried the oracle. (We also know some
given prior information about the function, such as differentiability and convexity.)

In practice the distinction between a parameter and oracle problem description
is not so sharp. If we are given a parameter problem description, we can construct
an oracle for it, which simply evaluates the required functions and derivatives when
queried. Most of the algorithms we study in part III work with an oracle model, but
can be made more efficient when they are restricted to solve a specific parametrized
family of problems.

4.2 Convex optimization

4.2.1 Convex optimization problems in standard form

A convex optimization problem is one of the form

minimize f0(x)
subject to fi(x) ≤ 0, i = 1, . . . ,m

aTi x = bi, i = 1, . . . , p,
(4.15)

where f0, . . . , fm are convex functions. Comparing (4.15) with the general standard
form problem (4.1), the convex problem has three additional requirements:



4.2 Convex optimization 137

• the objective function must be convex,
• the inequality constraint functions must be convex,
• the equality constraint functions hi(x) = aTi x− bi must be affine.

We immediately note an important property: The feasible set of a convex optimiza-
tion problem is convex, since it is the intersection of the domain of the problem

D =
m⋂
i=0

dom fi,

which is a convex set, with m (convex) sublevel sets {x | fi(x) ≤ 0} and p hyper-
planes {x | aTi x = bi}. (We can assume without loss of generality that ai 6= 0: if
ai = 0 and bi = 0 for some i, then the ith equality constraint can be deleted; if
ai = 0 and bi 6= 0, the ith equality constraint is inconsistent, and the problem is in-
feasible.) Thus, in a convex optimization problem, we minimize a convex objective
function over a convex set.

If f0 is quasiconvex instead of convex, we say the problem (4.15) is a (standard
form) quasiconvex optimization problem. Since the sublevel sets of a convex or
quasiconvex function are convex, we conclude that for a convex or quasiconvex
optimization problem the ǫ-suboptimal sets are convex. In particular, the optimal
set is convex. If the objective is strictly convex, then the optimal set contains at
most one point.

Concave maximization problems

With a slight abuse of notation, we will also refer to

maximize f0(x)
subject to fi(x) ≤ 0, i = 1, . . . ,m

aTi x = bi, i = 1, . . . , p,
(4.16)

as a convex optimization problem if the objective function f0 is concave, and the
inequality constraint functions f1, . . . , fm are convex. This concave maximization
problem is readily solved by minimizing the convex objective function −f0. All
of the results, conclusions, and algorithms that we describe for the minimization
problem are easily transposed to the maximization case. In a similar way the
maximization problem (4.16) is called quasiconvex if f0 is quasiconcave.

Abstract form convex optimization problem

It is important to note a subtlety in our definition of convex optimization problem.
Consider the example with x ∈ R2,

minimize f0(x) = x
2
1 + x

2
2

subject to f1(x) = x1/(1 + x
2
2) ≤ 0

h1(x) = (x1 + x2)
2 = 0,

(4.17)

which is in the standard form (4.1). This problem is not a convex optimization
problem in standard form since the equality constraint function h1 is not affine, and



138 4 Convex optimization problems

the inequality constraint function f1 is not convex. Nevertheless the feasible set,
which is {x | x1 ≤ 0, x1 + x2 = 0}, is convex. So although in this problem we are
minimizing a convex function f0 over a convex set, it is not a convex optimization
problem by our definition.

Of course, the problem is readily reformulated as

minimize f0(x) = x
2
1 + x

2
2

subject to f˜1(x) = x1 ≤ 0
h˜1(x) = x1 + x2 = 0,

(4.18)

which is in standard convex optimization form, since f0 and f˜1 are convex, and h˜1
is affine.

Some authors use the term abstract convex optimization problem to describe the
(abstract) problem of minimizing a convex function over a convex set. Using this
terminology, the problem (4.17) is an abstract convex optimization problem. We
will not use this terminology in this book. For us, a convex optimization problem is
not just one of minimizing a convex function over a convex set; it is also required
that the feasible set be described specifically by a set of inequalities involving
convex functions, and a set of linear equality constraints. The problem (4.17) is
not a convex optimization problem, but the problem (4.18) is a convex optimization
problem. (The two problems are, however, equivalent.)

Our adoption of the stricter definition of convex optimization problem does not
matter much in practice. To solve the abstract problem of minimizing a convex
function over a convex set, we need to find a description of the set in terms of
convex inequalities and linear equality constraints. As the example above suggests,
this is usually straightforward.

4.2.2 Local and global optima

A fundamental property of convex optimization problems is that any locally optimal
point is also (globally) optimal. To see this, suppose that x is locally optimal for
a convex optimization problem, i.e., x is feasible and

f0(x) = inf{f0(z) | z feasible, ‖z − x‖2 ≤ R}, (4.19)
for some R > 0. Now suppose that x is not globally optimal, i.e., there is a feasible
y such that f0(y) < f0(x). Evidently ‖y − x‖2 > R, since otherwise f0(x) ≤ f0(y).
Consider the point z given by

z = (1− θ)x+ θy, θ = R
2‖y − x‖2 .

Then we have ‖z − x‖2 = R/2 < R, and by convexity of the feasible set, z is
feasible. By convexity of f0 we have

f0(z) ≤ (1− θ)f0(x) + θf0(y) < f0(x),
which contradicts (4.19). Hence there exists no feasible y with f0(y) < f0(x), i.e.,
x is globally optimal.



4.2 Convex optimization 139

−∇f0(x)
X

x

Figure 4.2 Geometric interpretation of the optimality condition (4.21). The
feasible set X is shown shaded. Some level curves of f0 are shown as dashed
lines. The point x is optimal: −∇f0(x) defines a supporting hyperplane
(shown as a solid line) to X at x.

It is not true that locally optimal points of quasiconvex optimization problems
are globally optimal; see §4.2.5.

4.2.3 An optimality criterion for differentiable f0

Suppose that the objective f0 in a convex optimization problem is differentiable,
so that for all x, y ∈ dom f0,

f0(y) ≥ f0(x) +∇f0(x)T (y − x) (4.20)

(see §3.1.3). Let X denote the feasible set, i.e.,

X = {x | fi(x) ≤ 0, i = 1, . . . ,m, hi(x) = 0, i = 1, . . . , p}.

Then x is optimal if and only if x ∈ X and

∇f0(x)T (y − x) ≥ 0 for all y ∈ X. (4.21)

This optimality criterion can be understood geometrically: If ∇f0(x) 6= 0, it means
that −∇f0(x) defines a supporting hyperplane to the feasible set at x (see fig-
ure 4.2).

Proof of optimality condition

First suppose x ∈ X and satisfies (4.21). Then if y ∈ X we have, by (4.20),
f0(y) ≥ f0(x). This shows x is an optimal point for (4.1).

Conversely, suppose x is optimal, but the condition (4.21) does not hold, i.e.,
for some y ∈ X we have

∇f0(x)T (y − x) < 0.



140 4 Convex optimization problems

Consider the point z(t) = ty+(1− t)x, where t ∈ [0, 1] is a parameter. Since z(t) is
on the line segment between x and y, and the feasible set is convex, z(t) is feasible.
We claim that for small positive t we have f0(z(t)) < f0(x), which will prove that
x is not optimal. To show this, note that

d

dt
f0(z(t))

∣∣∣∣
t=0

= ∇f0(x)T (y − x) < 0,

so for small positive t, we have f0(z(t)) < f0(x).
We will pursue the topic of optimality conditions in much more depth in chap-

ter 5, but here we examine a few simple examples.

Unconstrained problems

For an unconstrained problem (i.e., m = p = 0), the condition (4.21) reduces to
the well known necessary and sufficient condition

∇f0(x) = 0 (4.22)
for x to be optimal. While we have already seen this optimality condition, it is
useful to see how it follows from (4.21). Suppose x is optimal, which means here
that x ∈ dom f0, and for all feasible y we have ∇f0(x)T (y − x) ≥ 0. Since f0 is
differentiable, its domain is (by definition) open, so all y sufficiently close to x are
feasible. Let us take y = x− t∇f0(x), where t ∈ R is a parameter. For t small and
positive, y is feasible, and so

∇f0(x)T (y − x) = −t‖∇f0(x)‖22 ≥ 0,
from which we conclude ∇f0(x) = 0.

There are several possible situations, depending on the number of solutions
of (4.22). If there are no solutions of (4.22), then there are no optimal points; the
optimal value of the problem is not attained. Here we can distinguish between
two cases: the problem is unbounded below, or the optimal value is finite, but not
attained. On the other hand we can have multiple solutions of the equation (4.22),
in which case each such solution is a minimizer of f0.

Example 4.5 Unconstrained quadratic optimization. Consider the problem of mini-
mizing the quadratic function

f0(x) = (1/2)x
TPx+ qTx+ r,

where P ∈ Sn+ (which makes f0 convex). The necessary and sufficient condition for
x to be a minimizer of f0 is

∇f0(x) = Px+ q = 0.
Several cases can occur, depending on whether this (linear) equation has no solutions,
one solution, or many solutions.

• If q 6∈ R(P ), then there is no solution. In this case f0 is unbounded below.
• If P ≻ 0 (which is the condition for f0 to be strictly convex), then there is a
unique minimizer, x⋆ = −P−1q.



4.2 Convex optimization 141

• If P is singular, but q ∈ R(P ), then the set of optimal points is the (affine) set
Xopt = −P †q +N (P ), where P † denotes the pseudo-inverse of P (see §A.5.4).

Example 4.6 Analytic centering. Consider the (unconstrained) problem of minimiz-
ing the (convex) function f0 : R

n → R, defined as

f0(x) = −
m∑
i=1

log(bi − aTi x), dom f0 = {x | Ax ≺ b},

where aT1 , . . . , a
T
m are the rows of A. The function f0 is differentiable, so the necessary

and sufficient conditions for x to be optimal are

Ax ≺ b, ∇f0(x) =
m∑
i=1

1

bi − aTi x
ai = 0. (4.23)

(The condition Ax ≺ b is just x ∈ dom f0.) If Ax ≺ b is infeasible, then the domain
of f0 is empty. Assuming Ax ≺ b is feasible, there are still several possible cases (see
exercise 4.2):

• There are no solutions of (4.23), and hence no optimal points for the problem.
This occurs if and only if f0 is unbounded below.

• There are many solutions of (4.23). In this case it can be shown that the
solutions form an affine set.

• There is a unique solution of (4.23), i.e., a unique minimizer of f0. This occurs
if and only if the open polyhedron {x | Ax ≺ b} is nonempty and bounded.

Problems with equality constraints only

Consider the case where there are equality constraints but no inequality constraints,
i.e.,

minimize f0(x)
subject to Ax = b.

Here the feasible set is affine. We assume that it is nonempty; otherwise the
problem is infeasible. The optimality condition for a feasible x is that

∇f0(x)T (y − x) ≥ 0

must hold for all y satisfying Ay = b. Since x is feasible, every feasible y has the
form y = x + v for some v ∈ N (A). The optimality condition can therefore be
expressed as:

∇f0(x)T v ≥ 0 for all v ∈ N (A).
If a linear function is nonnegative on a subspace, then it must be zero on the
subspace, so it follows that ∇f0(x)T v = 0 for all v ∈ N (A). In other words,

∇f0(x) ⊥ N (A).



142 4 Convex optimization problems

Using the fact that N (A)⊥ = R(AT ), this optimality condition can be expressed
as ∇f0(x) ∈ R(AT ), i.e., there exists a ν ∈ Rp such that

∇f0(x) +AT ν = 0.

Together with the requirement Ax = b (i.e., that x is feasible), this is the classical
Lagrange multiplier optimality condition, which we will study in greater detail in
chapter 5.

Minimization over the nonnegative orthant

As another example we consider the problem

minimize f0(x)
subject to x � 0,

where the only inequality constraints are nonnegativity constraints on the variables.
The optimality condition (4.21) is then

x � 0, ∇f0(x)T (y − x) ≥ 0 for all y � 0.

The term ∇f0(x)T y, which is a linear function of y, is unbounded below on y � 0,
unless we have ∇f0(x) � 0. The condition then reduces to −∇f0(x)Tx ≥ 0. But
x � 0 and ∇f0(x) � 0, so we must have ∇f0(x)Tx = 0, i.e.,

n∑
i=1

(∇f0(x))ixi = 0.

Now each of the terms in this sum is the product of two nonnegative numbers, so
we conclude that each term must be zero, i.e., (∇f0(x))i xi = 0 for i = 1, . . . , n.

The optimality condition can therefore be expressed as

x � 0, ∇f0(x) � 0, xi (∇f0(x))i = 0, i = 1, . . . , n.

The last condition is called complementarity, since it means that the sparsity pat-
terns (i.e., the set of indices corresponding to nonzero components) of the vectors x
and ∇f0(x) are complementary (i.e., have empty intersection). We will encounter
complementarity conditions again in chapter 5.

4.2.4 Equivalent convex problems

It is useful to see which of the transformations described in §4.1.3 preserve convex-
ity.

Eliminating equality constraints

For a convex problem the equality constraints must be linear, i.e., of the form
Ax = b. In this case they can be eliminated by finding a particular solution x0 of



4.2 Convex optimization 143

Ax = b, and a matrix F whose range is the nullspace of A, which results in the
problem

minimize f0(Fz + x0)
subject to fi(Fz + x0) ≤ 0, i = 1, . . . ,m,

with variable z. Since the composition of a convex function with an affine func-
tion is convex, eliminating equality constraints preserves convexity of a problem.
Moreover, the process of eliminating equality constraints (and reconstructing the
solution of the original problem from the solution of the transformed problem)
involves standard linear algebra operations.

At least in principle, this means we can restrict our attention to convex opti-
mization problems which have no equality constraints. In many cases, however, it
is better to retain the equality constraints, since eliminating them can make the
problem harder to understand and analyze, or ruin the efficiency of an algorithm
that solves it. This is true, for example, when the variable x has very large dimen-
sion, and eliminating the equality constraints would destroy sparsity or some other
useful structure of the problem.

Introducing equality constraints

We can introduce new variables and equality constraints into a convex optimization
problem, provided the equality constraints are linear, and the resulting problem
will also be convex. For example, if an objective or constraint function has the form
fi(Aix+ bi), where Ai ∈ Rki×n, we can introduce a new variable yi ∈ Rki , replace
fi(Aix+ bi) with fi(yi), and add the linear equality constraint yi = Aix+ bi.

Slack variables

By introducing slack variables we have the new constraints fi(x) + si = 0. Since
equality constraint functions must be affine in a convex problem, we must have fi
affine. In other words: introducing slack variables for linear inequalities preserves
convexity of a problem.

Epigraph problem form

The epigraph form of the convex optimization problem (4.15) is

minimize t
subject to f0(x)− t ≤ 0

fi(x) ≤ 0, i = 1, . . . ,m
aTi x = bi, i = 1, . . . , p.

The objective is linear (hence convex) and the new constraint function f0(x)− t is
also convex in (x, t), so the epigraph form problem is convex as well.

It is sometimes said that a linear objective is universal for convex optimization,
since any convex optimization problem is readily transformed to one with linear
objective. The epigraph form of a convex problem has several practical uses. By
assuming the objective of a convex optimization problem is linear, we can simplify
theoretical analysis. It can also simplify algorithm development, since an algo-
rithm that solves convex optimization problems with linear objective can, using



144 4 Convex optimization problems

the transformation above, solve any convex optimization problem (provided it can
handle the constraint f0(x)− t ≤ 0).

Minimizing over some variables

Minimizing a convex function over some variables preserves convexity. Therefore,
if f0 in (4.9) is jointly convex in x1 and x2, and fi, i = 1, . . . ,m1, and f˜i, i =
1, . . . ,m2, are convex, then the equivalent problem (4.10) is convex.

4.2.5 Quasiconvex optimization

Recall that a quasiconvex optimization problem has the standard form

minimize f0(x)
subject to fi(x) ≤ 0, i = 1, . . . ,m

Ax = b,
(4.24)

where the inequality constraint functions f1, . . . , fm are convex, and the objective
f0 is quasiconvex (instead of convex, as in a convex optimization problem). (Qua-
siconvex constraint functions can be replaced with equivalent convex constraint
functions, i.e., constraint functions that are convex and have the same 0-sublevel
set, as in §3.4.5.)

In this section we point out some basic differences between convex and quasicon-
vex optimization problems, and also show how solving a quasiconvex optimization
problem can be reduced to solving a sequence of convex optimization problems.

Locally optimal solutions and optimality conditions

The most important difference between convex and quasiconvex optimization is
that a quasiconvex optimization problem can have locally optimal solutions that
are not (globally) optimal. This phenomenon can be seen even in the simple case
of unconstrained minimization of a quasiconvex function on R, such as the one
shown in figure 4.3.

Nevertheless, a variation of the optimality condition (4.21) given in §4.2.3 does
hold for quasiconvex optimization problems with differentiable objective function.
Let X denote the feasible set for the quasiconvex optimization problem (4.24). It
follows from the first-order condition for quasiconvexity (3.20) that x is optimal if

x ∈ X, ∇f0(x)T (y − x) > 0 for all y ∈ X \ {x}. (4.25)
There are two important differences between this criterion and the analogous
one (4.21) for convex optimization:

• The condition (4.25) is only sufficient for optimality; simple examples show
that it need not hold for an optimal point. In contrast, the condition (4.21)
is necessary and sufficient for x to solve the convex problem.

• The condition (4.25) requires the gradient of f0 to be nonzero, whereas the
condition (4.21) does not. Indeed, when ∇f0(x) = 0 in the convex case, the
condition (4.21) is satisfied, and x is optimal.



4.2 Convex optimization 145

(x, f(x))

Figure 4.3 A quasiconvex function f on R, with a locally optimal point x
that is not globally optimal. This example shows that the simple optimality
condition f ′(x) = 0, valid for convex functions, does not hold for quasiconvex
functions.

Quasiconvex optimization via convex feasibility problems

One general approach to quasiconvex optimization relies on the representation of
the sublevel sets of a quasiconvex function via a family of convex inequalities, as
described in §3.4.5. Let φt : Rn → R, t ∈ R, be a family of convex functions that
satisfy

f0(x) ≤ t ⇐⇒ φt(x) ≤ 0,
and also, for each x, φt(x) is a nonincreasing function of t, i.e., φs(x) ≤ φt(x)
whenever s ≥ t.

Let p⋆ denote the optimal value of the quasiconvex optimization problem (4.24).
If the feasibility problem

find x
subject to φt(x) ≤ 0

fi(x) ≤ 0, i = 1, . . . ,m
Ax = b,

(4.26)

is feasible, then we have p⋆ ≤ t. Conversely, if the problem (4.26) is infeasible, then
we can conclude p⋆ ≥ t. The problem (4.26) is a convex feasibility problem, since
the inequality constraint functions are all convex, and the equality constraints
are linear. Thus, we can check whether the optimal value p⋆ of a quasiconvex
optimization problem is less than or more than a given value t by solving the
convex feasibility problem (4.26). If the convex feasibility problem is feasible then
we have p⋆ ≤ t, and any feasible point x is feasible for the quasiconvex problem
and satisfies f0(x) ≤ t. If the convex feasibility problem is infeasible, then we know
that p⋆ ≥ t.

This observation can be used as the basis of a simple algorithm for solving the
quasiconvex optimization problem (4.24) using bisection, solving a convex feasi-
bility problem at each step. We assume that the problem is feasible, and start
with an interval [l, u] known to contain the optimal value p⋆. We then solve the
convex feasibility problem at its midpoint t = (l + u)/2, to determine whether the



146 4 Convex optimization problems

optimal value is in the lower or upper half of the interval, and update the interval
accordingly. This produces a new interval, which also contains the optimal value,
but has half the width of the initial interval. This is repeated until the width of
the interval is small enough:

Algorithm 4.1 Bisection method for quasiconvex optimization.

given l ≤ p⋆, u ≥ p⋆, tolerance ǫ > 0.
repeat

1. t := (l + u)/2.
2. Solve the convex feasibility problem (4.26).
3. if (4.26) is feasible, u := t; else l := t.

until u− l ≤ ǫ.

The interval [l, u] is guaranteed to contain p⋆, i.e., we have l ≤ p⋆ ≤ u at
each step. In each iteration the interval is divided in two, i.e., bisected, so the
length of the interval after k iterations is 2−k(u − l), where u − l is the length of
the initial interval. It follows that exactly ⌈log2((u− l)/ǫ)⌉ iterations are required
before the algorithm terminates. Each step involves solving the convex feasibility
problem (4.26).

4.3 Linear optimization problems

When the objective and constraint functions are all affine, the problem is called a
linear program (LP). A general linear program has the form

minimize cTx+ d
subject to Gx � h

Ax = b,
(4.27)

where G ∈ Rm×n and A ∈ Rp×n. Linear programs are, of course, convex opti-
mization problems.

It is common to omit the constant d in the objective function, since it does not
affect the optimal (or feasible) set. Since we can maximize an affine objective cTx+
d, by minimizing −cTx− d (which is still convex), we also refer to a maximization
problem with affine objective and constraint functions as an LP.

The geometric interpretation of an LP is illustrated in figure 4.4. The feasible
set of the LP (4.27) is a polyhedron P; the problem is to minimize the affine
function cTx+ d (or, equivalently, the linear function cTx) over P.

Standard and inequality form linear programs

Two special cases of the LP (4.27) are so widely encountered that they have been
given separate names. In a standard form LP the only inequalities are componen-



4.3 Linear optimization problems 147

P x
⋆

−c

Figure 4.4 Geometric interpretation of an LP. The feasible set P, which
is a polyhedron, is shaded. The objective cTx is linear, so its level curves
are hyperplanes orthogonal to c (shown as dashed lines). The point x⋆ is
optimal; it is the point in P as far as possible in the direction −c.

twise nonnegativity constraints x � 0:

minimize cTx
subject to Ax = b

x � 0.
(4.28)

If the LP has no equality constraints, it is called an inequality form LP, usually
written as

minimize cTx
subject to Ax � b. (4.29)

Converting LPs to standard form

It is sometimes useful to transform a general LP (4.27) to one in standard form (4.28)
(for example in order to use an algorithm for standard form LPs). The first step
is to introduce slack variables si for the inequalities, which results in

minimize cTx+ d
subject to Gx+ s = h

Ax = b
s � 0.

The second step is to express the variable x as the difference of two nonnegative
variables x+ and x−, i.e., x = x+ − x−, x+, x− � 0. This yields the problem

minimize cTx+ − cTx− + d
subject to Gx+ −Gx− + s = h

Ax+ −Ax− = b
x+ � 0, x− � 0, s � 0,



148 4 Convex optimization problems

which is an LP in standard form, with variables x+, x−, and s. (For equivalence
of this problem and the original one (4.27), see exercise 4.10.)

These techniques for manipulating problems (along with many others we will
see in the examples and exercises) can be used to formulate many problems as linear
programs. With some abuse of terminology, it is common to refer to a problem
that can be formulated as an LP as an LP, even if it does not have the form (4.27).

4.3.1 Examples

LPs arise in a vast number of fields and applications; here we give a few typical
examples.

Diet problem

A healthy diet contains m different nutrients in quantities at least equal to b1, . . . ,
bm. We can compose such a diet by choosing nonnegative quantities x1, . . . , xn of
n different foods. One unit quantity of food j contains an amount aij of nutrient
i, and has a cost of cj . We want to determine the cheapest diet that satisfies the
nutritional requirements. This problem can be formulated as the LP

minimize cTx
subject to Ax � b

x � 0.
Several variations on this problem can also be formulated as LPs. For example,
we can insist on an exact amount of a nutrient in the diet (which gives a linear
equality constraint), or we can impose an upper bound on the amount of a nutrient,
in addition to the lower bound as above.

Chebyshev center of a polyhedron

We consider the problem of finding the largest Euclidean ball that lies in a poly-
hedron described by linear inequalities,

P = {x ∈ Rn | aTi x ≤ bi, i = 1, . . . ,m}.
(The center of the optimal ball is called the Chebyshev center of the polyhedron;
it is the point deepest inside the polyhedron, i.e., farthest from the boundary;
see §8.5.1.) We represent the ball as

B = {xc + u | ‖u‖2 ≤ r}.
The variables in the problem are the center xc ∈ Rn and the radius r; we wish to
maximize r subject to the constraint B ⊆ P.

We start by considering the simpler constraint that B lies in one halfspace
aTi x ≤ bi, i.e.,

‖u‖2 ≤ r =⇒ aTi (xc + u) ≤ bi. (4.30)
Since

sup{aTi u | ‖u‖2 ≤ r} = r‖ai‖2



4.3 Linear optimization problems 149

we can write (4.30) as
aTi xc + r‖ai‖2 ≤ bi, (4.31)

which is a linear inequality in xc and r. In other words, the constraint that the
ball lies in the halfspace determined by the inequality aTi x ≤ bi can be written as
a linear inequality.

Therefore B ⊆ P if and only if (4.31) holds for all i = 1, . . . ,m. Hence the
Chebyshev center can be determined by solving the LP

maximize r
subject to aTi xc + r‖ai‖2 ≤ bi, i = 1, . . . ,m,

with variables r and xc. (For more on the Chebyshev center, see §8.5.1.)

Dynamic activity planning

We consider the problem of choosing, or planning, the activity levels of n activities,
or sectors of an economy, over N time periods. We let xj(t) ≥ 0, t = 1, . . . , N ,
denote the activity level of sector j, in period t. The activities both consume and
produce products or goods in proportion to their activity levels. The amount of
good i produced per unit of activity j is given by aij . Similarly, the amount of good i
consumed per unit of activity j is bij . The total amount of goods produced in period
t is given by Ax(t) ∈ Rm, and the amount of goods consumed is Bx(t) ∈ Rm.
(Although we refer to these products as ‘goods’, they can also include unwanted
products such as pollutants.)

The goods consumed in a period cannot exceed those produced in the previous
period: we must have Bx(t + 1) � Ax(t) for t = 1, . . . , N . A vector g0 ∈ Rm of
initial goods is given, which constrains the first period activity levels: Bx(1) � g0.
The (vectors of) excess goods not consumed by the activities are given by

s(0) = g0 −Bx(1)
s(t) = Ax(t)−Bx(t+ 1), t = 1, . . . , N − 1
s(N) = Ax(N).

The objective is to maximize a discounted total value of excess goods:

cT s(0) + γcT s(1) + · · ·+ γNcT s(N),
where c ∈ Rm gives the values of the goods, and γ > 0 is a discount factor. (The
value ci is negative if the ith product is unwanted, e.g., a pollutant; |ci| is then the
cost of disposal per unit.)

Putting it all together we arrive at the LP

maximize cT s(0) + γcT s(1) + · · ·+ γNcT s(N)
subject to x(t) � 0, t = 1, . . . , N

s(t) � 0, t = 0, . . . , N
s(0) = g0 −Bx(1)
s(t) = Ax(t)−Bx(t+ 1), t = 1, . . . , N − 1
s(N) = Ax(N),

with variables x(1), . . . , x(N), s(0), . . . , s(N). This problem is a standard form LP;
the variables s(t) are the slack variables associated with the constraints Bx(t+1) �
Ax(t).



150 4 Convex optimization problems

Chebyshev inequalities

We consider a probability distribution for a discrete random variable x on a set
{u1, . . . , un} ⊆ R with n elements. We describe the distribution of x by a vector
p ∈ Rn, where

pi = prob(x = ui),

so p satisfies p � 0 and 1T p = 1. Conversely, if p satisfies p � 0 and 1T p = 1, then
it defines a probability distribution for x. We assume that ui are known and fixed,
but the distribution p is not known.

If f is any function of x, then

E f =

n∑
i=1

pif(ui)

is a linear function of p. If S is any subset of R, then

prob(x ∈ S) =
∑
ui∈S

pi

is a linear function of p.
Although we do not know p, we are given prior knowledge of the following form:

We know upper and lower bounds on expected values of some functions of x, and
probabilities of some subsets of R. This prior knowledge can be expressed as linear
inequality constraints on p,

αi ≤ aTi p ≤ βi, i = 1, . . . ,m.
The problem is to give lower and upper bounds on E f0(x) = a

T
0 p, where f0 is some

function of x.
To find a lower bound we solve the LP

minimize aT0 p
subject to p � 0, 1T p = 1

αi ≤ aTi p ≤ βi, i = 1, . . . ,m,
with variable p. The optimal value of this LP gives the lowest possible value of
E f0(X) for any distribution that is consistent with the prior information. More-
over, the bound is sharp: the optimal solution gives a distribution that is consistent
with the prior information and achieves the lower bound. In a similar way, we can
find the best upper bound by maximizing aT0 p subject to the same constraints. (We
will consider Chebyshev inequalities in more detail in §7.4.1.)

Piecewise-linear minimization

Consider the (unconstrained) problem of minimizing the piecewise-linear, convex
function

f(x) = max
i=1,...,m

(aTi x+ bi).

This problem can be transformed to an equivalent LP by first forming the epigraph
problem,

minimize t
subject to maxi=1,...,m(a

T
i x+ bi) ≤ t,



4.3 Linear optimization problems 151

and then expressing the inequality as a set of m separate inequalities:

minimize t
subject to aTi x+ bi ≤ t, i = 1, . . . ,m.

This is an LP (in inequality form), with variables x and t.

4.3.2 Linear-fractional programming

The problem of minimizing a ratio of affine functions over a polyhedron is called a
linear-fractional program:

minimize f0(x)
subject to Gx � h

Ax = b
(4.32)

where the objective function is given by

f0(x) =
cTx+ d

eTx+ f
, dom f0 = {x | eTx+ f > 0}.

The objective function is quasiconvex (in fact, quasilinear) so linear-fractional pro-
grams are quasiconvex optimization problems.

Transforming to a linear program

If the feasible set
{x | Gx � h, Ax = b, eTx+ f > 0}

is nonempty, the linear-fractional program (4.32) can be transformed to an equiv-
alent linear program

minimize cT y + dz
subject to Gy − hz � 0

Ay − bz = 0
eT y + fz = 1
z ≥ 0

(4.33)

with variables y, z.
To show the equivalence, we first note that if x is feasible in (4.32) then the

pair

y =
x

eTx+ f
, z =

1

eTx+ f

is feasible in (4.33), with the same objective value cT y+dz = f0(x). It follows that
the optimal value of (4.32) is greater than or equal to the optimal value of (4.33).

Conversely, if (y, z) is feasible in (4.33), with z 6= 0, then x = y/z is feasible
in (4.32), with the same objective value f0(x) = c

T y + dz. If (y, z) is feasible
in (4.33) with z = 0, and x0 is feasible for (4.32), then x = x0 + ty is feasible
in (4.32) for all t ≥ 0. Moreover, limt→∞ f0(x0 + ty) = cT y + dz, so we can find
feasible points in (4.32) with objective values arbitrarily close to the objective value
of (y, z). We conclude that the optimal value of (4.32) is less than or equal to the
optimal value of (4.33).



152 4 Convex optimization problems

Generalized linear-fractional programming

A generalization of the linear-fractional program (4.32) is the generalized linear-
fractional program in which

f0(x) = max
i=1,...,r

cTi x+ di
eTi x+ fi

, dom f0 = {x | eTi x+ fi > 0, i = 1, . . . , r}.

The objective function is the pointwise maximum of r quasiconvex functions, and
therefore quasiconvex, so this problem is quasiconvex. When r = 1 it reduces to
the standard linear-fractional program.

Example 4.7 Von Neumann growth problem. We consider an economy with n
sectors, and activity levels xi > 0 in the current period, and activity levels x

+
i > 0 in

the next period. (In this problem we only consider one period.) There are m goods
which are consumed, and also produced, by the activity: An activity level x consumes
goods Bx ∈ Rm, and produces goods Ax. The goods consumed in the next period
cannot exceed the goods produced in the current period, i.e., Bx+ � Ax. The growth
rate in sector i, over the period, is given by x+i /xi.

Von Neumann’s growth problem is to find an activity level vector x that maximizes
the minimum growth rate across all sectors of the economy. This problem can be
expressed as a generalized linear-fractional problem

maximize mini=1,...,n x
+
i /xi

subject to x+ � 0
Bx+ � Ax

with domain {(x, x+) | x ≻ 0}. Note that this problem is homogeneous in x and x+,
so we can replace the implicit constraint x ≻ 0 by the explicit constraint x � 1.

4.4 Quadratic optimization problems

The convex optimization problem (4.15) is called a quadratic program (QP) if the
objective function is (convex) quadratic, and the constraint functions are affine. A
quadratic program can be expressed in the form

minimize (1/2)xTPx+ qTx+ r
subject to Gx � h

Ax = b,
(4.34)

where P ∈ Sn+, G ∈ Rm×n, and A ∈ Rp×n. In a quadratic program, we minimize
a convex quadratic function over a polyhedron, as illustrated in figure 4.5.

If the objective in (4.15) as well as the inequality constraint functions are (con-
vex) quadratic, as in

minimize (1/2)xTP0x+ q
T
0 x+ r0

subject to (1/2)xTPix+ q
T
i x+ ri ≤ 0, i = 1, . . . ,m

Ax = b,
(4.35)



4.4 Quadratic optimization problems 153

P

x⋆

−∇f0(x⋆)

Figure 4.5 Geometric illustration of QP. The feasible set P, which is a poly-
hedron, is shown shaded. The contour lines of the objective function, which
is convex quadratic, are shown as dashed curves. The point x⋆ is optimal.

where Pi ∈ Sn+, i = 0, 1 . . . ,m, the problem is called a quadratically constrained
quadratic program (QCQP). In a QCQP, we minimize a convex quadratic function
over a feasible region that is the intersection of ellipsoids (when Pi ≻ 0).

Quadratic programs include linear programs as a special case, by taking P = 0
in (4.34). Quadratically constrained quadratic programs include quadratic pro-
grams (and therefore also linear programs) as a special case, by taking Pi = 0
in (4.35), for i = 1, . . . ,m.

4.4.1 Examples

Least-squares and regression

The problem of minimizing the convex quadratic function

‖Ax− b‖22 = xTATAx− 2bTAx+ bT b

is an (unconstrained) QP. It arises in many fields and has many names, e.g., re-
gression analysis or least-squares approximation. This problem is simple enough to
have the well known analytical solution x = A†b, where A† is the pseudo-inverse
of A (see §A.5.4).

When linear inequality constraints are added, the problem is called constrained
regression or constrained least-squares, and there is no longer a simple analytical
solution. As an example we can consider regression with lower and upper bounds
on the variables, i.e.,

minimize ‖Ax− b‖22
subject to li ≤ xi ≤ ui, i = 1, . . . , n,



154 4 Convex optimization problems

which is a QP. (We will study least-squares and regression problems in far more
depth in chapters 6 and 7.)

Distance between polyhedra

The (Euclidean) distance between the polyhedra P1 = {x | A1x � b1} and P2 =
{x | A2x � b2} in Rn is defined as

dist(P1,P2) = inf{‖x1 − x2‖2 | x1 ∈ P1, x2 ∈ P2}.

If the polyhedra intersect, the distance is zero.
To find the distance between P1 and P2, we can solve the QP

minimize ‖x1 − x2‖22
subject to A1x1 � b1, A2x2 � b2,

with variables x1, x2 ∈ Rn. This problem is infeasible if and only if one of the
polyhedra is empty. The optimal value is zero if and only if the polyhedra intersect,
in which case the optimal x1 and x2 are equal (and is a point in the intersection
P1∩P2). Otherwise the optimal x1 and x2 are the points in P1 and P2, respectively,
that are closest to each other. (We will study geometric problems involving distance
in more detail in chapter 8.)

Bounding variance

We consider again the Chebyshev inequalities example (page 150), where the vari-
able is an unknown probability distribution given by p ∈ Rn, about which we have
some prior information. The variance of a random variable f(x) is given by

E f2 − (E f)2 =
n∑
i=1

f2i pi −
(

n∑
i=1

fipi

)2
,

(where fi = f(ui)), which is a concave quadratic function of p.
It follows that we can maximize the variance of f(x), subject to the given prior

information, by solving the QP

maximize
∑n

i=1 f
2
i pi − (

∑n
i=1 fipi)

2

subject to p � 0, 1T p = 1
αi ≤ aTi p ≤ βi, i = 1, . . . ,m.

The optimal value gives the maximum possible variance of f(x), over all distribu-
tions that are consistent with the prior information; the optimal p gives a distri-
bution that achieves this maximum variance.

Linear program with random cost

We consider an LP,
minimize cTx
subject to Gx � h

Ax = b,



4.4 Quadratic optimization problems 155

with variable x ∈ Rn. We suppose that the cost function (vector) c ∈ Rn is
random, with mean value c and covariance E(c − c)(c − c)T = Σ. (We assume
for simplicity that the other problem parameters are deterministic.) For a given
x ∈ Rn, the cost cTx is a (scalar) random variable with mean E cTx = cTx and
variance

var(cTx) = E(cTx−E cTx)2 = xTΣx.
In general there is a trade-off between small expected cost and small cost vari-

ance. One way to take variance into account is to minimize a linear combination
of the expected value and the variance of the cost, i.e.,

E cTx+ γ var(cTx),

which is called the risk-sensitive cost. The parameter γ ≥ 0 is called the risk-
aversion parameter, since it sets the relative values of cost variance and expected
value. (For γ > 0, we are willing to trade off an increase in expected cost for a
sufficiently large decrease in cost variance).

To minimize the risk-sensitive cost we solve the QP

minimize cTx+ γxTΣx
subject to Gx � h

Ax = b.

Markowitz portfolio optimization

We consider a classical portfolio problem with n assets or stocks held over a period
of time. We let xi denote the amount of asset i held throughout the period, with
xi in dollars, at the price at the beginning of the period. A normal long position
in asset i corresponds to xi > 0; a short position in asset i (i.e., the obligation to
buy the asset at the end of the period) corresponds to xi < 0. We let pi denote
the relative price change of asset i over the period, i.e., its change in price over
the period divided by its price at the beginning of the period. The overall return
on the portfolio is r = pTx (given in dollars). The optimization variable is the
portfolio vector x ∈ Rn.

A wide variety of constraints on the portfolio can be considered. The simplest
set of constraints is that xi ≥ 0 (i.e., no short positions) and 1Tx = B (i.e., the
total budget to be invested is B, which is often taken to be one).

We take a stochastic model for price changes: p ∈ Rn is a random vector, with
known mean p and covariance Σ. Therefore with portfolio x ∈ Rn, the return r
is a (scalar) random variable with mean pTx and variance xTΣx. The choice of
portfolio x involves a trade-off between the mean of the return, and its variance.

The classical portfolio optimization problem, introduced by Markowitz, is the
QP

minimize xTΣx
subject to pTx ≥ rmin

1Tx = 1, x � 0,
where x, the portfolio, is the variable. Here we find the portfolio that minimizes
the return variance (which is associated with the risk of the portfolio) subject to



156 4 Convex optimization problems

achieving a minimum acceptable mean return rmin, and satisfying the portfolio
budget and no-shorting constraints.

Many extensions are possible. One standard extension, for example, is to allow
short positions, i.e., xi < 0. To do this we introduce variables xlong and xshort,
with

xlong � 0, xshort � 0, x = xlong − xshort, 1Txshort ≤ η1Txlong.
The last constraint limits the total short position at the beginning of the period to
some fraction η of the total long position at the beginning of the period.

As another extension we can include linear transaction costs in the portfolio
optimization problem. Starting from a given initial portfolio xinit we buy and sell
assets to achieve the portfolio x, which we then hold over the period as described
above. We are charged a transaction fee for buying and selling assets, which is
proportional to the amount bought or sold. To handle this, we introduce variables
ubuy and usell, which determine the amount of each asset we buy and sell before
the holding period. We have the constraints

x = xinit + ubuy − usell, ubuy � 0, usell � 0.
We replace the simple budget constraint 1Tx = 1 with the condition that the initial
buying and selling, including transaction fees, involves zero net cash:

(1− fsell)1Tusell = (1 + fbuy)1Tubuy
Here the lefthand side is the total proceeds from selling assets, less the selling
transaction fee, and the righthand side is the total cost, including transaction fee,
of buying assets. The constants fbuy ≥ 0 and fsell ≥ 0 are the transaction fee rates
for buying and selling (assumed the same across assets, for simplicity).

The problem of minimizing return variance, subject to a minimum mean return,
and the budget and trading constraints, is a QP with variables x, ubuy, usell.

4.4.2 Second-order cone programming

A problem that is closely related to quadratic programming is the second-order
cone program (SOCP):

minimize fTx
subject to ‖Aix+ bi‖2 ≤ cTi x+ di, i = 1, . . . ,m

Fx = g,
(4.36)

where x ∈ Rn is the optimization variable, Ai ∈ Rni×n, and F ∈ Rp×n. We call a
constraint of the form

‖Ax+ b‖2 ≤ cTx+ d,
where A ∈ Rk×n, a second-order cone constraint, since it is the same as requiring
the affine function (Ax+ b, cTx+ d) to lie in the second-order cone in Rk+1.

When ci = 0, i = 1, . . . ,m, the SOCP (4.36) is equivalent to a QCQP (which
is obtained by squaring each of the constraints). Similarly, if Ai = 0, i = 1, . . . ,m,
then the SOCP (4.36) reduces to a (general) LP. Second-order cone programs are,
however, more general than QCQPs (and of course, LPs).



4.4 Quadratic optimization problems 157

Robust linear programming

We consider a linear program in inequality form,

minimize cTx
subject to aTi x ≤ bi, i = 1, . . . ,m,

in which there is some uncertainty or variation in the parameters c, ai, bi. To
simplify the exposition we assume that c and bi are fixed, and that ai are known
to lie in given ellipsoids:

ai ∈ Ei = {ai + Piu | ‖u‖2 ≤ 1},

where Pi ∈ Rn×n. (If Pi is singular we obtain ‘flat’ ellipsoids, of dimension rankPi;
Pi = 0 means that ai is known perfectly.)

We will require that the constraints be satisfied for all possible values of the
parameters ai, which leads us to the robust linear program

minimize cTx
subject to aTi x ≤ bi for all ai ∈ Ei, i = 1, . . . ,m. (4.37)

The robust linear constraint, aTi x ≤ bi for all ai ∈ Ei, can be expressed as

sup{aTi x | ai ∈ Ei} ≤ bi,

the lefthand side of which can be expressed as

sup{aTi x | ai ∈ Ei} = aTi x+ sup{uTPTi x | ‖u‖2 ≤ 1}
= aTi x+ ‖PTi x‖2.

Thus, the robust linear constraint can be expressed as

aTi x+ ‖PTi x‖2 ≤ bi,

which is evidently a second-order cone constraint. Hence the robust LP (4.37) can
be expressed as the SOCP

minimize cTx
subject to aTi x+ ‖PTi x‖2 ≤ bi, i = 1, . . . ,m.

Note that the additional norm terms act as regularization terms ; they prevent x
from being large in directions with considerable uncertainty in the parameters ai.

Linear programming with random constraints

The robust LP described above can also be considered in a statistical framework.
Here we suppose that the parameters ai are independent Gaussian random vectors,
with mean ai and covariance Σi. We require that each constraint a

T
i x ≤ bi should

hold with a probability (or confidence) exceeding η, where η ≥ 0.5, i.e.,

prob(aTi x ≤ bi) ≥ η. (4.38)



158 4 Convex optimization problems

We will show that this probability constraint can be expressed as a second-order
cone constraint.

Letting u = aTi x, with σ
2 denoting its variance, this constraint can be written

as

prob

(
u− u
σ

≤ bi − u
σ

)
≥ η.

Since (u − u)/σ is a zero mean unit variance Gaussian variable, the probability
above is simply Φ((bi − u)/σ), where

Φ(z) =
1√
2π

∫ z
−∞

e−t
2/2 dt

is the cumulative distribution function of a zero mean unit variance Gaussian ran-
dom variable. Thus the probability constraint (4.38) can be expressed as

bi − u
σ

≥ Φ−1(η),

or, equivalently,
u+Φ−1(η)σ ≤ bi.

From u = aTi x and σ = (x
TΣix)

1/2 we obtain

aTi x+Φ
−1(η)‖Σ1/2i x‖2 ≤ bi.

By our assumption that η ≥ 1/2, we have Φ−1(η) ≥ 0, so this constraint is a
second-order cone constraint.

In summary, the problem

minimize cTx
subject to prob(aTi x ≤ bi) ≥ η, i = 1, . . . ,m

can be expressed as the SOCP

minimize cTx

subject to aTi x+Φ
−1(η)‖Σ1/2i x‖2 ≤ bi, i = 1, . . . ,m.

(We will consider robust convex optimization problems in more depth in chapter 6.
See also exercises 4.13, 4.28, and 4.59.)

Example 4.8 Portfolio optimization with loss risk constraints. We consider again the
classical Markowitz portfolio problem described above (page 155). We assume here
that the price change vector p ∈ Rn is a Gaussian random variable, with mean p
and covariance Σ. Therefore the return r is a Gaussian random variable with mean
r = pTx and variance σ2r = x

TΣx.

Consider a loss risk constraint of the form

prob(r ≤ α) ≤ β, (4.39)
where α is a given unwanted return level (e.g., a large loss) and β is a given maximum
probability.



4.4 Quadratic optimization problems 159

As in the stochastic interpretation of the robust LP given above, we can express this
constraint using the cumulative distribution function Φ of a unit Gaussian random
variable. The inequality (4.39) is equivalent to

pTx+Φ−1(β) ‖Σ1/2x‖2 ≥ α.

Provided β ≤ 1/2 (i.e., Φ−1(β) ≤ 0), this loss risk constraint is a second-order cone
constraint. (If β > 1/2, the loss risk constraint becomes nonconvex in x.)

The problem of maximizing the expected return subject to a bound on the loss
risk (with β ≤ 1/2), can therefore be cast as an SOCP with one second-order cone
constraint:

maximize pTx

subject to pTx+Φ−1(β) ‖Σ1/2x‖2 ≥ α
x � 0, 1Tx = 1.

There are many extensions of this problem. For example, we can impose several loss
risk constraints, i.e.,

prob(r ≤ αi) ≤ βi, i = 1, . . . , k,
(where βi ≤ 1/2), which expresses the risks (βi) we are willing to accept for various
levels of loss (αi).

Minimal surface

Consider a differentiable function f : R2 → R with dom f = C. The surface area
of its graph is given by

A =

∫
C

√
1 + ‖∇f(x)‖22 dx =

∫
C

‖(∇f(x), 1)‖2 dx,

which is a convex functional of f . The minimal surface problem is to find the
function f that minimizes A subject to some constraints, for example, some given
values of f on the boundary of C.

We will approximate this problem by discretizing the function f . Let C =
[0, 1] × [0, 1], and let fij denote the value of f at the point (i/K, j/K), for i, j =
0, . . . ,K. An approximate expression for the gradient of f at the point x =
(i/K, j/K) can be found using forward differences:

∇f(x) ≈ K
[
fi+1,j − fi,j
fi,j+1 − fi,j

]
.

Substituting this into the expression for the area of the graph, and approximating
the integral as a sum, we obtain an approximation for the area of the graph:

A ≈ Adisc = 1
K2

K−1∑
i,j=0

∥∥∥∥∥∥
 K(fi+1,j − fi,j)K(fi,j+1 − fi,j)

1

∥∥∥∥∥∥
2

The discretized area approximation Adisc is a convex function of fij .
We can consider a wide variety of constraints on fij , such as equality or in-

equality constraints on any of its entries (for example, on the boundary values), or



160 4 Convex optimization problems

on its moments. As an example, we consider the problem of finding the minimal
area surface with fixed boundary values on the left and right edges of the square:

minimize Adisc
subject to f0j = lj , j = 0, . . . ,K

fKj = rj , j = 0, . . . ,K
(4.40)

where fij , i, j = 0, . . . ,K, are the variables, and lj , rj are the given boundary
values on the left and right sides of the square.

We can transform the problem (4.40) into an SOCP by introducing new vari-
ables tij , i, j = 0, . . . ,K − 1:

minimize (1/K2)
∑K−1

i,j=0 tij

subject to

∥∥∥∥∥∥
 K(fi+1,j − fi,j)K(fi,j+1 − fi,j)

1

∥∥∥∥∥∥
2

≤ tij , i, j = 0, . . . ,K − 1

f0j = lj , j = 0, . . . ,K
fKj = rj , j = 0, . . . ,K.

4.5 Geometric programming

In this section we describe a family of optimization problems that are not convex
in their natural form. These problems can, however, be transformed to convex op-
timization problems, by a change of variables and a transformation of the objective
and constraint functions.

4.5.1 Monomials and posynomials

A function f : Rn → R with dom f = Rn++, defined as

f(x) = cxa11 x
a2
2 · · ·xann , (4.41)

where c > 0 and ai ∈ R, is called a monomial function, or simply, a monomial.
The exponents ai of a monomial can be any real numbers, including fractional or
negative, but the coefficient c can only be positive. (The term ‘monomial’ conflicts
with the standard definition from algebra, in which the exponents must be non-
negative integers, but this should not cause any confusion.) A sum of monomials,
i.e., a function of the form

f(x) =

K∑
k=1

ckx
a1k
1 x

a2k
2 · · ·xankn , (4.42)

where ck > 0, is called a posynomial function (with K terms), or simply, a posyn-
omial.



4.5 Geometric programming 161

Posynomials are closed under addition, multiplication, and nonnegative scal-
ing. Monomials are closed under multiplication and division. If a posynomial is
multiplied by a monomial, the result is a posynomial; similarly, a posynomial can
be divided by a monomial, with the result a posynomial.

4.5.2 Geometric programming

An optimization problem of the form

minimize f0(x)
subject to fi(x) ≤ 1, i = 1, . . . ,m

hi(x) = 1, i = 1, . . . , p
(4.43)

where f0, . . . , fm are posynomials and h1, . . . , hp are monomials, is called a geomet-
ric program (GP). The domain of this problem is D = Rn++; the constraint x ≻ 0
is implicit.

Extensions of geometric programming

Several extensions are readily handled. If f is a posynomial and h is a monomial,
then the constraint f(x) ≤ h(x) can be handled by expressing it as f(x)/h(x) ≤ 1
(since f/h is posynomial). This includes as a special case a constraint of the
form f(x) ≤ a, where f is posynomial and a > 0. In a similar way if h1 and h2
are both nonzero monomial functions, then we can handle the equality constraint
h1(x) = h2(x) by expressing it as h1(x)/h2(x) = 1 (since h1/h2 is monomial). We
can maximize a nonzero monomial objective function, by minimizing its inverse
(which is also a monomial).

For example, consider the problem

maximize x/y
subject to 2 ≤ x ≤ 3

x2 + 3y/z ≤ √y
x/y = z2,

with variables x, y, z ∈ R (and the implicit constraint x, y, z > 0). Using
the simple transformations described above, we obtain the equivalent standard
form GP

minimize x−1y
subject to 2x−1 ≤ 1, (1/3)x ≤ 1

x2y−1/2 + 3y1/2z−1 ≤ 1
xy−1z−2 = 1.

We will refer to a problem like this one, that is easily transformed to an equiva-
lent GP in the standard form (4.43), also as a GP. (In the same way that we refer
to a problem easily transformed to an LP as an LP.)



162 4 Convex optimization problems

4.5.3 Geometric program in convex form

Geometric programs are not (in general) convex optimization problems, but they
can be transformed to convex problems by a change of variables and a transforma-
tion of the objective and constraint functions.

We will use the variables defined as yi = log xi, so xi = e
yi . If f is the monomial

function of x given in (4.41), i.e.,

f(x) = cxa11 x
a2
2 · · ·xann ,

then

f(x) = f(ey1 , . . . , eyn)

= c(ey1)a1 · · · (eyn)an
= ea

T y+b,

where b = log c. The change of variables yi = log xi turns a monomial function
into the exponential of an affine function.

Similarly, if f is the posynomial given by (4.42), i.e.,

f(x) =
K∑
k=1

ckx
a1k
1 x

a2k
2 · · ·xankn ,

then

f(x) =
K∑
k=1

ea
T
k y+bk ,

where ak = (a1k, . . . , ank) and bk = log ck. After the change of variables, a posyn-
omial becomes a sum of exponentials of affine functions.

The geometric program (4.43) can be expressed in terms of the new variable y
as

minimize
∑K0

k=1 e
aT0ky+b0k

subject to
∑Ki

k=1 e
aTiky+bik ≤ 1, i = 1, . . . ,m

eg
T
i y+hi = 1, i = 1, . . . , p,

where aik ∈ Rn, i = 0, . . . ,m, contain the exponents of the posynomial inequality
constraints, and gi ∈ Rn, i = 1, . . . , p, contain the exponents of the monomial
equality constraints of the original geometric program.

Now we transform the objective and constraint functions, by taking the loga-
rithm. This results in the problem

minimize f˜0(y) = log
(∑K0

k=1 e
aT0ky+b0k

)
subject to f˜i(y) = log

(∑Ki
k=1 e

aTiky+bik
)
≤ 0, i = 1, . . . ,m

h˜i(y) = g
T
i y + hi = 0, i = 1, . . . , p.

(4.44)

Since the functions f˜i are convex, and h˜i are affine, this problem is a convex
optimization problem. We refer to it as a geometric program in convex form. To



4.5 Geometric programming 163

distinguish it from the original geometric program, we refer to (4.43) as a geometric
program in posynomial form.

Note that the transformation between the posynomial form geometric pro-
gram (4.43) and the convex form geometric program (4.44) does not involve any
computation; the problem data for the two problems are the same. It simply
changes the form of the objective and constraint functions.

If the posynomial objective and constraint functions all have only one term,
i.e., are monomials, then the convex form geometric program (4.44) reduces to a
(general) linear program. We can therefore consider geometric programming to be
a generalization, or extension, of linear programming.

4.5.4 Examples

Frobenius norm diagonal scaling

Consider a matrix M ∈ Rn×n, and the associated linear function that maps u
into y = Mu. Suppose we scale the coordinates, i.e., change variables to u˜ = Du,
y˜ = Dy, where D is diagonal, with Dii > 0. In the new coordinates the linear
function is given by y˜ = DMD−1u˜.

Now suppose we want to choose the scaling in such a way that the resulting
matrix, DMD−1, is small. We will use the Frobenius norm (squared) to measure
the size of the matrix:

‖DMD−1‖2F = tr
((
DMD−1

)T (
DMD−1

))
=

n∑
i,j=1

(
DMD−1

)2
ij

=

n∑
i,j=1

M2ijd
2
i /d

2
j ,

where D = diag(d). Since this is a posynomial in d, the problem of choosing the
scaling d to minimize the Frobenius norm is an unconstrained geometric program,

minimize
∑n

i,j=1M
2
ijd

2
i /d

2
j ,

with variable d. The only exponents in this geometric program are 0, 2, and −2.

Design of a cantilever beam

We consider the design of a cantilever beam, which consists of N segments, num-
bered from right to left as 1, . . . , N , as shown in figure 4.6. Each segment has unit
length and a uniform rectangular cross-section with width wi and height hi. A
vertical load (force) F is applied at the right end of the beam. This load causes
the beam to deflect (downward), and induces stress in each segment of the beam.
We assume that the deflections are small, and that the material is linearly elastic,
with Young’s modulus E.



164 4 Convex optimization problems

F

segment 4 segment 3 segment 2 segment 1

Figure 4.6 Segmented cantilever beam with 4 segments. Each segment has
unit length and a rectangular profile. A vertical force F is applied at the
right end of the beam.

The design variables in the problem are the widths wi and heights hi of the N
segments. We seek to minimize the total volume of the beam (which is proportional
to its weight),

w1h1 + · · ·+ wNhN ,
subject to some design constraints. We impose upper and lower bounds on width
and height of the segments,

wmin ≤ wi ≤ wmax, hmin ≤ hi ≤ hmax, i = 1, . . . , N,

as well as the aspect ratios,

Smin ≤ hi/wi ≤ Smax.

In addition, we have a limit on the maximum allowable stress in the material, and
on the vertical deflection at the end of the beam.

We first consider the maximum stress constraint. The maximum stress in seg-
ment i, which we denote σi, is given by σi = 6iF/(wih

2
i ). We impose the constraints

6iF

wih2i
≤ σmax, i = 1, . . . , N,

to ensure that the stress does not exceed the maximum allowable value σmax any-
where in the beam.

The last constraint is a limit on the vertical deflection at the end of the beam,
which we will denote y1:

y1 ≤ ymax.
The deflection y1 can be found by a recursion that involves the deflection and slope
of the beam segments:

vi = 12(i− 1/2) F
Ewih3i

+ vi+1, yi = 6(i− 1/3) F
Ewih3i

+ vi+1 + yi+1, (4.45)

for i = N,N − 1, . . . , 1, with starting values vN+1 = yN+1 = 0. In this recursion,
yi is the deflection at the right end of segment i, and vi is the slope at that point.
We can use the recursion (4.45) to show that these deflection and slope quantities



4.5 Geometric programming 165

are in fact posynomial functions of the variables w and h. We first note that vN+1
and yN+1 are zero, and therefore posynomials. Now assume that vi+1 and yi+1 are
posynomial functions of w and h. The lefthand equation in (4.45) shows that vi is
the sum of a monomial and a posynomial (i.e., vi+1), and therefore is a posynomial.
From the righthand equation in (4.45), we see that the deflection yi is the sum of
a monomial and two posynomials (vi+1 and yi+1), and so is a posynomial. In
particular, the deflection at the end of the beam, y1, is a posynomial.

The problem is then

minimize
∑N

i=1 wihi
subject to wmin ≤ wi ≤ wmax, i = 1, . . . , N

hmin ≤ hi ≤ hmax, i = 1, . . . , N
Smin ≤ hi/wi ≤ Smax, i = 1, . . . , N
6iF/(wih

2
i ) ≤ σmax, i = 1, . . . , N

y1 ≤ ymax,

(4.46)

with variables w and h. This is a GP, since the objective is a posynomial, and
the constraints can all be expressed as posynomial inequalities. (In fact, the con-
straints can be all be expressed as monomial inequalities, with the exception of the
deflection limit, which is a complicated posynomial inequality.)

When the number of segments N is large, the number of monomial terms ap-
pearing in the posynomial y1 grows approximately as N

2. Another formulation of
this problem, explored in exercise 4.31, is obtained by introducing v1, . . . , vN and
y1, . . . , yN as variables, and including a modified version of the recursion as a set
of constraints. This formulation avoids this growth in the number of monomial
terms.

Minimizing spectral radius via Perron-Frobenius theory

Suppose the matrix A ∈ Rn×n is elementwise nonnegative, i.e., Aij ≥ 0 for i, j =
1, . . . , n, and irreducible, which means that the matrix (I + A)n−1 is elementwise
positive. The Perron-Frobenius theorem states that A has a positive real eigenvalue
λpf equal to its spectral radius, i.e., the largest magnitude of its eigenvalues. The
Perron-Frobenius eigenvalue λpf determines the asymptotic rate of growth or decay

of Ak, as k → ∞; in fact, the matrix ((1/λpf)A)k converges. Roughly speaking,
this means that as k → ∞, Ak grows like λkpf , if λpf > 1, or decays like λkpf , if
λpf < 1.

A basic result in the theory of nonnegative matrices states that the Perron-
Frobenius eigenvalue is given by

λpf = inf{λ | Av � λv for some v ≻ 0}
(and moreover, that the infimum is achieved). The inequality Av � λv can be
expressed as

n∑
j=1

Aijvj/(λvi) ≤ 1, i = 1, . . . , n, (4.47)

which is a set of posynomial inequalities in the variables Aij , vi, and λ. Thus,
the condition that λpf ≤ λ can be expressed as a set of posynomial inequalities



166 4 Convex optimization problems

in A, v, and λ. This allows us to solve some optimization problems involving the
Perron-Frobenius eigenvalue using geometric programming.

Suppose that the entries of the matrix A are posynomial functions of some
underlying variable x ∈ Rk. In this case the inequalities (4.47) are posynomial
inequalities in the variables x ∈ Rk, v ∈ Rn, and λ ∈ R. We consider the problem
of choosing x to minimize the Perron-Frobenius eigenvalue (or spectral radius) of
A, possibly subject to posynomial inequalities on x,

minimize λpf(A(x))
subject to fi(x) ≤ 1, i = 1, . . . , p,

where fi are posynomials. Using the characterization above, we can express this
problem as the GP

minimize λ
subject to

∑n
j=1Aijvj/(λvi) ≤ 1, i = 1, . . . , n

fi(x) ≤ 1, i = 1, . . . , p,
where the variables are x, v, and λ.

As a specific example, we consider a simple model for the population dynamics
for a bacterium, with time or period denoted by t = 0, 1, 2, . . ., in hours. The vector
p(t) ∈ R4+ characterizes the population age distribution at period t: p1(t) is the
total population between 0 and 1 hours old; p2(t) is the total population between
1 and 2 hours old; and so on. We (arbitrarily) assume that no bacteria live more
than 4 hours. The population propagates in time as p(t+ 1) = Ap(t), where

A =


b1 b2 b3 b4
s1 0 0 0
0 s2 0 0
0 0 s3 0

 .
Here bi is the birth rate among bacteria in age group i, and si is the survival rate
from age group i into age group i + 1. We assume that bi > 0 and 0 < si < 1,
which implies that the matrix A is irreducible.

The Perron-Frobenius eigenvalue of A determines the asymptotic growth or
decay rate of the population. If λpf < 1, the population converges to zero like
λtpf , and so has a half-life of −1/ log2 λpf hours. If λpf > 1 the population grows
geometrically like λtpf , with a doubling time of 1/ log2 λpf hours. Minimizing the
spectral radius of A corresponds to finding the fastest decay rate, or slowest growth
rate, for the population.

As our underlying variables, on which the matrix A depends, we take c1 and c2,
the concentrations of two chemicals in the environment that affect the birth and
survival rates of the bacteria. We model the birth and survival rates as monomial
functions of the two concentrations:

bi = b
nom
i (c1/c

nom
1 )

αi(c2/c
nom
2 )

βi , i = 1, . . . , 4

si = s
nom
i (c1/c

nom
1 )

γi(c2/c
nom
2 )

δi , i = 1, . . . , 3.

Here, bnomi is nominal birth rate, s
nom
i is nominal survival rate, and c

nom
i is nominal

concentration of chemical i. The constants αi, βi, γi, and δi give the effect on the



4.6 Generalized inequality constraints 167

birth and survival rates due to changes in the concentrations of the chemicals away
from the nominal values. For example α2 = −0.3 and γ1 = 0.5 means that an
increase in concentration of chemical 1, over the nominal concentration, causes a
decrease in the birth rate of bacteria that are between 1 and 2 hours old, and an
increase in the survival rate of bacteria from 0 to 1 hours old.

We assume that the concentrations c1 and c2 can be independently increased or
decreased (say, within a factor of 2), by administering drugs, and pose the problem
of finding the drug mix that maximizes the population decay rate (i.e., minimizes
λpf(A)). Using the approach described above, this problem can be posed as the
GP

minimize λ
subject to b1v1 + b2v2 + b3v3 + b4v4 ≤ λv1

s1v1 ≤ λv2
s2v2 ≤ λv3
s3v3 ≤ λv4
1/2 ≤ ci/cnomi ≤ 2, i = 1, 2
bi = b

nom
i (c1/c

nom
1 )

αi(c2/c
nom
2 )

βi , i = 1, . . . , 4
si = s

nom
i (c1/c

nom
1 )

γi(c2/c
nom
2 )

δi , i = 1, . . . , 3,

with variables bi, si, ci, vi, and λ.

4.6 Generalized inequality constraints

One very useful generalization of the standard form convex optimization prob-
lem (4.15) is obtained by allowing the inequality constraint functions to be vector
valued, and using generalized inequalities in the constraints:

minimize f0(x)
subject to fi(x) �Ki 0, i = 1, . . . ,m

Ax = b,
(4.48)

where f0 : R
n → R, Ki ⊆ Rki are proper cones, and fi : Rn → Rki are Ki-convex.

We refer to this problem as a (standard form) convex optimization problem with
generalized inequality constraints. Problem (4.15) is a special case with Ki = R+,
i = 1, . . . ,m.

Many of the results for ordinary convex optimization problems hold for problems
with generalized inequalities. Some examples are:

• The feasible set, any sublevel set, and the optimal set are convex.
• Any point that is locally optimal for the problem (4.48) is globally optimal.
• The optimality condition for differentiable f0, given in §4.2.3, holds without
any change.

We will also see (in chapter 11) that convex optimization problems with generalized
inequality constraints can often be solved as easily as ordinary convex optimization
problems.



168 4 Convex optimization problems

4.6.1 Conic form problems

Among the simplest convex optimization problems with generalized inequalities are
the conic form problems (or cone programs), which have a linear objective and one
inequality constraint function, which is affine (and therefore K-convex):

minimize cTx
subject to Fx+ g �K 0

Ax = b.
(4.49)

When K is the nonnegative orthant, the conic form problem reduces to a linear
program. We can view conic form problems as a generalization of linear programs
in which componentwise inequality is replaced with a generalized linear inequality.

Continuing the analogy to linear programming, we refer to the conic form prob-
lem

minimize cTx
subject to x �K 0

Ax = b

as a conic form problem in standard form. Similarly, the problem

minimize cTx
subject to Fx+ g �K 0

is called a conic form problem in inequality form.

4.6.2 Semidefinite programming

When K is Sk+, the cone of positive semidefinite k × k matrices, the associated
conic form problem is called a semidefinite program (SDP), and has the form

minimize cTx
subject to x1F1 + · · ·+ xnFn +G � 0

Ax = b,
(4.50)

where G, F1, . . . , Fn ∈ Sk, and A ∈ Rp×n. The inequality here is a linear matrix
inequality (see example 2.10).

If the matrices G, F1, . . . , Fn are all diagonal, then the LMI in (4.50) is equiva-
lent to a set of n linear inequalities, and the SDP (4.50) reduces to a linear program.

Standard and inequality form semidefinite programs

Following the analogy to LP, a standard form SDP has linear equality constraints,
and a (matrix) nonnegativity constraint on the variable X ∈ Sn:

minimize tr(CX)
subject to tr(AiX) = bi, i = 1, . . . , p

X � 0,
(4.51)



4.6 Generalized inequality constraints 169

where C, A1, . . . , Ap ∈ Sn. (Recall that tr(CX) =
∑n

i,j=1 CijXij is the form of a
general real-valued linear function on Sn.) This form should be compared to the
standard form linear program (4.28). In LP and SDP standard forms, we minimize
a linear function of the variable, subject to p linear equality constraints on the
variable, and a nonnegativity constraint on the variable.

An inequality form SDP, analogous to an inequality form LP (4.29), has no
equality constraints, and one LMI:

minimize cTx
subject to x1A1 + · · ·+ xnAn � B,

with variable x ∈ Rn, and parameters B, A1, . . . , An ∈ Sk, c ∈ Rn.

Multiple LMIs and linear inequalities

It is common to refer to a problem with linear objective, linear equality and in-
equality constraints, and several LMI constraints, i.e.,

minimize cTx

subject to F (i)(x) = x1F
(i)
1 + · · ·+ xnF (i)n +G(i) � 0, i = 1, . . . ,K

Gx � h, Ax = b,
as an SDP as well. Such problems are readily transformed to an SDP, by forming
a large block diagonal LMI from the individual LMIs and linear inequalities:

minimize cTx
subject to diag(Gx− h, F (1)(x), . . . , F (K)(x)) � 0

Ax = b.

4.6.3 Examples

Second-order cone programming

The SOCP (4.36) can be expressed as a conic form problem

minimize cTx
subject to −(Aix+ bi, cTi x+ di) �Ki 0, i = 1, . . . ,m

Fx = g,

in which
Ki = {(y, t) ∈ Rni+1 | ‖y‖2 ≤ t},

i.e., the second-order cone in Rni+1. This explains the name second-order cone
program for the optimization problem (4.36).

Matrix norm minimization

Let A(x) = A0 + x1A1 + · · · + xnAn, where Ai ∈ Rp×q. We consider the uncon-
strained problem

minimize ‖A(x)‖2,



170 4 Convex optimization problems

where ‖ · ‖2 denotes the spectral norm (maximum singular value), and x ∈ Rn is
the variable. This is a convex problem since ‖A(x)‖2 is a convex function of x.

Using the fact that ‖A‖2 ≤ s if and only if ATA � s2I (and s ≥ 0), we can
express the problem in the form

minimize s
subject to A(x)TA(x) � sI,

with variables x and s. Since the function A(x)TA(x) − sI is matrix convex in
(x, s), this is a convex optimization problem with a single q × q matrix inequality
constraint.

We can also formulate the problem using a single linear matrix inequality of
size (p+ q)× (p+ q), using the fact that

ATA � t2I (and t ≥ 0) ⇐⇒
[
tI A
AT tI

]
� 0.

(see §A.5.5). This results in the SDP
minimize t

subject to

[
tI A(x)

A(x)T tI

]
� 0

in the variables x and t.

Moment problems

Let t be a random variable in R. The expected values E tk (assuming they exist)
are called the (power) moments of the distribution of t. The following classical
results give a characterization of a moment sequence.

If there is a probability distribution on R such that xk = E t
k, k = 0, . . . , 2n,

then x0 = 1 and

H(x0, . . . , x2n) =



x0 x1 x2 . . . xn−1 xn
x1 x2 x3 . . . xn xn+1
x2 x3 x4 . . . xn+1 xn+2
...

...
...

...
...

xn−1 xn xn+1 . . . x2n−2 x2n−1
xn xn+1 xn+2 . . . x2n−1 x2n


� 0. (4.52)

(The matrix H is called the Hankel matrix associated with x0, . . . , x2n.) This is
easy to see: Let xi = E t

i, i = 0, . . . , 2n be the moments of some distribution, and
let y = (y0, y1, . . . yn) ∈ Rn+1. Then we have

yTH(x0, . . . , x2n)y =

n∑
i,j=0

yiyj E t
i+j = E(y0 + y1t

1 + · · ·+ yntn)2 ≥ 0.

The following partial converse is less obvious: If x0 = 1 and H(x) ≻ 0, then there
exists a probability distribution on R such that xi = E t

i, i = 0, . . . , 2n. (For a



4.6 Generalized inequality constraints 171

proof, see exercise 2.37.) Now suppose that x0 = 1, and H(x) � 0 (but possibly
H(x) 6≻ 0), i.e., the linear matrix inequality (4.52) holds, but possibly not strictly.
In this case, there is a sequence of distributions on R, whose moments converge to
x. In summary: the condition that x0, . . . , x2n be the moments of some distribution
on R (or the limit of the moments of a sequence of distributions) can be expressed
as the linear matrix inequality (4.52) in the variable x, together with the linear
equality x0 = 1. Using this fact, we can cast some interesting problems involving
moments as SDPs.

Suppose t is a random variable on R. We do not know its distribution, but we
do know some bounds on the moments, i.e.,

µ
k
≤ E tk ≤ µk, k = 1, . . . , 2n

(which includes, as a special case, knowing exact values of some of the moments).
Let p(t) = c0 + c1t + · · · + c2nt2n be a given polynomial in t. The expected value
of p(t) is linear in the moments E ti:

E p(t) =

2n∑
i=0

ciE t
i =

2n∑
i=0

cixi.

We can compute upper and lower bounds for E p(t),

minimize (maximize) E p(t)
subject to µ

k
≤ E tk ≤ µk, k = 1, . . . , 2n,

over all probability distributions that satisfy the given moment bounds, by solving
the SDP

minimize (maximize) c1x1 + · · ·+ c2nx2n
subject to µ

k
≤ xk ≤ µk, k = 1, . . . , 2n

H(1, x1, . . . , x2n) � 0
with variables x1, . . . , x2n. This gives bounds on E p(t), over all probability dis-
tributions that satisfy the known moment constraints. The bounds are sharp in
the sense that there exists a sequence of distributions, whose moments satisfy the
given moment bounds, for which E p(t) converges to the upper and lower bounds
found by these SDPs.

Bounding portfolio risk with incomplete covariance information

We consider once again the setup for the classical Markowitz portfolio problem (see
page 155). We have a portfolio of n assets or stocks, with xi denoting the amount
of asset i that is held over some investment period, and pi denoting the relative
price change of asset i over the period. The change in total value of the portfolio
is pTx. The price change vector p is modeled as a random vector, with mean and
covariance

p = E p, Σ = E(p− p)(p− p)T .
The change in value of the portfolio is therefore a random variable with mean pTx
and standard deviation σ = (xTΣx)1/2. The risk of a large loss, i.e., a change
in portfolio value that is substantially below its expected value, is directly related



172 4 Convex optimization problems

to the standard deviation σ, and increases with it. For this reason the standard
deviation σ (or the variance σ2) is used as a measure of the risk associated with
the portfolio.

In the classical portfolio optimization problem, the portfolio x is the optimiza-
tion variable, and we minimize the risk subject to a minimum mean return and
other constraints. The price change statistics p and Σ are known problem param-
eters. In the risk bounding problem considered here, we turn the problem around:
we assume the portfolio x is known, but only partial information is available about
the covariance matrix Σ. We might have, for example, an upper and lower bound
on each entry:

Lij ≤ Σij ≤ Uij , i, j = 1, . . . , n,
where L and U are given. We now pose the question: what is the maximum risk
for our portfolio, over all covariance matrices consistent with the given bounds?
We define the worst-case variance of the portfolio as

σ2wc = sup{xTΣx | Lij ≤ Σij ≤ Uij , i, j = 1, . . . , n, Σ � 0}.
We have added the condition Σ � 0, which the covariance matrix must, of course,
satisfy.

We can find σwc by solving the SDP

maximize xTΣx
subject to Lij ≤ Σij ≤ Uij , i, j = 1, . . . , n

Σ � 0
with variable Σ ∈ Sn (and problem parameters x, L, and U). The optimal Σ is
the worst covariance matrix consistent with our given bounds on the entries, where
‘worst’ means largest risk with the (given) portfolio x. We can easily construct
a distribution for p that is consistent with the given bounds, and achieves the
worst-case variance, from an optimal Σ for the SDP. For example, we can take
p = p+Σ1/2v, where v is any random vector with E v = 0 and E vvT = I.

Evidently we can use the same method to determine σwc for any prior informa-
tion about Σ that is convex. We list here some examples.

• Known variance of certain portfolios. We might have equality constraints
such as

uTkΣuk = σ
2
k,

where uk and σk are given. This corresponds to prior knowledge that certain
known portfolios (given by uk) have known (or very accurately estimated)
variance.

• Including effects of estimation error. If the covariance Σ is estimated from
empirical data, the estimation method will give an estimate Σˆ, and some in-
formation about the reliability of the estimate, such as a confidence ellipsoid.
This can be expressed as

C(Σ− Σˆ) ≤ α,
where C is a positive definite quadratic form on Sn, and the constant α
determines the confidence level.



4.6 Generalized inequality constraints 173

• Factor models. The covariance might have the form

Σ = FΣfactorF
T +D,

where F ∈ Rn×k, Σfactor ∈ Sk, and D is diagonal. This corresponds to a
model of the price changes of the form

p = Fz + d,

where z is a random variable (the underlying factors that affect the price
changes) and di are independent (additional volatility of each asset price).
We assume that the factors are known. Since Σ is linearly related to Σfactor
and D, we can impose any convex constraint on them (representing prior
information) and still compute σwc using convex optimization.

• Information about correlation coefficients. In the simplest case, the diagonal
entries of Σ (i.e., the volatilities of each asset price) are known, and bounds
on correlation coefficients between price changes are known:

lij ≤ ρij = Σij
Σ

1/2
ii Σ

1/2
jj

≤ uij , i, j = 1, . . . , n.

Since Σii are known, but Σij for i 6= j are not, these are linear inequalities.

Fastest mixing Markov chain on a graph

We consider an undirected graph, with nodes 1, . . . , n, and a set of edges

E ⊆ {1, . . . , n} × {1, . . . , n}.

Here (i, j) ∈ E means that nodes i and j are connected by an edge. Since the
graph is undirected, E is symmetric: (i, j) ∈ E if and only if (j, i) ∈ E . We allow
the possibility of self-loops, i.e., we can have (i, i) ∈ E .

We define a Markov chain, with state X(t) ∈ {1, . . . , n}, for t ∈ Z+ (the set
of nonnegative integers), as follows. With each edge (i, j) ∈ E we associate a
probability Pij , which is the probability that X makes a transition between nodes
i and j. State transitions can only occur across edges; we have Pij = 0 for (i, j) 6∈ E .
The probabilities associated with the edges must be nonnegative, and for each node,
the sum of the probabilities of links connected to the node (including a self-loop,
if there is one) must equal one.

The Markov chain has transition probability matrix

Pij = prob(X(t+ 1) = i | X(t) = j), i, j = 1, . . . , n.

This matrix must satisfy

Pij ≥ 0, i, j = 1, . . . , n, 1TP = 1T , P = PT , (4.53)

and also
Pij = 0 for (i, j) 6∈ E . (4.54)



174 4 Convex optimization problems

Since P is symmetric and 1TP = 1T , we conclude P1 = 1, so the uniform
distribution (1/n)1 is an equilibrium distribution for the Markov chain. Conver-
gence of the distribution of X(t) to (1/n)1 is determined by the second largest (in
magnitude) eigenvalue of P , i.e., by r = max{λ2,−λn}, where

1 = λ1 ≥ λ2 ≥ · · · ≥ λn
are the eigenvalues of P . We refer to r as the mixing rate of the Markov chain.
If r = 1, then the distribution of X(t) need not converge to (1/n)1 (which means
the Markov chain does not mix). When r < 1, the distribution of X(t) approaches
(1/n)1 asymptotically as rt, as t → ∞. Thus, the smaller r is, the faster the
Markov chain mixes.

The fastest mixing Markov chain problem is to find P , subject to the con-
straints (4.53) and (4.54), that minimizes r. (The problem data is the graph, i.e.,
E .) We will show that this problem can be formulated as an SDP.

Since the eigenvalue λ1 = 1 is associated with the eigenvector 1, we can express
the mixing rate as the norm of the matrix P , restricted to the subspace 1⊥: r =
‖QPQ‖2, where Q = I−(1/n)11T is the matrix representing orthogonal projection
on 1⊥. Using the property P1 = 1, we have

r = ‖QPQ‖2
= ‖(I − (1/n)11T )P (I − (1/n)11T )‖2
= ‖P − (1/n)11T ‖2.

This shows that the mixing rate r is a convex function of P , so the fastest mixing
Markov chain problem can be cast as the convex optimization problem

minimize ‖P − (1/n)11T ‖2
subject to P1 = 1

Pij ≥ 0, i, j = 1, . . . , n
Pij = 0 for (i, j) 6∈ E ,

with variable P ∈ Sn. We can express the problem as an SDP by introducing a
scalar variable t to bound the norm of P − (1/n)11T :

minimize t
subject to −tI � P − (1/n)11T � tI

P1 = 1
Pij ≥ 0, i, j = 1, . . . , n
Pij = 0 for (i, j) 6∈ E .

(4.55)

4.7 Vector optimization

4.7.1 General and convex vector optimization problems

In §4.6 we extended the standard form problem (4.1) to include vector-valued
constraint functions. In this section we investigate the meaning of a vector-valued



4.7 Vector optimization 175

objective function. We denote a general vector optimization problem as

minimize (with respect to K) f0(x)
subject to fi(x) ≤ 0, i = 1, . . . ,m

hi(x) = 0, i = 1, . . . , p.
(4.56)

Here x ∈ Rn is the optimization variable, K ⊆ Rq is a proper cone, f0 : Rn → Rq
is the objective function, fi : R

n → R are the inequality constraint functions, and
hi : R

n → R are the equality constraint functions. The only difference between this
problem and the standard optimization problem (4.1) is that here, the objective
function takes values in Rq, and the problem specification includes a proper cone
K, which is used to compare objective values. In the context of vector optimization,
the standard optimization problem (4.1) is sometimes called a scalar optimization
problem.

We say the vector optimization problem (4.56) is a convex vector optimization
problem if the objective function f0 isK-convex, the inequality constraint functions
f1, . . . , fm are convex, and the equality constraint functions h1, . . . , hp are affine.
(As in the scalar case, we usually express the equality constraints as Ax = b, where
A ∈ Rp×n.)

What meaning can we give to the vector optimization problem (4.56)? Suppose
x and y are two feasible points (i.e., they satisfy the constraints). Their associated
objective values, f0(x) and f0(y), are to be compared using the generalized inequal-
ity �K . We interpret f0(x) �K f0(y) as meaning that x is ‘better than or equal’ in
value to y (as judged by the objective f0, with respect to K). The confusing aspect
of vector optimization is that the two objective values f0(x) and f0(y) need not be
comparable; we can have neither f0(x) �K f0(y) nor f0(y) �K f0(x), i.e., neither
is better than the other. This cannot happen in a scalar objective optimization
problem.

4.7.2 Optimal points and values

We first consider a special case, in which the meaning of the vector optimization
problem is clear. Consider the set of objective values of feasible points,

O = {f0(x) | ∃x ∈ D, fi(x) ≤ 0, i = 1, . . . ,m, hi(x) = 0, i = 1, . . . , p} ⊆ Rq,

which is called the set of achievable objective values. If this set has a minimum
element (see §2.4.2), i.e., there is a feasible x such that f0(x) �K f0(y) for all
feasible y, then we say x is optimal for the problem (4.56), and refer to f0(x) as
the optimal value of the problem. (When a vector optimization problem has an
optimal value, it is unique.) If x⋆ is an optimal point, then f0(x

⋆), the objective
at x⋆, can be compared to the objective at every other feasible point, and is better
than or equal to it. Roughly speaking, x⋆ is unambiguously a best choice for x,
among feasible points.

A point x⋆ is optimal if and only if it is feasible and

O ⊆ f0(x⋆) +K (4.57)



176 4 Convex optimization problems

O

f0(x
⋆)

Figure 4.7 The set O of achievable values for a vector optimization with
objective values in R2, with cone K = R2+, is shown shaded. In this case,
the point labeled f0(x

⋆) is the optimal value of the problem, and x⋆ is an
optimal point. The objective value f0(x

⋆) can be compared to every other
achievable value f0(y), and is better than or equal to f0(y). (Here, ‘better
than or equal to’ means ‘is below and to the left of’.) The lightly shaded
region is f0(x

⋆)+K, which is the set of all z ∈ R2 corresponding to objective
values worse than (or equal to) f0(x

⋆).

(see §2.4.2). The set f0(x⋆) + K can be interpreted as the set of values that are
worse than, or equal to, f0(x

⋆), so the condition (4.57) states that every achievable
value falls in this set. This is illustrated in figure 4.7. Most vector optimization
problems do not have an optimal point and an optimal value, but this does occur
in some special cases.

Example 4.9 Best linear unbiased estimator. Suppose y = Ax+ v, where v ∈ Rm is
a measurement noise, y ∈ Rm is a vector of measurements, and x ∈ Rn is a vector to
be estimated, given the measurement y. We assume that A has rank n, and that the
measurement noise satisfies E v = 0, E vvT = I, i.e., its components are zero mean
and uncorrelated.

A linear estimator of x has the form x̂ = Fy. The estimator is called unbiased if for
all x we have E x̂ = x, i.e., if FA = I. The error covariance of an unbiased estimator
is

E(x̂− x)(x̂− x)T = EFvvTFT = FFT .
Our goal is to find an unbiased estimator that has a ‘small’ error covariance matrix.
We can compare error covariances using matrix inequality, i.e., with respect to Sn+.
This has the following interpretation: Suppose x̂1 = F1y, x̂2 = F2y are two unbiased
estimators. Then the first estimator is at least as good as the second, i.e., F1F

T
1 �

F2F
T
2 , if and only if for all c,

E(cT x̂1 − cTx)2 ≤ E(cT x̂2 − cTx)2.

In other words, for any linear function of x, the estimator F1 yields at least as good
an estimate as does F2.



4.7 Vector optimization 177

We can express the problem of finding an unbiased estimator for x as the vector
optimization problem

minimize (w.r.t. Sn+) FF
T

subject to FA = I,
(4.58)

with variable F ∈ Rn×m. The objective FFT is convex with respect to Sn+, so the
problem (4.58) is a convex vector optimization problem. An easy way to see this is
to observe that vTFFT v = ‖FT v‖22 is a convex function of F for any fixed v.
It is a famous result that the problem (4.58) has an optimal solution, the least-squares
estimator, or pseudo-inverse,

F ⋆ = A† = (ATA)−1AT .

For any F with FA = I, we have FFT � F ⋆F ⋆T . The matrix

F ⋆F ⋆T = A†A†T = (ATA)−1

is the optimal value of the problem (4.58).

4.7.3 Pareto optimal points and values

We now consider the case (which occurs in most vector optimization problems of
interest) in which the set of achievable objective values does not have a minimum
element, so the problem does not have an optimal point or optimal value. In these
cases minimal elements of the set of achievable values play an important role. We
say that a feasible point x is Pareto optimal (or efficient) if f0(x) is a minimal
element of the set of achievable values O. In this case we say that f0(x) is a
Pareto optimal value for the vector optimization problem (4.56). Thus, a point x
is Pareto optimal if it is feasible and, for any feasible y, f0(y) �K f0(x) implies
f0(y) = f0(x). In other words: any feasible point y that is better than or equal to
x (i.e., f0(y) �K f0(x)) has exactly the same objective value as x.

A point x is Pareto optimal if and only if it is feasible and

(f0(x)−K) ∩ O = {f0(x)} (4.59)

(see §2.4.2). The set f0(x) − K can be interpreted as the set of values that are
better than or equal to f0(x), so the condition (4.59) states that the only achievable
value better than or equal to f0(x) is f0(x) itself. This is illustrated in figure 4.8.

A vector optimization problem can have many Pareto optimal values (and
points). The set of Pareto optimal values, denoted P, satisfies

P ⊆ O ∩ bdO,

i.e., every Pareto optimal value is an achievable objective value that lies in the
boundary of the set of achievable objective values (see exercise 4.52).



178 4 Convex optimization problems

O

f0(x
po)

Figure 4.8 The set O of achievable values for a vector optimization problem
with objective values in R2, with cone K = R2+, is shown shaded. This
problem does not have an optimal point or value, but it does have a set of
Pareto optimal points, whose corresponding values are shown as the dark-
ened curve on the lower left boundary of O. The point labeled f0(xpo)
is a Pareto optimal value, and xpo is a Pareto optimal point. The lightly
shaded region is f0(x

po) −K, which is the set of all z ∈ R2 corresponding
to objective values better than (or equal to) f0(x

po).

4.7.4 Scalarization

Scalarization is a standard technique for finding Pareto optimal (or optimal) points
for a vector optimization problem, based on the characterization of minimum and
minimal points via dual generalized inequalities given in §2.6.3. Choose any λ ≻K∗
0, i.e., any vector that is positive in the dual generalized inequality. Now consider
the scalar optimization problem

minimize λT f0(x)
subject to fi(x) ≤ 0, i = 1, . . . ,m

hi(x) = 0, i = 1, . . . , p,
(4.60)

and let x be an optimal point. Then x is Pareto optimal for the vector optimization
problem (4.56). This follows from the dual inequality characterization of minimal
points given in §2.6.3, and is also easily shown directly. If x were not Pareto optimal,
then there is a y that is feasible, satisfies f0(y) �K f0(x), and f0(x) 6= f0(y).
Since f0(x) − f0(y) �K 0 and is nonzero, we have λT (f0(x) − f0(y)) > 0, i.e.,
λT f0(x) > λ

T f0(y). This contradicts the assumption that x is optimal for the
scalar problem (4.60).

Using scalarization, we can find Pareto optimal points for any vector opti-
mization problem by solving the ordinary scalar optimization problem (4.60). The
vector λ, which is sometimes called the weight vector, must satisfy λ ≻K∗ 0. The
weight vector is a free parameter; by varying it we obtain (possibly) different Pareto
optimal solutions of the vector optimization problem (4.56). This is illustrated in
figure 4.9. The figure also shows an example of a Pareto optimal point that cannot



4.7 Vector optimization 179

O

f0(x1)

λ1

f0(x2)
λ2

f0(x3)

Figure 4.9 Scalarization. The set O of achievable values for a vector opti-
mization problem with cone K = R2+. Three Pareto optimal values f0(x1),
f0(x2), f0(x3) are shown. The first two values can be obtained by scalar-
ization: f0(x1) minimizes λ

T
1 u over all u ∈ O and f0(x2) minimizes λT2 u,

where λ1, λ2 ≻ 0. The value f0(x3) is Pareto optimal, but cannot be found
by scalarization.

be obtained via scalarization, for any value of the weight vector λ ≻K∗ 0.
The method of scalarization can be interpreted geometrically. A point x is

optimal for the scalarized problem, i.e., minimizes λT f0 over the feasible set, if
and only if λT (f0(y)− f0(x)) ≥ 0 for all feasible y. But this is the same as saying
that {u | − λT (u− f0(x)) = 0} is a supporting hyperplane to the set of achievable
objective values O at the point f0(x); in particular

{u | λT (u− f0(x)) < 0} ∩ O = ∅. (4.61)

(See figure 4.9.) Thus, when we find an optimal point for the scalarized problem, we
not only find a Pareto optimal point for the original vector optimization problem;
we also find an entire halfspace in Rq, given by (4.61), of objective values that
cannot be achieved.

Scalarization of convex vector optimization problems

Now suppose the vector optimization problem (4.56) is convex. Then the scalarized
problem (4.60) is also convex, since λT f0 is a (scalar-valued) convex function (by
the results in §3.6). This means that we can find Pareto optimal points of a convex
vector optimization problem by solving a convex scalar optimization problem. For
each choice of the weight vector λ ≻K∗ 0 we get a (usually different) Pareto optimal
point.

For convex vector optimization problems we have a partial converse: For every
Pareto optimal point xpo, there is some nonzero λ �K∗ 0 such that xpo is a solution
of the scalarized problem (4.60). So, roughly speaking, for convex problems the
method of scalarization yields all Pareto optimal points, as the weight vector λ



180 4 Convex optimization problems

varies over theK∗-nonnegative, nonzero values. We have to be careful here, because
it is not true that every solution of the scalarized problem, with λ �K∗ 0 and λ 6= 0,
is a Pareto optimal point for the vector problem. (In contrast, every solution of
the scalarized problem with λ ≻K∗ 0 is Pareto optimal.)

In some cases we can use this partial converse to find all Pareto optimal points
of a convex vector optimization problem. Scalarization with λ ≻K∗ 0 gives a set
of Pareto optimal points (as it would in a nonconvex vector optimization problem
as well). To find the remaining Pareto optimal solutions, we have to consider
nonzero weight vectors λ that satisfy λ �K∗ 0. For each such weight vector, we
first identify all solutions of the scalarized problem. Then among these solutions we
must check which are, in fact, Pareto optimal for the vector optimization problem.
These ‘extreme’ Pareto optimal points can also be found as the limits of the Pareto
optimal points obtained from positive weight vectors.

To establish this partial converse, we consider the set

A = O +K = {t ∈ Rq | f0(x) �K t for some feasible x}, (4.62)
which consists of all values that are worse than or equal to (with respect to �K)
some achievable objective value. While the set O of achievable objective values
need not be convex, the set A is convex, when the problem is convex. Moreover,
the minimal elements of A are exactly the same as the minimal elements of the
set O of achievable values, i.e., they are the same as the Pareto optimal values.
(See exercise 4.53.) Now we use the results of §2.6.3 to conclude that any minimal
element of A minimizes λT z over A for some nonzero λ �K∗ 0. This means that
every Pareto optimal point for the vector optimization problem is optimal for the
scalarized problem, for some nonzero weight λ �K∗ 0.

Example 4.10 Minimal upper bound on a set of matrices. We consider the (convex)
vector optimization problem, with respect to the positive semidefinite cone,

minimize (w.r.t. Sn+) X
subject to X � Ai, i = 1, . . . ,m, (4.63)

where Ai ∈ Sn, i = 1, . . . ,m, are given. The constraints mean that X is an upper
bound on the given matrices A1, . . . , Am; a Pareto optimal solution of (4.63) is a
minimal upper bound on the matrices.

To find a Pareto optimal point, we apply scalarization: we choose any W ∈ Sn++ and
form the problem

minimize tr(WX)
subject to X � Ai, i = 1, . . . ,m, (4.64)

which is an SDP. Different choices for W will, in general, give different minimal
solutions.

The partial converse tells us that if X is Pareto optimal for the vector problem (4.63)
then it is optimal for the SDP (4.64), for some nonzero weight matrix W � 0.
(In this case, however, not every solution of (4.64) is Pareto optimal for the vector
optimization problem.)

We can give a simple geometric interpretation for this problem. We associate with
each A ∈ Sn++ an ellipsoid centered at the origin, given by

EA = {u | uTA−1u ≤ 1},



4.7 Vector optimization 181

X1

X2

Figure 4.10 Geometric interpretation of the problem (4.63). The three
shaded ellipsoids correspond to the data A1, A2, A3 ∈ S2++; the Pareto
optimal points correspond to minimal ellipsoids that contain them. The two
ellipsoids, with boundaries labeled X1 and X2, show two minimal ellipsoids
obtained by solving the SDP (4.64) for two different weight matricesW1 and
W2.

so that A � B if and only if EA ⊆ EB . A Pareto optimal point X for the prob-
lem (4.63) corresponds to a minimal ellipsoid that contains the ellipsoids associated
with A1, . . . , Am. An example is shown in figure 4.10.

4.7.5 Multicriterion optimization

When a vector optimization problem involves the cone K = Rq+, it is called a
multicriterion or multi-objective optimization problem. The components of f0,
say, F1, . . . , Fq, can be interpreted as q different scalar objectives, each of which
we would like to minimize. We refer to Fi as the ith objective of the problem. A
multicriterion optimization problem is convex if f1, . . . , fm are convex, h1, . . . , hp
are affine, and the objectives F1, . . . , Fq are convex.

Since multicriterion problems are vector optimization problems, all of the ma-
terial of §4.7.1–§4.7.4 applies. For multicriterion problems, though, we can be a
bit more specific in the interpretations. If x is feasible, we can think of Fi(x) as
its score or value, according to the ith objective. If x and y are both feasible,
Fi(x) ≤ Fi(y) means that x is at least as good as y, according to the ith objective;
Fi(x) < Fi(y) means that x is better than y, or x beats y, according to the ith ob-
jective. If x and y are both feasible, we say that x is better than y, or x dominates
y, if Fi(x) ≤ Fi(y) for i = 1, . . . , q, and for at least one j, Fj(x) < Fj(y). Roughly
speaking, x is better than y if x meets or beats y on all objectives, and beats it in
at least one objective.

In a multicriterion problem, an optimal point x⋆ satisfies

Fi(x
⋆) ≤ Fi(y), i = 1, . . . , q,



182 4 Convex optimization problems

for every feasible y. In other words, x⋆ is simultaneously optimal for each of the
scalar problems

minimize Fj(x)
subject to fi(x) ≤ 0, i = 1, . . . ,m

hi(x) = 0, i = 1, . . . , p,

for j = 1, . . . , q. When there is an optimal point, we say that the objectives are
noncompeting, since no compromises have to be made among the objectives; each
objective is as small as it could be made, even if the others were ignored.

A Pareto optimal point xpo satisfies the following: if y is feasible and Fi(y) ≤
Fi(x

po) for i = 1, . . . , q, then Fi(x
po) = Fi(y), i = 1, . . . , q. This can be restated

as: a point is Pareto optimal if and only if it is feasible and there is no better
feasible point. In particular, if a feasible point is not Pareto optimal, there is at
least one other feasible point that is better. In searching for good points, then, we
can clearly limit our search to Pareto optimal points.

Trade-off analysis

Now suppose that x and y are Pareto optimal points with, say,

Fi(x) < Fi(y), i ∈ A
Fi(x) = Fi(y), i ∈ B
Fi(x) > Fi(y), i ∈ C,

where A∪B∪C = {1, . . . , q}. In other words, A is the set of (indices of) objectives
for which x beats y, B is the set of objectives for which the points x and y are tied,
and C is the set of objectives for which y beats x. If A and C are empty, then
the two points x and y have exactly the same objective values. If this is not the
case, then both A and C must be nonempty. In other words, when comparing two
Pareto optimal points, they either obtain the same performance (i.e., all objectives
equal), or, each beats the other in at least one objective.

In comparing the point x to y, we say that we have traded or traded off better
objective values for i ∈ A for worse objective values for i ∈ C. Optimal trade-off
analysis (or just trade-off analysis) is the study of how much worse we must do
in one or more objectives in order to do better in some other objectives, or more
generally, the study of what sets of objective values are achievable.

As an example, consider a bi-criterion (i.e., two criterion) problem. Suppose
x is a Pareto optimal point, with objectives F1(x) and F2(x). We might ask how
much larger F2(z) would have to be, in order to obtain a feasible point z with
F1(z) ≤ F1(x)−a, where a > 0 is some constant. Roughly speaking, we are asking
how much we must pay in the second objective to obtain an improvement of a in
the first objective. If a large increase in F2 must be accepted to realize a small
decrease in F1, we say that there is a strong trade-off between the objectives, near
the Pareto optimal value (F1(x), F2(x)). If, on the other hand, a large decrease
in F1 can be obtained with only a small increase in F2, we say that the trade-off
between the objectives is weak (near the Pareto optimal value (F1(x), F2(x))).

We can also consider the case in which we trade worse performance in the first
objective for an improvement in the second. Here we find how much smaller F2(z)



4.7 Vector optimization 183

can be made, to obtain a feasible point z with F1(z) ≤ F1(x) + a, where a > 0
is some constant. In this case we receive a benefit in the second objective, i.e., a
reduction in F2 compared to F2(x). If this benefit is large (i.e., by increasing F1
a small amount we obtain a large reduction in F2), we say the objectives exhibit
a strong trade-off. If it is small, we say the objectives trade off weakly (near the
Pareto optimal value (F1(x), F2(x))).

Optimal trade-off surface

The set of Pareto optimal values for a multicriterion problem is called the optimal
trade-off surface (in general, when q > 2) or the optimal trade-off curve (when
q = 2). (Since it would be foolish to accept any point that is not Pareto optimal,
we can restrict our trade-off analysis to Pareto optimal points.) Trade-off analysis
is also sometimes called exploring the optimal trade-off surface. (The optimal trade-
off surface is usually, but not always, a surface in the usual sense. If the problem
has an optimal point, for example, the optimal trade-off surface consists of a single
point, the optimal value.)

An optimal trade-off curve is readily interpreted. An example is shown in
figure 4.11, on page 185, for a (convex) bi-criterion problem. From this curve we
can easily visualize and understand the trade-offs between the two objectives.

• The endpoint at the right shows the smallest possible value of F2, without
any consideration of F1.

• The endpoint at the left shows the smallest possible value of F1, without any
consideration of F2.

• By finding the intersection of the curve with a vertical line at F1 = α, we can
see how large F2 must be to achieve F1 ≤ α.

• By finding the intersection of the curve with a horizontal line at F2 = β, we
can see how large F1 must be to achieve F2 ≤ β.

• The slope of the optimal trade-off curve at a point on the curve (i.e., a Pareto
optimal value) shows the local optimal trade-off between the two objectives.
Where the slope is steep, small changes in F1 are accompanied by large
changes in F2.

• A point of large curvature is one where small decreases in one objective can
only be accomplished by a large increase in the other. This is the prover-
bial knee of the trade-off curve, and in many applications represents a good
compromise solution.

All of these have simple extensions to a trade-off surface, although visualizing a
surface with more than three objectives is difficult.

Scalarizing multicriterion problems

When we scalarize a multicriterion problem by forming the weighted sum objective

λT f0(x) =

q∑
i=1

λiFi(x),



184 4 Convex optimization problems

where λ ≻ 0, we can interpret λi as the weight we attach to the ith objective.
The weight λi can be thought of as quantifying our desire to make Fi small (or
our objection to having Fi large). In particular, we should take λi large if we
want Fi to be small; if we care much less about Fi, we can take λi small. We can
interpret the ratio λi/λj as the relative weight or relative importance of the ith
objective compared to the jth objective. Alternatively, we can think of λi/λj as
exchange rate between the two objectives, since in the weighted sum objective a
decrease (say) in Fi by α is considered the same as an increase in Fj in the amount
(λi/λj)α.

These interpretations give us some intuition about how to set or change the
weights while exploring the optimal trade-off surface. Suppose, for example, that
the weight vector λ ≻ 0 yields the Pareto optimal point xpo, with objective values
F1(x

po), . . . , Fq(x
po). To find a (possibly) new Pareto optimal point which trades

off a better kth objective value (say), for (possibly) worse objective values for the
other objectives, we form a new weight vector λ˜ with

λ˜k > λk, λ˜j = λj , j 6= k, j = 1, . . . , q,

i.e., we increase the weight on the kth objective. This yields a new Pareto optimal
point x˜po with Fk(x˜

po) ≤ Fk(xpo) (and usually, Fk(x˜po) < Fk(xpo)), i.e., a new
Pareto optimal point with an improved kth objective.

We can also see that at any point where the optimal trade-off surface is smooth,
λ gives the inward normal to the surface at the associated Pareto optimal point.
In particular, when we choose a weight vector λ and apply scalarization, we obtain
a Pareto optimal point where λ gives the local trade-offs among objectives.

In practice, optimal trade-off surfaces are explored by ad hoc adjustment of the
weights, based on the intuitive ideas above. We will see later (in chapter 5) that
the basic idea of scalarization, i.e., minimizing a weighted sum of objectives, and
then adjusting the weights to obtain a suitable solution, is the essence of duality.

4.7.6 Examples

Regularized least-squares

We are given A ∈ Rm×n and b ∈ Rm, and want to choose x ∈ Rn taking into
account two quadratic objectives:

• F1(x) = ‖Ax − b‖22 = xTATAx − 2bTAx + bT b is a measure of the misfit
between Ax and b,

• F2(x) = ‖x‖22 = xTx is a measure of the size of x.

Our goal is to find x that gives a good fit (i.e., small F1) and that is not large (i.e.,
small F2). We can formulate this problem as a vector optimization problem with
respect to the cone R2+, i.e., a bi-criterion problem (with no constraints):

minimize (w.r.t. R2+) f0(x) = (F1(x), F2(x)).



4.7 Vector optimization 185

F1(x) = ‖Ax− b‖22

F
2
(x
)
=
‖x
‖2 2

0 5 10 15
0

5

10

15

Figure 4.11 Optimal trade-off curve for a regularized least-squares problem.
The shaded set is the set of achievable values (‖Ax−b‖22, ‖x‖22). The optimal
trade-off curve, shown darker, is the lower left part of the boundary.

We can scalarize this problem by taking λ1 > 0 and λ2 > 0 and minimizing the
scalar weighted sum objective

λT f0(x) = λ1F1(x) + λ2F2(x)

= xT (λ1A
TA+ λ2I)x− 2λ1bTAx+ λ1bT b,

which yields

x(µ) = (λ1A
TA+ λ2I)

−1λ1A
T b = (ATA+ µI)−1AT b,

where µ = λ2/λ1. For any µ > 0, this point is Pareto optimal for the bi-criterion
problem. We can interpret µ = λ2/λ1 as the relative weight we assign F2 compared
to F1.

This method produces all Pareto optimal points, except two, associated with
the extremes µ → ∞ and µ → 0. In the first case we have the Pareto optimal
solution x = 0, which would be obtained by scalarization with λ = (0, 1). At the
other extreme we have the Pareto optimal solution A†b, where A† is the pseudo-
inverse of A. This Pareto optimal solution is obtained as the limit of the optimal
solution of the scalarized problem as µ→ 0, i.e., as λ→ (1, 0). (We will encounter
the regularized least-squares problem again in §6.3.2.)

Figure 4.11 shows the optimal trade-off curve and the set of achievable values
for a regularized least-squares problem with problem data A ∈ R100×10, b ∈ R100.
(See exercise 4.50 for more discussion.)

Risk-return trade-off in portfolio optimization

The classical Markowitz portfolio optimization problem described on page 155 is
naturally expressed as a bi-criterion problem, where the objectives are the negative



186 4 Convex optimization problems

mean return (since we wish to maximize mean return) and the variance of the
return:

minimize (w.r.t. R2+) (F1(x), F2(x)) = (−pTx, xTΣx)
subject to 1Tx = 1, x � 0.

In forming the associated scalarized problem, we can (without loss of generality)
take λ1 = 1 and λ2 = µ > 0:

minimize −pTx+ µxTΣx
subject to 1Tx = 1, x � 0,

which is a QP. In this example too, we get all Pareto optimal portfolios except for
the two limiting cases corresponding to µ → 0 and µ → ∞. Roughly speaking, in
the first case we get a maximum mean return, without regard for return variance;
in the second case we form a minimum variance return, without regard for mean
return. Assuming that pk > pi for i 6= k, i.e., that asset k is the unique asset with
maximum mean return, the portfolio allocation x = ek is the only one correspond-
ing to µ → 0. (In other words, we concentrate the portfolio entirely in the asset
that has maximum mean return.) In many portfolio problems asset n corresponds
to a risk-free investment, with (deterministic) return rrf . Assuming that Σ, with its
last row and column (which are zero) removed, is full rank, then the other extreme
Pareto optimal portfolio is x = en, i.e., the portfolio is concentrated entirely in the
risk-free asset.

As a specific example, we consider a simple portfolio optimization problem with
4 assets, with price change mean and standard deviations given in the following
table.

Asset pi Σ
1/2
ii

1 12% 20%
2 10% 10%
3 7% 5%
4 3% 0%

Asset 4 is a risk-free asset, with a (certain) 3% return. Assets 3, 2, and 1 have
increasing mean returns, ranging from 7% to 12%, as well as increasing standard
deviations, which range from 5% to 20%. The correlation coefficients between the
assets are ρ12 = 30%, ρ13 = −40%, and ρ23 = 0%.

Figure 4.12 shows the optimal trade-off curve for this portfolio optimization
problem. The plot is given in the conventional way, with the horizontal axis show-
ing standard deviation (i.e., squareroot of variance) and the vertical axis showing
expected return. The lower plot shows the optimal asset allocation vector x for
each Pareto optimal point.

The results in this simple example agree with our intuition. For small risk,
the optimal allocation consists mostly of the risk-free asset, with a mixture of the
other assets in smaller quantities. Note that a mixture of asset 3 and asset 1, which
are negatively correlated, gives some hedging, i.e., lowers variance for a given level
of mean return. At the other end of the trade-off curve, we see that aggressive
growth portfolios (i.e., those with large mean returns) concentrate the allocation
in assets 1 and 2, the ones with the largest mean returns (and variances).



4.7 Vector optimization 187

m
ea
n
re
tu
rn

0% 10% 20%
0%

5%

10%

15%

standard deviation of return

al
lo
ca
ti
on

x(1)

x(2)x(3)x(4)

0% 10% 20%

0

0.5

1

Figure 4.12 Top. Optimal risk-return trade-off curve for a simple portfolio
optimization problem. The lefthand endpoint corresponds to putting all
resources in the risk-free asset, and so has zero standard deviation. The
righthand endpoint corresponds to putting all resources in asset 1, which
has highest mean return. Bottom. Corresponding optimal allocations.



188 4 Convex optimization problems

Bibliography

Linear programming has been studied extensively since the 1940s, and is the subject of
many excellent books, including Dantzig [Dan63], Luenberger [Lue84], Schrijver [Sch86],
Papadimitriou and Steiglitz [PS98], Bertsimas and Tsitsiklis [BT97], Vanderbei [Van96],
and Roos, Terlaky, and Vial [RTV97]. Dantzig and Schrijver also provide detailed ac-
counts of the history of linear programming. For a recent survey, see Todd [Tod02].

Schaible [Sch82, Sch83] gives an overview of fractional programming, which includes
linear-fractional problems and extensions such as convex-concave fractional problems (see
exercise 4.7). The model of a growing economy in example 4.7 appears in von Neumann
[vN46].

Research on quadratic programming began in the 1950s (see, e.g., Frank and Wolfe
[FW56], Markowitz [Mar56], Hildreth [Hil57]), and was in part motivated by the portfo-
lio optimization problem discussed on page 155 (Markowitz [Mar52]), and the LP with
random cost discussed on page 154 (see Freund [Fre56]).

Interest in second-order cone programming is more recent, and started with Nesterov
and Nemirovski [NN94, §6.2.3]. The theory and applications of SOCPs are surveyed by
Alizadeh and Goldfarb [AG03], Ben-Tal and Nemirovski [BTN01, lecture 3] (where the
problem is referred to as conic quadratic programming), and Lobo, Vandenberghe, Boyd,
and Lebret [LVBL98].

Robust linear programming, and robust convex optimization in general, originated with
Ben-Tal and Nemirovski [BTN98, BTN99] and El Ghaoui and Lebret [EL97]. Goldfarb
and Iyengar [GI03a, GI03b] discuss robust QCQPs and applications in portfolio optimiza-
tion. El Ghaoui, Oustry, and Lebret [EOL98] focus on robust semidefinite programming.

Geometric programming has been known since the 1960s. Its use in engineering design
was first advocated by Duffin, Peterson, and Zener [DPZ67] and Zener [Zen71]. Peterson
[Pet76] and Ecker [Eck80] describe the progress made during the 1970s. These articles
and books also include examples of engineering applications, in particular in chemical
and civil engineering. Fishburn and Dunlop [FD85], Sapatnekar, Rao, Vaidya, and Kang
[SRVK93], and Hershenson, Boyd, and Lee [HBL01]) apply geometric programming to
problems in integrated circuit design. The cantilever beam design example (page 163)
is from Vanderplaats [Van84, page 147]. The variational characterization of the Perron-
Frobenius eigenvalue (page 165) is proved in Berman and Plemmons [BP94, page 31].

Nesterov and Nemirovski [NN94, chapter 4] introduced the conic form problem (4.49)
as a standard problem format in nonlinear convex optimization. The cone programming
approach is further developed in Ben-Tal and Nemirovski [BTN01], who also describe
numerous applications.

Alizadeh [Ali91] and Nesterov and Nemirovski [NN94, §6.4] were the first to make a
systematic study of semidefinite programming, and to point out the wide variety of
applications in convex optimization. Subsequent research in semidefinite programming
during the 1990s was driven by applications in combinatorial optimization (Goemans
and Williamson [GW95]), control (Boyd, El Ghaoui, Feron, and Balakrishnan [BEFB94],
Scherer, Gahinet, and Chilali [SGC97], Dullerud and Paganini [DP00]), communications
and signal processing (Luo [Luo03], Davidson, Luo, Wong, and Ma [DLW00, MDW+02]),
and other areas of engineering. The book edited by Wolkowicz, Saigal, and Vandenberghe
[WSV00] and the articles by Todd [Tod01], Lewis and Overton [LO96], and Vandenberghe
and Boyd [VB95] provide overviews and extensive bibliographies. Connections between
SDP and moment problems, of which we give a simple example on page 170, are explored
in detail by Bertsimas and Sethuraman [BS00], Nesterov [Nes00], and Lasserre [Las02].
The fastest mixing Markov chain problem is from Boyd, Diaconis, and Xiao [BDX04].

Multicriterion optimization and Pareto optimality are fundamental tools in economics;
see Pareto [Par71], Debreu [Deb59] and Luenberger [Lue95]. The result in example 4.9 is
known as the Gauss-Markov theorem (Kailath, Sayed, and Hassibi [KSH00, page 97]).



Exercises 189

Exercises

Basic terminology and optimality conditions

4.1 Consider the optimization problem

minimize f0(x1, x2)
subject to 2x1 + x2 ≥ 1

x1 + 3x2 ≥ 1
x1 ≥ 0, x2 ≥ 0.

Make a sketch of the feasible set. For each of the following objective functions, give the
optimal set and the optimal value.

(a) f0(x1, x2) = x1 + x2.

(b) f0(x1, x2) = −x1 − x2.
(c) f0(x1, x2) = x1.

(d) f0(x1, x2) = max{x1, x2}.
(e) f0(x1, x2) = x

2
1 + 9x

2
2.

4.2 Consider the optimization problem

minimize f0(x) = −
∑m

i=1
log(bi − aTi x)

with domain dom f0 = {x | Ax ≺ b}, where A ∈ Rm×n (with rows aTi ). We assume that
dom f0 is nonempty.

Prove the following facts (which include the results quoted without proof on page 141).

(a) dom f0 is unbounded if and only if there exists a v 6= 0 with Av � 0.
(b) f0 is unbounded below if and only if there exists a v with Av � 0, Av 6= 0. Hint.

There exists a v such that Av � 0, Av 6= 0 if and only if there exists no z ≻ 0
such that AT z = 0. This follows from the theorem of alternatives in example 2.21,
page 50.

(c) If f0 is bounded below then its minimum is attained, i.e., there exists an x that
satisfies the optimality condition (4.23).

(d) The optimal set is affine: Xopt = {x⋆ + v | Av = 0}, where x⋆ is any optimal point.
4.3 Prove that x⋆ = (1, 1/2,−1) is optimal for the optimization problem

minimize (1/2)xTPx+ qTx+ r
subject to −1 ≤ xi ≤ 1, i = 1, 2, 3,

where

P =

[
13 12 −2
12 17 6
−2 6 12

]
, q =

[ −22.0
−14.5
13.0

]
, r = 1.

4.4 [P. Parrilo] Symmetries and convex optimization. Suppose G = {Q1, . . . , Qk} ⊆ Rn×n is a
group, i.e., closed under products and inverse. We say that the function f : Rn → R is G-
invariant, or symmetric with respect to G, if f(Qix) = f(x) holds for all x and i = 1, . . . , k.
We define x = (1/k)

∑k
i=1

Qix, which is the average of x over its G-orbit. We define the
fixed subspace of G as

F = {x | Qix = x, i = 1, . . . , k}.
(a) Show that for any x ∈ Rn, we have x ∈ F .



190 4 Convex optimization problems

(b) Show that if f : Rn → R is convex and G-invariant, then f(x) ≤ f(x).
(c) We say the optimization problem

minimize f0(x)
subject to fi(x) ≤ 0, i = 1, . . . ,m

is G-invariant if the objective f0 is G-invariant, and the feasible set is G-invariant,
which means

f1(x) ≤ 0, . . . , fm(x) ≤ 0 =⇒ f1(Qix) ≤ 0, . . . , fm(Qix) ≤ 0,

for i = 1, . . . , k. Show that if the problem is convex and G-invariant, and there exists
an optimal point, then there exists an optimal point in F . In other words, we can
adjoin the equality constraints x ∈ F to the problem, without loss of generality.

(d) As an example, suppose f is convex and symmetric, i.e., f(Px) = f(x) for every
permutation P . Show that if f has a minimizer, then it has a minimizer of the form
α1. (This means to minimize f over x ∈ Rn, we can just as well minimize f(t1)
over t ∈ R.)

4.5 Equivalent convex problems. Show that the following three convex problems are equiva-
lent. Carefully explain how the solution of each problem is obtained from the solution of
the other problems. The problem data are the matrix A ∈ Rm×n (with rows aTi ), the
vector b ∈ Rm, and the constant M > 0.

(a) The robust least-squares problem

minimize
∑m

i=1
φ(aTi x− bi),

with variable x ∈ Rn, where φ : R→ R is defined as

φ(u) =

{
u2 |u| ≤M
M(2|u| −M) |u| > M.

(This function is known as the Huber penalty function; see §6.1.2.)
(b) The least-squares problem with variable weights

minimize
∑m

i=1
(aTi x− bi)2/(wi + 1) +M21Tw

subject to w � 0,

with variables x ∈ Rn and w ∈ Rm, and domain D = {(x,w) ∈ Rn×Rm | w ≻ −1}.
Hint. Optimize over w assuming x is fixed, to establish a relation with the problem
in part (a).

(This problem can be interpreted as a weighted least-squares problem in which we
are allowed to adjust the weight of the ith residual. The weight is one if wi = 0, and
decreases if we increase wi. The second term in the objective penalizes large values
of w, i.e., large adjustments of the weights.)

(c) The quadratic program

minimize
∑m

i=1
(u2i + 2Mvi)

subject to −u− v � Ax− b � u+ v
0 � u �M1
v � 0.



Exercises 191

4.6 Handling convex equality constraints. A convex optimization problem can have only linear
equality constraint functions. In some special cases, however, it is possible to handle
convex equality constraint functions, i.e., constraints of the form h(x) = 0, where h is
convex. We explore this idea in this problem.

Consider the optimization problem

minimize f0(x)
subject to fi(x) ≤ 0, i = 1, . . . ,m

h(x) = 0,
(4.65)

where fi and h are convex functions with domain R
n. Unless h is affine, this is not a

convex optimization problem. Consider the related problem

minimize f0(x)
subject to fi(x) ≤ 0, i = 1, . . . ,m,

h(x) ≤ 0,
(4.66)

where the convex equality constraint has been relaxed to a convex inequality. This prob-
lem is, of course, convex.

Now suppose we can guarantee that at any optimal solution x⋆ of the convex prob-
lem (4.66), we have h(x⋆) = 0, i.e., the inequality h(x) ≤ 0 is always active at the solution.
Then we can solve the (nonconvex) problem (4.65) by solving the convex problem (4.66).

Show that this is the case if there is an index r such that

• f0 is monotonically increasing in xr
• f1, . . . , fm are nondecreasing in xr
• h is monotonically decreasing in xr.

We will see specific examples in exercises 4.31 and 4.58.

4.7 Convex-concave fractional problems. Consider a problem of the form

minimize f0(x)/(c
Tx+ d)

subject to fi(x) ≤ 0, i = 1, . . . ,m
Ax = b

where f0, f1, . . . , fm are convex, and the domain of the objective function is defined as
{x ∈ dom f0 | cTx+ d > 0}.
(a) Show that this is a quasiconvex optimization problem.

(b) Show that the problem is equivalent to

minimize g0(y, t)
subject to gi(y, t) ≤ 0, i = 1, . . . ,m

Ay = bt
cT y + dt = 1,

where gi is the perspective of fi (see §3.2.6). The variables are y ∈ Rn and t ∈ R.
Show that this problem is convex.

(c) Following a similar argument, derive a convex formulation for the convex-concave
fractional problem

minimize f0(x)/h(x)
subject to fi(x) ≤ 0, i = 1, . . . ,m

Ax = b



192 4 Convex optimization problems

where f0, f1, . . . , fm are convex, h is concave, the domain of the objective function
is defined as {x ∈ dom f0 ∩ domh | h(x) > 0} and f0(x) ≥ 0 everywhere.
As an example, apply your technique to the (unconstrained) problem with

f0(x) = (trF (x))/m, h(x) = (det(F (x))
1/m,

with dom(f0/h) = {x | F (x) ≻ 0}, where F (x) = F0 + x1F1 + · · ·+ xnFn for given
Fi ∈ Sm. In this problem, we minimize the ratio of the arithmetic mean over the
geometric mean of the eigenvalues of an affine matrix function F (x).

Linear optimization problems

4.8 Some simple LPs. Give an explicit solution of each of the following LPs.

(a) Minimizing a linear function over an affine set.

minimize cTx
subject to Ax = b.

(b) Minimizing a linear function over a halfspace.

minimize cTx
subject to aTx ≤ b,

where a 6= 0.
(c) Minimizing a linear function over a rectangle.

minimize cTx
subject to l � x � u,

where l and u satisfy l � u.
(d) Minimizing a linear function over the probability simplex.

minimize cTx
subject to 1Tx = 1, x � 0.

What happens if the equality constraint is replaced by an inequality 1Tx ≤ 1?
We can interpret this LP as a simple portfolio optimization problem. The vector
x represents the allocation of our total budget over different assets, with xi the
fraction invested in asset i. The return of each investment is fixed and given by −ci,
so our total return (which we want to maximize) is −cTx. If we replace the budget
constraint 1Tx = 1 with an inequality 1Tx ≤ 1, we have the option of not investing
a portion of the total budget.

(e) Minimizing a linear function over a unit box with a total budget constraint.

minimize cTx
subject to 1Tx = α, 0 � x � 1,

where α is an integer between 0 and n. What happens if α is not an integer (but
satisfies 0 ≤ α ≤ n)? What if we change the equality to an inequality 1Tx ≤ α?

(f) Minimizing a linear function over a unit box with a weighted budget constraint.

minimize cTx
subject to dTx = α, 0 � x � 1,

with d ≻ 0, and 0 ≤ α ≤ 1T d.



Exercises 193

4.9 Square LP. Consider the LP
minimize cTx
subject to Ax � b

with A square and nonsingular. Show that the optimal value is given by

p⋆ =

{
cTA−1b A−T c � 0
−∞ otherwise.

4.10 Converting general LP to standard form. Work out the details on page 147 of §4.3.
Explain in detail the relation between the feasible sets, the optimal solutions, and the
optimal values of the standard form LP and the original LP.

4.11 Problems involving ℓ1- and ℓ∞-norms. Formulate the following problems as LPs. Explain
in detail the relation between the optimal solution of each problem and the solution of its
equivalent LP.

(a) Minimize ‖Ax− b‖∞ (ℓ∞-norm approximation).
(b) Minimize ‖Ax− b‖1 (ℓ1-norm approximation).
(c) Minimize ‖Ax− b‖1 subject to ‖x‖∞ ≤ 1.
(d) Minimize ‖x‖1 subject to ‖Ax− b‖∞ ≤ 1.
(e) Minimize ‖Ax− b‖1 + ‖x‖∞.

In each problem, A ∈ Rm×n and b ∈ Rm are given. (See §6.1 for more problems involving
approximation and constrained approximation.)

4.12 Network flow problem. Consider a network of n nodes, with directed links connecting each
pair of nodes. The variables in the problem are the flows on each link: xij will denote the
flow from node i to node j. The cost of the flow along the link from node i to node j is
given by cijxij , where cij are given constants. The total cost across the network is

C =

n∑
i,j=1

cijxij .

Each link flow xij is also subject to a given lower bound lij (usually assumed to be
nonnegative) and an upper bound uij .

The external supply at node i is given by bi, where bi > 0 means an external flow enters
the network at node i, and bi < 0 means that at node i, an amount |bi| flows out of the
network. We assume that 1T b = 0, i.e., the total external supply equals total external
demand. At each node we have conservation of flow: the total flow into node i along links
and the external supply, minus the total flow out along the links, equals zero.

The problem is to minimize the total cost of flow through the network, subject to the
constraints described above. Formulate this problem as an LP.

4.13 Robust LP with interval coefficients. Consider the problem, with variable x ∈ Rn,
minimize cTx
subject to Ax � b for all A ∈ A,

where A ⊆ Rm×n is the set
A = {A ∈ Rm×n | A¯ij − Vij ≤ Aij ≤ A¯ij + Vij , i = 1, . . . ,m, j = 1, . . . , n}.

(The matrices A¯ and V are given.) This problem can be interpreted as an LP where each
coefficient of A is only known to lie in an interval, and we require that x must satisfy the
constraints for all possible values of the coefficients.

Express this problem as an LP. The LP you construct should be efficient, i.e., it should
not have dimensions that grow exponentially with n or m.



194 4 Convex optimization problems

4.14 Approximating a matrix in infinity norm. The ℓ∞-norm induced norm of a matrix A ∈
Rm×n, denoted ‖A‖∞, is given by

‖A‖∞ = sup
x 6=0

‖Ax‖∞
‖x‖∞ = maxi=1,...,m

n∑
j=1

|aij |.

This norm is sometimes called the max-row-sum norm, for obvious reasons (see §A.1.5).
Consider the problem of approximating a matrix, in the max-row-sum norm, by a linear
combination of other matrices. That is, we are given k+1 matrices A0, . . . , Ak ∈ Rm×n,
and need to find x ∈ Rk that minimizes

‖A0 + x1A1 + · · ·+ xkAk‖∞.

Express this problem as a linear program. Explain the significance of any extra variables
in your LP. Carefully explain how your LP formulation solves this problem, e.g., what is
the relation between the feasible set for your LP and this problem?

4.15 Relaxation of Boolean LP. In a Boolean linear program, the variable x is constrained to
have components equal to zero or one:

minimize cTx
subject to Ax � b

xi ∈ {0, 1}, i = 1, . . . , n.
(4.67)

In general, such problems are very difficult to solve, even though the feasible set is finite
(containing at most 2n points).

In a general method called relaxation, the constraint that xi be zero or one is replaced
with the linear inequalities 0 ≤ xi ≤ 1:

minimize cTx
subject to Ax � b

0 ≤ xi ≤ 1, i = 1, . . . , n.
(4.68)

We refer to this problem as the LP relaxation of the Boolean LP (4.67). The LP relaxation
is far easier to solve than the original Boolean LP.

(a) Show that the optimal value of the LP relaxation (4.68) is a lower bound on the
optimal value of the Boolean LP (4.67). What can you say about the Boolean LP
if the LP relaxation is infeasible?

(b) It sometimes happens that the LP relaxation has a solution with xi ∈ {0, 1}. What
can you say in this case?

4.16 Minimum fuel optimal control. We consider a linear dynamical system with state x(t) ∈
Rn, t = 0, . . . , N , and actuator or input signal u(t) ∈ R, for t = 0, . . . , N − 1. The
dynamics of the system is given by the linear recurrence

x(t+ 1) = Ax(t) + bu(t), t = 0, . . . , N − 1,
where A ∈ Rn×n and b ∈ Rn are given. We assume that the initial state is zero, i.e.,
x(0) = 0.

The minimum fuel optimal control problem is to choose the inputs u(0), . . . , u(N − 1) so
as to minimize the total fuel consumed, which is given by

F =

N−1∑
t=0

f(u(t)),



Exercises 195

subject to the constraint that x(N) = xdes, where N is the (given) time horizon, and
xdes ∈ Rn is the (given) desired final or target state. The function f : R→ R is the fuel
use map for the actuator, and gives the amount of fuel used as a function of the actuator
signal amplitude. In this problem we use

f(a) =

{
|a| |a| ≤ 1
2|a| − 1 |a| > 1.

This means that fuel use is proportional to the absolute value of the actuator signal, for
actuator signals between −1 and 1; for larger actuator signals the marginal fuel efficiency
is half.

Formulate the minimum fuel optimal control problem as an LP.

4.17 Optimal activity levels. We consider the selection of n nonnegative activity levels, denoted
x1, . . . , xn. These activities consume m resources, which are limited. Activity j consumes
Aijxj of resource i, where Aij are given. The total resource consumption is additive, so
the total of resource i consumed is ci =

∑n
j=1

Aijxj . (Ordinarily we have Aij ≥ 0, i.e.,
activity j consumes resource i. But we allow the possibility that Aij < 0, which means
that activity j actually generates resource i as a by-product.) Each resource consumption
is limited: we must have ci ≤ cmaxi , where cmaxi are given. Each activity generates revenue,
which is a piecewise-linear concave function of the activity level:

rj(xj) =

{
pjxj 0 ≤ xj ≤ qj
pjqj + p

disc
j (xj − qj) xj ≥ qj .

Here pj > 0 is the basic price, qj > 0 is the quantity discount level, and p
disc
j is the

quantity discount price, for (the product of) activity j. (We have 0 < pdiscj < pj .) The

total revenue is the sum of the revenues associated with each activity, i.e.,
∑n

j=1
rj(xj).

The goal is to choose activity levels that maximize the total revenue while respecting the
resource limits. Show how to formulate this problem as an LP.

4.18 Separating hyperplanes and spheres. Suppose you are given two sets of points in Rn,
{v1, v2, . . . , vK} and {w1, w2, . . . , wL}. Formulate the following two problems as LP fea-
sibility problems.

(a) Determine a hyperplane that separates the two sets, i.e., find a ∈ Rn and b ∈ R
with a 6= 0 such that

aT vi ≤ b, i = 1, . . . ,K, aTwi ≥ b, i = 1, . . . , L.

Note that we require a 6= 0, so you have to make sure that your formulation excludes
the trivial solution a = 0, b = 0. You can assume that

rank

[
v1 v2 · · · vK w1 w2 · · · wL
1 1 · · · 1 1 1 · · · 1

]
= n+ 1

(i.e., the affine hull of the K + L points has dimension n).

(b) Determine a sphere separating the two sets of points, i.e., find xc ∈ Rn and R ≥ 0
such that

‖vi − xc‖2 ≤ R, i = 1, . . . ,K, ‖wi − xc‖2 ≥ R, i = 1, . . . , L.

(Here xc is the center of the sphere; R is its radius.)

(See chapter 8 for more on separating hyperplanes, separating spheres, and related topics.)



196 4 Convex optimization problems

4.19 Consider the problem
minimize ‖Ax− b‖1/(cTx+ d)
subject to ‖x‖∞ ≤ 1,

where A ∈ Rm×n, b ∈ Rm, c ∈ Rn, and d ∈ R. We assume that d > ‖c‖1, which implies
that cTx+ d > 0 for all feasible x.

(a) Show that this is a quasiconvex optimization problem.

(b) Show that it is equivalent to the convex optimization problem

minimize ‖Ay − bt‖1
subject to ‖y‖∞ ≤ t

cT y + dt = 1,

with variables y ∈ Rn, t ∈ R.
4.20 Power assignment in a wireless communication system. We consider n transmitters with

powers p1, . . . , pn ≥ 0, transmitting to n receivers. These powers are the optimization
variables in the problem. We let G ∈ Rn×n denote the matrix of path gains from the
transmitters to the receivers; Gij ≥ 0 is the path gain from transmitter j to receiver i.
The signal power at receiver i is then Si = Giipi, and the interference power at receiver i
is Ii =

∑
k 6=i

Gikpk. The signal to interference plus noise ratio, denoted SINR, at receiver

i, is given by Si/(Ii + σi), where σi > 0 is the (self-) noise power in receiver i. The
objective in the problem is to maximize the minimum SINR ratio, over all receivers, i.e.,
to maximize

min
i=1,...,n

Si
Ii + σi

.

There are a number of constraints on the powers that must be satisfied, in addition to the
obvious one pi ≥ 0. The first is a maximum allowable power for each transmitter, i.e.,
pi ≤ Pmaxi , where Pmaxi > 0 is given. In addition, the transmitters are partitioned into
groups, with each group sharing the same power supply, so there is a total power constraint
for each group of transmitter powers. More precisely, we have subsets K1, . . . ,Km of
{1, . . . , n} with K1 ∪ · · · ∪Km = {1, . . . , n}, and Kj ∩Kl = 0 if j 6= l. For each group Kl,
the total associated transmitter power cannot exceed P gpl > 0:∑

k∈Kl

pk ≤ P gpl , l = 1, . . . ,m.

Finally, we have a limit P rck > 0 on the total received power at each receiver:

n∑
k=1

Gikpk ≤ P rci , i = 1, . . . , n.

(This constraint reflects the fact that the receivers will saturate if the total received power
is too large.)

Formulate the SINR maximization problem as a generalized linear-fractional program.

Quadratic optimization problems

4.21 Some simple QCQPs. Give an explicit solution of each of the following QCQPs.

(a) Minimizing a linear function over an ellipsoid centered at the origin.

minimize cTx
subject to xTAx ≤ 1,

where A ∈ Sn++ and c 6= 0. What is the solution if the problem is not convex
(A 6∈ Sn+)?



Exercises 197

(b) Minimizing a linear function over an ellipsoid.

minimize cTx
subject to (x− xc)TA(x− xc) ≤ 1,

where A ∈ Sn++ and c 6= 0.
(c) Minimizing a quadratic form over an ellipsoid centered at the origin.

minimize xTBx
subject to xTAx ≤ 1,

where A ∈ Sn++ and B ∈ Sn+. Also consider the nonconvex extension with B 6∈ Sn+.
(See §B.1.)

4.22 Consider the QCQP
minimize (1/2)xTPx+ qTx+ r
subject to xTx ≤ 1,

with P ∈ Sn++. Show that x⋆ = −(P + λI)−1q where λ = max{0, λ¯} and λ¯ is the largest
solution of the nonlinear equation

qT (P + λI)−2q = 1.

4.23 ℓ4-norm approximation via QCQP. Formulate the ℓ4-norm approximation problem

minimize ‖Ax− b‖4 = (
∑m

i=1
(aTi x− bi)4)1/4

as a QCQP. The matrix A ∈ Rm×n (with rows aTi ) and the vector b ∈ Rm are given.
4.24 Complex ℓ1-, ℓ2- and ℓ∞-norm approximation. Consider the problem

minimize ‖Ax− b‖p,
where A ∈ Cm×n, b ∈ Cm, and the variable is x ∈ Cn. The complex ℓp-norm is defined
by

‖y‖p =
(

m∑
i=1

|yi|p
)1/p

for p ≥ 1, and ‖y‖∞ = maxi=1,...,m |yi|. For p = 1, 2, and∞, express the complex ℓp-norm
approximation problem as a QCQP or SOCP with real variables and data.

4.25 Linear separation of two sets of ellipsoids. Suppose we are given K + L ellipsoids

Ei = {Piu+ qi | ‖u‖2 ≤ 1}, i = 1, . . . ,K + L,
where Pi ∈ Sn. We are interested in finding a hyperplane that strictly separates E1, . . . ,
EK from EK+1, . . . , EK+L, i.e., we want to compute a ∈ Rn, b ∈ R such that

aTx+ b > 0 for x ∈ E1 ∪ · · · ∪ EK , aTx+ b < 0 for x ∈ EK+1 ∪ · · · ∪ EK+L,
or prove that no such hyperplane exists. Express this problem as an SOCP feasibility
problem.

4.26 Hyperbolic constraints as SOC constraints. Verify that x ∈ Rn, y, z ∈ R satisfy
xTx ≤ yz, y ≥ 0, z ≥ 0

if and only if ∥∥∥∥[ 2xy − z
]∥∥∥∥

2

≤ y + z, y ≥ 0, z ≥ 0.

Use this observation to cast the following problems as SOCPs.



198 4 Convex optimization problems

(a) Maximizing harmonic mean.

maximize
(∑m

i=1
1/(aTi x− bi)

)−1
,

with domain {x | Ax ≻ b}, where aTi is the ith row of A.
(b) Maximizing geometric mean.

maximize
(∏m

i=1
(aTi x− bi)

)1/m
,

with domain {x | Ax � b}, where aTi is the ith row of A.
4.27 Matrix fractional minimization via SOCP. Express the following problem as an SOCP:

minimize (Ax+ b)T (I +B diag(x)BT )−1(Ax+ b)
subject to x � 0,

with A ∈ Rm×n, b ∈ Rm, B ∈ Rm×n. The variable is x ∈ Rn.
Hint. First show that the problem is equivalent to

minimize vT v + wT diag(x)−1w
subject to v +Bw = Ax+ b

x � 0,

with variables v ∈ Rm, w, x ∈ Rn. (If xi = 0 we interpret w2i /xi as zero if wi = 0 and as
∞ otherwise.) Then use the results of exercise 4.26.

4.28 Robust quadratic programming. In §4.4.2 we discussed robust linear programming as an
application of second-order cone programming. In this problem we consider a similar
robust variation of the (convex) quadratic program

minimize (1/2)xTPx+ qTx+ r
subject to Ax � b.

For simplicity we assume that only the matrix P is subject to errors, and the other
parameters (q, r, A, b) are exactly known. The robust quadratic program is defined as

minimize supP∈E((1/2)x
TPx+ qTx+ r)

subject to Ax � b
where E is the set of possible matrices P .
For each of the following sets E , express the robust QP as a convex problem. Be as specific
as you can. If the problem can be expressed in a standard form (e.g., QP, QCQP, SOCP,
SDP), say so.

(a) A finite set of matrices: E = {P1, . . . , PK}, where Pi ∈ Sn+, i = 1, . . . ,K.
(b) A set specified by a nominal value P0 ∈ Sn+ plus a bound on the eigenvalues of the

deviation P − P0:
E = {P ∈ Sn | −γI � P − P0 � γI}

where γ ∈ R and P0 ∈ Sn+,
(c) An ellipsoid of matrices:

E =
{
P0 +

K∑
i=1

Piui

∣∣∣∣∣ ‖u‖2 ≤ 1
}
.

You can assume Pi ∈ Sn+, i = 0, . . . ,K.



Exercises 199

4.29 Maximizing probability of satisfying a linear inequality. Let c be a random variable in Rn,
normally distributed with mean c¯ and covariance matrix R. Consider the problem

maximize prob(cTx ≥ α)
subject to Fx � g, Ax = b.

Assuming there exists a feasible point x˜ for which c¯T x˜ ≥ α, show that this problem is
equivalent to a convex or quasiconvex optimization problem. Formulate the problem as a
QP, QCQP, or SOCP (if the problem is convex), or explain how you can solve it by solving
a sequence of QP, QCQP, or SOCP feasibility problems (if the problem is quasiconvex).

Geometric programming

4.30 A heated fluid at temperature T (degrees above ambient temperature) flows in a pipe
with fixed length and circular cross section with radius r. A layer of insulation, with
thickness w ≪ r, surrounds the pipe to reduce heat loss through the pipe walls. The
design variables in this problem are T , r, and w.

The heat loss is (approximately) proportional to Tr/w, so over a fixed lifetime, the energy
cost due to heat loss is given by α1Tr/w. The cost of the pipe, which has a fixed wall
thickness, is approximately proportional to the total material, i.e., it is given by α2r. The
cost of the insulation is also approximately proportional to the total insulation material,
i.e., α3rw (using w ≪ r). The total cost is the sum of these three costs.
The heat flow down the pipe is entirely due to the flow of the fluid, which has a fixed
velocity, i.e., it is given by α4Tr

2. The constants αi are all positive, as are the variables
T , r, and w.

Now the problem: maximize the total heat flow down the pipe, subject to an upper limit
Cmax on total cost, and the constraints

Tmin ≤ T ≤ Tmax, rmin ≤ r ≤ rmax, wmin ≤ w ≤ wmax, w ≤ 0.1r.
Express this problem as a geometric program.

4.31 Recursive formulation of optimal beam design problem. Show that the GP (4.46) is equiv-
alent to the GP

minimize
∑N

i=1
wihi

subject to wi/wmax ≤ 1, wmin/wi ≤ 1, i = 1, . . . , N
hi/hmax ≤ 1, hmin/hi ≤ 1, i = 1, . . . , N
hi/(wiSmax) ≤ 1, Sminwi/hi ≤ 1, i = 1, . . . , N
6iF/(σmaxwih

2
i ) ≤ 1, i = 1, . . . , N

(2i− 1)di/vi + vi+1/vi ≤ 1, i = 1, . . . , N
(i− 1/3)di/yi + vi+1/yi + yi+1/yi ≤ 1, i = 1, . . . , N
y1/ymax ≤ 1
Ewih

3
i di/(6F ) = 1, i = 1, . . . , N.

The variables are wi, hi, vi, di, yi for i = 1, . . . , N .

4.32 Approximating a function as a monomial. Suppose the function f : Rn → R is differ-
entiable at a point x0 ≻ 0, with f(x0) > 0. How would you find a monomial function
fˆ : Rn → R such that f(x0) = fˆ(x0) and for x near x0, fˆ(x) is very near f(x)?

4.33 Express the following problems as convex optimization problems.

(a) Minimize max{p(x), q(x)}, where p and q are posynomials.
(b) Minimize exp(p(x)) + exp(q(x)), where p and q are posynomials.

(c) Minimize p(x)/(r(x) − q(x)), subject to r(x) > q(x), where p, q are posynomials,
and r is a monomial.



200 4 Convex optimization problems

4.34 Log-convexity of Perron-Frobenius eigenvalue. Let A ∈ Rn×n be an elementwise positive
matrix, i.e., Aij > 0. (The results of this problem hold for irreducible nonnegative
matrices as well.) Let λpf(A) denotes its Perron-Frobenius eigenvalue, i.e., its eigenvalue
of largest magnitude. (See the definition and the example on page 165.) Show that
log λpf(A) is a convex function of logAij . This means, for example, that we have the
inequality

λpf(C) ≤ (λpf(A)λpf(B))1/2 ,
where Cij = (AijBij)

1/2, and A and B are elementwise positive matrices.

Hint. Use the characterization of the Perron-Frobenius eigenvalue given in (4.47), or,
alternatively, use the characterization

log λpf(A) = lim
k→∞

(1/k) log(1TAk1).

4.35 Signomial and geometric programs. A signomial is a linear combination of monomials of
some positive variables x1, . . . , xn. Signomials are more general than posynomials, which
are signomials with all positive coefficients. A signomial program is an optimization
problem of the form

minimize f0(x)
subject to fi(x) ≤ 0, i = 1, . . . ,m

hi(x) = 0, i = 1, . . . , p,

where f0, . . . , fm and h1, . . . , hp are signomials. In general, signomial programs are very
difficult to solve.

Some signomial programs can be transformed to GPs, and therefore solved efficiently.
Show how to do this for a signomial program of the following form:

• The objective signomial f0 is a posynomial, i.e., its terms have only positive coeffi-
cients.

• Each inequality constraint signomial f1, . . . , fm has exactly one term with a negative
coefficient: fi = pi − qi where pi is posynomial, and qi is monomial.

• Each equality constraint signomial h1, . . . , hp has exactly one term with a positive
coefficient and one term with a negative coefficient: hi = ri− si where ri and si are
monomials.

4.36 Explain how to reformulate a general GP as an equivalent GP in which every posynomial
(in the objective and constraints) has at most two monomial terms. Hint. Express each
sum (of monomials) as a sum of sums, each with two terms.

4.37 Generalized posynomials and geometric programming. Let x1, . . . , xn be positive variables,
and suppose the functions fi : R

n → R, i = 1, . . . , k, are posynomials of x1, . . . , xn. If
φ : Rk → R is a polynomial with nonnegative coefficients, then the composition

h(x) = φ(f1(x), . . . , fk(x)) (4.69)

is a posynomial, since posynomials are closed under products, sums, and multiplication
by nonnegative scalars. For example, suppose f1 and f2 are posynomials, and consider
the polynomial φ(z1, z2) = 3z

2
1z2 + 2z1 + 3z

3
2 (which has nonnegative coefficients). Then

h = 3f21 f2 + 2f1 + f
3
2 is a posynomial.

In this problem we consider a generalization of this idea, in which φ is allowed to be
a posynomial, i.e., can have fractional exponents. Specifically, assume that φ : Rk →
R is a posynomial, with all its exponents nonnegative. In this case we will call the
function h defined in (4.69) a generalized posynomial. As an example, suppose f1 and f2
are posynomials, and consider the posynomial (with nonnegative exponents) φ(z1, z2) =
2z0.31 z

1.2
2 + z1z

0.5
2 + 2. Then the function

h(x) = 2f1(x)
0.3f2(x)

1.2 + f1(x)f2(x)
0.5 + 2



Exercises 201

is a generalized posynomial. Note that it is not a posynomial, however (unless f1 and f2
are monomials or constants).

A generalized geometric program (GGP) is an optimization problem of the form

minimize h0(x)
subject to hi(x) ≤ 1, i = 1, . . . ,m

gi(x) = 1, i = 1, . . . , p,
(4.70)

where g1, . . . , gp are monomials, and h0, . . . , hm are generalized posynomials.

Show how to express this generalized geometric program as an equivalent geometric pro-
gram. Explain any new variables you introduce, and explain how your GP is equivalent
to the GGP (4.70).

Semidefinite programming and conic form problems

4.38 LMIs and SDPs with one variable. The generalized eigenvalues of a matrix pair (A,B),
where A,B ∈ Sn, are defined as the roots of the polynomial det(λB −A) (see §A.5.3).
Suppose B is nonsingular, and that A and B can be simultaneously diagonalized by a
congruence, i.e., there exists a nonsingular R ∈ Rn×n such that

RTAR = diag(a), RTBR = diag(b),

where a, b ∈ Rn. (A sufficient condition for this to hold is that there exists t1, t2 such
that t1A+ t2B ≻ 0.)
(a) Show that the generalized eigenvalues of (A,B) are real, and given by λi = ai/bi,

i = 1, . . . , n.

(b) Express the solution of the SDP

minimize ct
subject to tB � A,

with variable t ∈ R, in terms of a and b.
4.39 SDPs and congruence transformations. Consider the SDP

minimize cTx
subject to x1F1 + x2F2 + · · ·+ xnFn +G � 0,

with Fi, G ∈ Sk, c ∈ Rn.
(a) Suppose R ∈ Rk×k is nonsingular. Show that the SDP is equivalent to the SDP

minimize cTx

subject to x1F˜1 + x2F˜2 + · · ·+ xnF˜n + G˜ � 0,

where F˜i = R
TFiR, G˜ = R

TGR.

(b) Suppose there exists a nonsingular R such that F˜i and G˜ are diagonal. Show that
the SDP is equivalent to an LP.

(c) Suppose there exists a nonsingular R such that F˜i and G˜ have the form

F˜i =

[
αiI ai
aTi αi

]
, i = 1, . . . , n, G˜ =

[
βI b
bT β

]
,

where αi, β ∈ R, ai, b ∈ Rk−1. Show that the SDP is equivalent to an SOCP with
a single second-order cone constraint.



202 4 Convex optimization problems

4.40 LPs, QPs, QCQPs, and SOCPs as SDPs. Express the following problems as SDPs.

(a) The LP (4.27).

(b) The QP (4.34), the QCQP (4.35) and the SOCP (4.36). Hint. Suppose A ∈ Sr++,
C ∈ Ss, and B ∈ Rr×s. Then[

A B
BT C

]
� 0 ⇐⇒ C −BTA−1B � 0.

For a more complete statement, which applies also to singular A, and a proof,
see §A.5.5.

(c) The matrix fractional optimization problem

minimize (Ax+ b)TF (x)−1(Ax+ b)

where A ∈ Rm×n, b ∈ Rm,
F (x) = F0 + x1F1 + · · ·+ xnFn,

with Fi ∈ Sm, and we take the domain of the objective to be {x | F (x) ≻ 0}. You
can assume the problem is feasible (there exists at least one x with F (x) ≻ 0).

4.41 LMI tests for copositive matrices and P0-matrices. Amatrix A ∈ Sn is said to be copositive
if xTAx ≥ 0 for all x � 0 (see exercise 2.35). A matrix A ∈ Rn×n is said to be a P0-
matrix if maxi=1,...,n xi(Ax)i ≥ 0 for all x. Checking whether a matrix is copositive or
a P0-matrix is very difficult in general. However, there exist useful sufficient conditions
that can be verified using semidefinite programming.

(a) Show that A is copositive if it can be decomposed as a sum of a positive semidefinite
and an elementwise nonnegative matrix:

A = B + C, B � 0, Cij ≥ 0, i, j = 1, . . . , n. (4.71)
Express the problem of finding B and C that satisfy (4.71) as an SDP feasibility
problem.

(b) Show that A is a P0-matrix if there exists a positive diagonal matrix D such that

DA+ATD � 0. (4.72)
Express the problem of finding aD that satisfies (4.72) as an SDP feasibility problem.

4.42 Complex LMIs and SDPs. A complex LMI has the form

x1F1 + · · ·+ xnFn +G � 0
where F1, . . . , Fn, G are complex n× n Hermitian matrices, i.e., FHi = Fi, GH = G, and
x ∈ Rn is a real variable. A complex SDP is the problem of minimizing a (real) linear
function of x subject to a complex LMI constraint.

Complex LMIs and SDPs can be transformed to real LMIs and SDPs, using the fact that

X � 0 ⇐⇒
[
ℜX −ℑX
ℑX ℜX

]
� 0,

where ℜX ∈ Rn×n is the real part of the complex Hermitian matrix X, and ℑX ∈ Rn×n
is the imaginary part of X.

Verify this result, and show how to pose a complex SDP as a real SDP.



Exercises 203

4.43 Eigenvalue optimization via SDP. Suppose A : Rn → Sm is affine, i.e.,
A(x) = A0 + x1A1 + · · ·+ xnAn

where Ai ∈ Sm. Let λ1(x) ≥ λ2(x) ≥ · · · ≥ λm(x) denote the eigenvalues of A(x). Show
how to pose the following problems as SDPs.

(a) Minimize the maximum eigenvalue λ1(x).

(b) Minimize the spread of the eigenvalues, λ1(x)− λm(x).
(c) Minimize the condition number of A(x), subject to A(x) ≻ 0. The condition number

is defined as κ(A(x)) = λ1(x)/λm(x), with domain {x | A(x) ≻ 0}. You may assume
that A(x) ≻ 0 for at least one x.
Hint. You need to minimize λ/γ, subject to

0 ≺ γI � A(x) � λI.
Change variables to y = x/γ, t = λ/γ, s = 1/γ.

(d) Minimize the sum of the absolute values of the eigenvalues, |λ1(x)|+ · · ·+ |λm(x)|.
Hint. Express A(x) as A(x) = A+ −A−, where A+ � 0, A− � 0.

4.44 Optimization over polynomials. Pose the following problem as an SDP. Find the polyno-
mial p : R→ R,

p(t) = x1 + x2t+ · · ·+ x2k+1t2k,
that satisfies given bounds li ≤ p(ti) ≤ ui, at m specified points ti, and, of all the
polynomials that satisfy these bounds, has the greatest minimum value:

maximize inft p(t)
subject to li ≤ p(ti) ≤ ui, i = 1, . . . ,m.

The variables are x ∈ R2k+1.
Hint. Use the LMI characterization of nonnegative polynomials derived in exercise 2.37,
part (b).

4.45 [Nes00, Par00] Sum-of-squares representation via LMIs. Consider a polynomial p : Rn →
R of degree 2k. The polynomial is said to be positive semidefinite (PSD) if p(x) ≥ 0
for all x ∈ Rn. Except for special cases (e.g., n = 1 or k = 1), it is extremely difficult
to determine whether or not a given polynomial is PSD, let alone solve an optimization
problem, with the coefficients of p as variables, with the constraint that p be PSD.

A famous sufficient condition for a polynomial to be PSD is that it have the form

p(x) =

r∑
i=1

qi(x)
2,

for some polynomials qi, with degree no more than k. A polynomial p that has this
sum-of-squares form is called SOS.

The condition that a polynomial p be SOS (viewed as a constraint on its coefficients)
turns out to be equivalent to an LMI, and therefore a variety of optimization problems,
with SOS constraints, can be posed as SDPs. You will explore these ideas in this problem.

(a) Let f1, . . . , fs be all monomials of degree k or less. (Here we mean monomial in
the standard sense, i.e., xm11 · · ·xmnn , where mi ∈ Z+, and not in the sense used in
geometric programming.) Show that if p can be expressed as a positive semidefinite
quadratic form p = fTV f , with V ∈ Ss+, then p is SOS. Conversely, show that if
p is SOS, then it can be expressed as a positive semidefinite quadratic form in the
monomials, i.e., p = fTV f , for some V ∈ Ss+.



204 4 Convex optimization problems

(b) Show that the condition p = fTV f is a set of linear equality constraints relating the
coefficients of p and the matrix V . Combined with part (a) above, this shows that
the condition that p be SOS is equivalent to a set of linear equalities relating V and
the coefficients of p, and the matrix inequality V � 0.

(c) Work out the LMI conditions for SOS explicitly for the case where p is polynomial
of degree four in two variables.

4.46 Multidimensional moments. The moments of a random variable t on R2 are defined as
µij = E t

i
1t
j
2, where i, j are nonnegative integers. In this problem we derive necessary

conditions for a set of numbers µij , 0 ≤ i, j ≤ 2k, i + j ≤ 2k, to be the moments of a
distribution on R2.

Let p : R2 → R be a polynomial of degree k with coefficients cij ,

p(t) =

k∑
i=0

k−i∑
j=0

cijt
i
1t
j
2,

and let t be a random variable with moments µij . Suppose c ∈ R(k+1)(k+2)/2 contains
the coefficients cij in some specific order, and µ ∈ R(k+1)(2k+1) contains the moments µij
in the same order. Show that E p(t)2 can be expressed as a quadratic form in c:

E p(t)2 = cTH(µ)c,

where H : R(k+1)(2k+1) → S(k+1)(k+2)/2 is a linear function of µ. From this, conclude
that µ must satisfy the LMI H(µ) � 0.
Remark: For random variables on R, the matrix H can be taken as the Hankel matrix
defined in (4.52). In this case, H(µ) � 0 is a necessary and sufficient condition for µ to be
the moments of a distribution, or the limit of a sequence of moments. On R2, however,
the LMI is only a necessary condition.

4.47 Maximum determinant positive semidefinite matrix completion. We consider a matrix
A ∈ Sn, with some entries specified, and the others not specified. The positive semidefinite
matrix completion problem is to determine values of the unspecified entries of the matrix
so that A � 0 (or to determine that such a completion does not exist).
(a) Explain why we can assume without loss of generality that the diagonal entries of

A are specified.

(b) Show how to formulate the positive semidefinite completion problem as an SDP
feasibility problem.

(c) Assume that A has at least one completion that is positive definite, and the diag-
onal entries of A are specified (i.e., fixed). The positive definite completion with
largest determinant is called the maximum determinant completion. Show that the
maximum determinant completion is unique. Show that if A⋆ is the maximum de-
terminant completion, then (A⋆)−1 has zeros in all the entries of the original matrix
that were not specified. Hint. The gradient of the function f(X) = log detX is
∇f(X) = X−1 (see §A.4.1).

(d) Suppose A is specified on its tridiagonal part, i.e., we are given A11, . . . , Ann and
A12, . . . , An−1,n. Show that if there exists a positive definite completion of A, then
there is a positive definite completion whose inverse is tridiagonal.

4.48 Generalized eigenvalue minimization. Recall (from example 3.37, or §A.5.3) that the
largest generalized eigenvalue of a pair of matrices (A,B) ∈ Sk × Sk++ is given by

λmax(A,B) = sup
u 6=0

uTAu

uTBu
= max{λ | det(λB −A) = 0}.

As we have seen, this function is quasiconvex (if we take Sk × Sk++ as its domain).



Exercises 205

We consider the problem

minimize λmax(A(x), B(x)) (4.73)

where A,B : Rn → Sk are affine functions, defined as
A(x) = A0 + x1A1 + · · ·+ xnAn, B(x) = B0 + x1B1 + · · ·+ xnBn.

with Ai, Bi ∈ Sk.
(a) Give a family of convex functions φt : S

k × Sk → R, that satisfy
λmax(A,B) ≤ t ⇐⇒ φt(A,B) ≤ 0

for all (A,B) ∈ Sk × Sk++. Show that this allows us to solve (4.73) by solving a
sequence of convex feasibility problems.

(b) Give a family of matrix-convex functions Φt : S
k × Sk → Sk that satisfy

λmax(A,B) ≤ t ⇐⇒ Φt(A,B) � 0

for all (A,B) ∈ Sk × Sk++. Show that this allows us to solve (4.73) by solving a
sequence of convex feasibility problems with LMI constraints.

(c) Suppose B(x) = (aTx+b)I, with a 6= 0. Show that (4.73) is equivalent to the convex
problem

minimize λmax(sA0 + y1A1 + · · ·+ ynAn)
subject to aT y + bs = 1

s ≥ 0,
with variables y ∈ Rn, s ∈ R.

4.49 Generalized fractional programming. Let K ∈ Rm be a proper cone. Show that the
function f0 : R

n → Rm, defined by
f0(x) = inf{t | Cx+ d �K t(Fx+ g)}, dom f0 = {x | Fx+ g ≻K 0},

with C,F ∈ Rm×n, d, g ∈ Rm, is quasiconvex.
A quasiconvex optimization problem with objective function of this form is called a gen-
eralized fractional program. Express the generalized linear-fractional program of page 152
and the generalized eigenvalue minimization problem (4.73) as generalized fractional pro-
grams.

Vector and multicriterion optimization

4.50 Bi-criterion optimization. Figure 4.11 shows the optimal trade-off curve and the set of
achievable values for the bi-criterion optimization problem

minimize (w.r.t. R2+) (‖Ax− b‖2, ‖x‖22),

for some A ∈ R100×10, b ∈ R100. Answer the following questions using information from
the plot. We denote by xls the solution of the least-squares problem

minimize ‖Ax− b‖22.
(a) What is ‖xls‖2?
(b) What is ‖Axls − b‖2?
(c) What is ‖b‖2?



206 4 Convex optimization problems

(d) Give the optimal value of the problem

minimize ‖Ax− b‖22
subject to ‖x‖22 = 1.

(e) Give the optimal value of the problem

minimize ‖Ax− b‖22
subject to ‖x‖22 ≤ 1.

(f) Give the optimal value of the problem

minimize ‖Ax− b‖22 + ‖x‖22.

(g) What is the rank of A?

4.51 Monotone transformation of objective in vector optimization. Consider the vector opti-
mization problem (4.56). Suppose we form a new vector optimization problem by replacing
the objective f0 with φ ◦ f0, where φ : Rq → Rq satisfies

u �K v, u 6= v =⇒ φ(u) �K φ(v), φ(u) 6= φ(v).

Show that a point x is Pareto optimal (or optimal) for one problem if and only if it is
Pareto optimal (optimal) for the other, so the two problems are equivalent. In particular,
composing each objective in a multicriterion problem with an increasing function does
not affect the Pareto optimal points.

4.52 Pareto optimal points and the boundary of the set of achievable values. Consider a vector
optimization problem with cone K. Let P denote the set of Pareto optimal values, and
let O denote the set of achievable objective values. Show that P ⊆ O ∩ bdO, i.e., every
Pareto optimal value is an achievable objective value that lies in the boundary of the set
of achievable objective values.

4.53 Suppose the vector optimization problem (4.56) is convex. Show that the set

A = O +K = {t ∈ Rq | f0(x) �K t for some feasible x},

is convex. Also show that the minimal elements of A are the same as the minimal points
of O.

4.54 Scalarization and optimal points. Suppose a (not necessarily convex) vector optimization
problem has an optimal point x⋆. Show that x⋆ is a solution of the associated scalarized
problem for any choice of λ ≻K∗ 0. Also show the converse: If a point x is a solution of
the scalarized problem for any choice of λ ≻K∗ 0, then it is an optimal point for the (not
necessarily convex) vector optimization problem.

4.55 Generalization of weighted-sum scalarization. In §4.7.4 we showed how to obtain Pareto
optimal solutions of a vector optimization problem by replacing the vector objective f0 :
Rn → Rq with the scalar objective λT f0, where λ ≻K∗ 0. Let ψ : Rq → R be a
K-increasing function, i.e., satisfying

u �K v, u 6= v =⇒ ψ(u) < ψ(v).

Show that any solution of the problem

minimize ψ(f0(x))
subject to fi(x) ≤ 0, i = 1, . . . ,m

hi(x) = 0, i = 1, . . . , p



Exercises 207

is Pareto optimal for the vector optimization problem

minimize (w.r.t. K) f0(x)
subject to fi(x) ≤ 0, i = 1, . . . ,m

hi(x) = 0, i = 1, . . . , p.

Note that ψ(u) = λTu, where λ ≻K∗ 0, is a special case.
As a related example, show that in a multicriterion optimization problem (i.e., a vector
optimization problem with f0 = F : R

n → Rq, and K = Rq+), a unique solution of the
scalar optimization problem

minimize maxi=1,...,q Fi(x)
subject to fi(x) ≤ 0, i = 1, . . . ,m

hi(x) = 0, i = 1, . . . , p,

is Pareto optimal.

Miscellaneous problems

4.56 [P. Parrilo] We consider the problem of minimizing the convex function f0 : R
n → R

over the convex hull of the union of some convex sets, conv
(⋃q

i=1
Ci
)
. These sets are

described via convex inequalities,

Ci = {x | fij(x) ≤ 0, j = 1, . . . , ki},
where fij : R

n → R are convex. Our goal is to formulate this problem as a convex
optimization problem.

The obvious approach is to introduce variables x1, . . . , xq ∈ Rn, with xi ∈ Ci, θ ∈ Rq
with θ � 0, 1T θ = 1, and a variable x ∈ Rn, with x = θ1x1 + · · · + θqxq. This equality
constraint is not affine in the variables, so this approach does not yield a convex problem.

A more sophisticated formulation is given by

minimize f0(x)
subject to sifij(zi/si) ≤ 0, i = 1, . . . , q, j = 1, . . . , ki

1T s = 1, s � 0
x = z1 + · · ·+ zq,

with variables z1, . . . , zq ∈ Rn, x ∈ Rn, and s1, . . . , sq ∈ R. (When si = 0, we take
sifij(zi/si) to be 0 if zi = 0 and ∞ if zi 6= 0.) Explain why this problem is convex, and
equivalent to the original problem.

4.57 Capacity of a communication channel. We consider a communication channel, with input
X(t) ∈ {1, . . . , n}, and output Y (t) ∈ {1, . . . ,m}, for t = 1, 2, . . . (in seconds, say). The
relation between the input and the output is given statistically:

pij = prob(Y (t) = i|X(t) = j), i = 1, . . . ,m, j = 1, . . . , n.
The matrix P ∈ Rm×n is called the channel transition matrix, and the channel is called
a discrete memoryless channel.

A famous result of Shannon states that information can be sent over the communication
channel, with arbitrarily small probability of error, at any rate less than a number C,
called the channel capacity, in bits per second. Shannon also showed that the capacity of
a discrete memoryless channel can be found by solving an optimization problem. Assume
that X has a probability distribution denoted x ∈ Rn, i.e.,

xj = prob(X = j), j = 1, . . . , n.



208 4 Convex optimization problems

The mutual information between X and Y is given by

I(X;Y ) =

m∑
i=1

n∑
j=1

xjpij log2
pij∑n

k=1
xkpik

.

Then the channel capacity C is given by

C = sup
x

I(X;Y ),

where the supremum is over all possible probability distributions for the input X, i.e.,
over x � 0, 1Tx = 1.
Show how the channel capacity can be computed using convex optimization.

Hint. Introduce the variable y = Px, which gives the probability distribution of the
output Y , and show that the mutual information can be expressed as

I(X;Y ) = cTx−
m∑
i=1

yi log2 yi,

where cj =
∑m

i=1
pij log2 pij , j = 1, . . . , n.

4.58 Optimal consumption. In this problem we consider the optimal way to consume (or spend)
an initial amount of money (or other asset) k0 over time. The variables are c0, . . . , cT ,
where ct ≥ 0 denotes the consumption in period t. The utility derived from a consumption
level c is given by u(c), where u : R→ R is an increasing concave function. The present
value of the utility derived from the consumption is given by

U =

T∑
t=0

βtu(ct),

where 0 < β < 1 is a discount factor.

Let kt denote the amount of money available for investment in period t. We assume
that it earns an investment return given by f(kt), where f : R → R is an increasing,
concave investment return function, which satisfies f(0) = 0. For example if the funds
earn simple interest at rate R percent per period, we have f(a) = (R/100)a. The amount
to be consumed, i.e., ct, is withdrawn at the end of the period, so we have the recursion

kt+1 = kt + f(kt)− ct, t = 0, . . . , T.
The initial sum k0 > 0 is given. We require kt ≥ 0, t = 1, . . . , T+1 (but more sophisticated
models, which allow kt < 0, can be considered).

Show how to formulate the problem of maximizing U as a convex optimization problem.
Explain how the problem you formulate is equivalent to this one, and exactly how the
two are related.

Hint. Show that we can replace the recursion for kt given above with the inequalities

kt+1 ≤ kt + f(kt)− ct, t = 0, . . . , T.
(Interpretation: the inequalities give you the option of throwing money away in each
period.) For a more general version of this trick, see exercise 4.6.

4.59 Robust optimization. In some optimization problems there is uncertainty or variation
in the objective and constraint functions, due to parameters or factors that are either
beyond our control or unknown. We can model this situation by making the objective
and constraint functions f0, . . . , fm functions of the optimization variable x ∈ Rn and
a parameter vector u ∈ Rk that is unknown, or varies. In the stochastic optimization



Exercises 209

approach, the parameter vector u is modeled as a random variable with a known dis-
tribution, and we work with the expected values Eu fi(x, u). In the worst-case analysis
approach, we are given a set U that u is known to lie in, and we work with the maximum
or worst-case values supu∈U fi(x, u). To simplify the discussion, we assume there are no
equality constraints.

(a) Stochastic optimization. We consider the problem

minimize E f0(x, u)
subject to E fi(x, u) ≤ 0, i = 1, . . . ,m,

where the expectation is with respect to u. Show that if fi are convex in x for each
u, then this stochastic optimization problem is convex.

(b) Worst-case optimization. We consider the problem

minimize supu∈U f0(x, u)
subject to supu∈U fi(x, u) ≤ 0, i = 1, . . . ,m.

Show that if fi are convex in x for each u, then this worst-case optimization problem
is convex.

(c) Finite set of possible parameter values. The observations made in parts (a) and (b)
are most useful when we have analytical or easily evaluated expressions for the
expected values E fi(x, u) or the worst-case values supu∈U fi(x, u).

Suppose we are given the set of possible values of the parameter is finite, i.e., we
have u ∈ {u1, . . . , uN}. For the stochastic case, we are also given the probabilities
of each value: prob(u = ui) = pi, where p ∈ RN , p � 0, 1T p = 1. In the worst-case
formulation, we simply take U ∈ {u1, . . . , uN}.
Show how to set up the worst-case and stochastic optimization problems explicitly
(i.e., give explicit expressions for supu∈U fi and Eu fi).

4.60 Log-optimal investment strategy. We consider a portfolio problem with n assets held over
N periods. At the beginning of each period, we re-invest our total wealth, redistributing
it over the n assets using a fixed, constant, allocation strategy x ∈ Rn, where x � 0,
1Tx = 1. In other words, if W (t − 1) is our wealth at the beginning of period t, then
during period t we invest xiW (t−1) in asset i. We denote by λ(t) the total return during
period t, i.e., λ(t) = W (t)/W (t − 1). At the end of the N periods our wealth has been
multiplied by the factor

∏N
t=1

λ(t). We call

1

N

N∑
t=1

log λ(t)

the growth rate of the investment over the N periods. We are interested in determining
an allocation strategy x that maximizes growth of our total wealth for large N .

We use a discrete stochastic model to account for the uncertainty in the returns. We
assume that during each period there are m possible scenarios, with probabilities πj ,
j = 1, . . . ,m. In scenario j, the return for asset i over one period is given by pij .
Therefore, the return λ(t) of our portfolio during period t is a random variable, with
m possible values pT1 x, . . . , p

T
mx, and distribution

πj = prob(λ(t) = p
T
j x), j = 1, . . . ,m.

We assume the same scenarios for each period, with (identical) independent distributions.
Using the law of large numbers, we have

lim
N→∞

1

N
log

(
W (N)

W (0)

)
= lim

N→∞

1

N

N∑
t=1

log λ(t) = E log λ(t) =

m∑
j=1

πj log(p
T
j x).



210 4 Convex optimization problems

In other words, with investment strategy x, the long term growth rate is given by

Rlt =

m∑
j=1

πj log(p
T
j x).

The investment strategy x that maximizes this quantity is called the log-optimal invest-
ment strategy, and can be found by solving the optimization problem

maximize
∑m

j=1
πj log(p

T
j x)

subject to x � 0, 1Tx = 1,
with variable x ∈ Rn.
Show that this is a convex optimization problem.

4.61 Optimization with logistic model. A random variable X ∈ {0, 1} satisfies

prob(X = 1) = p =
exp(aTx+ b)

1 + exp(aTx+ b)
,

where x ∈ Rn is a vector of variables that affect the probability, and a and b are known
parameters. We can think of X = 1 as the event that a consumer buys a product, and
x as a vector of variables that affect the probability, e.g., advertising effort, retail price,
discounted price, packaging expense, and other factors. The variable x, which we are to
optimize over, is subject to a set of linear constraints, Fx � g.
Formulate the following problems as convex optimization problems.

(a) Maximizing buying probability. The goal is to choose x to maximize p.

(b) Maximizing expected profit. Let cTx+d be the profit derived from selling the product,
which we assume is positive for all feasible x. The goal is to maximize the expected
profit, which is p(cTx+ d).

4.62 Optimal power and bandwidth allocation in a Gaussian broadcast channel. We consider a
communication system in which a central node transmits messages to n receivers. (‘Gaus-
sian’ refers to the type of noise that corrupts the transmissions.) Each receiver channel
is characterized by its (transmit) power level Pi ≥ 0 and its bandwidth Wi ≥ 0. The
power and bandwidth of a receiver channel determine its bit rate Ri (the rate at which
information can be sent) via

Ri = αiWi log(1 + βiPi/Wi),

where αi and βi are known positive constants. For Wi = 0, we take Ri = 0 (which is
what you get if you take the limit as Wi → 0).
The powers must satisfy a total power constraint, which has the form

P1 + · · ·+ Pn = Ptot,
where Ptot > 0 is a given total power available to allocate among the channels. Similarly,
the bandwidths must satisfy

W1 + · · ·+Wn =Wtot,
where Wtot > 0 is the (given) total available bandwidth. The optimization variables in
this problem are the powers and bandwidths, i.e., P1, . . . , Pn, W1, . . . ,Wn.

The objective is to maximize the total utility,

n∑
i=1

ui(Ri),



Exercises 211

where ui : R → R is the utility function associated with the ith receiver. (You can
think of ui(Ri) as the revenue obtained for providing a bit rate Ri to receiver i, so the
objective is to maximize the total revenue.) You can assume that the utility functions ui
are nondecreasing and concave.

Pose this problem as a convex optimization problem.

4.63 Optimally balancing manufacturing cost and yield. The vector x ∈ Rn denotes the nomi-
nal parameters in a manufacturing process. The yield of the process, i.e., the fraction of
manufactured goods that is acceptable, is given by Y (x). We assume that Y is log-concave
(which is often the case; see example 3.43). The cost per unit to manufacture the product
is given by cTx, where c ∈ Rn. The cost per acceptable unit is cTx/Y (x). We want to
minimize cTx/Y (x), subject to some convex constraints on x such as a linear inequalities
Ax � b. (You can assume that over the feasible set we have cTx > 0 and Y (x) > 0.)
This problem is not a convex or quasiconvex optimization problem, but it can be solved
using convex optimization and a one-dimensional search. The basic ideas are given below;
you must supply all details and justification.

(a) Show that the function f : R→ R given by
f(a) = sup{Y (x) | Ax � b, cTx = a},

which gives the maximum yield versus cost, is log-concave. This means that by
solving a convex optimization problem (in x) we can evaluate the function f .

(b) Suppose that we evaluate the function f for enough values of a to give a good approx-
imation over the range of interest. Explain how to use these data to (approximately)
solve the problem of minimizing cost per good product.

4.64 Optimization with recourse. In an optimization problem with recourse, also called two-
stage optimization, the cost function and constraints depend not only on our choice of
variables, but also on a discrete random variable s ∈ {1, . . . , S}, which is interpreted as
specifying which of S scenarios occurred. The scenario random variable s has known
probability distribution π, with πi = prob(s = i), i = 1, . . . , S.

In two-stage optimization, we are to choose the values of two variables, x ∈ Rn and
z ∈ Rq. The variable x must be chosen before the particular scenario s is known; the
variable z, however, is chosen after the value of the scenario random variable is known.
In other words, z is a function of the scenario random variable s. To describe our choice
z, we list the values we would choose under the different scenarios, i.e., we list the vectors

z1, . . . , zS ∈ Rq.
Here z3 is our choice of z when s = 3 occurs, and so on. The set of values

x ∈ Rn, z1, . . . , zS ∈ Rq

is called the policy, since it tells us what choice to make for x (independent of which
scenario occurs), and also, what choice to make for z in each possible scenario.

The variable z is called the recourse variable (or second-stage variable), since it allows
us to take some action or make a choice after we know which scenario occurred. In
contrast, our choice of x (which is called the first-stage variable) must be made without
any knowledge of the scenario.

For simplicity we will consider the case with no constraints. The cost function is given by

f : Rn ×Rq × {1, . . . , S} → R,
where f(x, z, i) gives the cost when the first-stage choice x is made, second-stage choice
z is made, and scenario i occurs. We will take as the overall objective, to be minimized
over all policies, the expected cost

E f(x, zs, s) =

S∑
i=1

πif(x, zi, i).



212 4 Convex optimization problems

Suppose that f is a convex function of (x, z), for each scenario i = 1, . . . , S. Explain
how to find an optimal policy, i.e., one that minimizes the expected cost over all possible
policies, using convex optimization.

4.65 Optimal operation of a hybrid vehicle. A hybrid vehicle has an internal combustion engine,
a motor/generator connected to a storage battery, and a conventional (friction) brake. In
this exercise we consider a (highly simplified) model of a parallel hybrid vehicle, in which
both the motor/generator and the engine are directly connected to the drive wheels. The
engine can provide power to the wheels, and the brake can take power from the wheels,
turning it into heat. The motor/generator can act as a motor, when it uses energy stored
in the battery to deliver power to the wheels, or as a generator, when it takes power from
the wheels or engine, and uses the power to charge the battery. When the generator takes
power from the wheels and charges the battery, it is called regenerative braking ; unlike
ordinary friction braking, the energy taken from the wheels is stored, and can be used
later. The vehicle is judged by driving it over a known, fixed test track to evaluate its
fuel efficiency.

A diagram illustrating the power flow in the hybrid vehicle is shown below. The arrows
indicate the direction in which the power flow is considered positive. The engine power
peng, for example, is positive when it is delivering power; the brake power pbr is positive
when it is taking power from the wheels. The power preq is the required power at the
wheels. It is positive when the wheels require power (e.g., when the vehicle accelerates,
climbs a hill, or cruises on level terrain). The required wheel power is negative when the
vehicle must decelerate rapidly, or descend a hill.

Engine Brake

Motor/
generator Battery

peng

pmg

pbr preq
wheels

All of these powers are functions of time, which we discretize in one second intervals, with
t = 1, 2, . . . , T . The required wheel power preq(1), . . . , preq(T ) is given. (The speed of
the vehicle on the track is specified, so together with known road slope information, and
known aerodynamic and other losses, the power required at the wheels can be calculated.)

Power is conserved, which means we have

preq(t) = peng(t) + pmg(t)− pbr(t), t = 1, . . . , T.
The brake can only dissipate power, so we have pbr(t) ≥ 0 for each t. The engine can only
provide power, and only up to a given limit Pmaxeng , i.e., we have

0 ≤ peng(t) ≤ Pmaxeng , t = 1, . . . , T.
The motor/generator power is also limited: pmg must satisfy

Pminmg ≤ pmg(t) ≤ Pmaxmg , t = 1, . . . , T.

Here Pmaxmg > 0 is the maximum motor power, and −Pminmg > 0 is the maximum generator
power.

The battery charge or energy at time t is denoted E(t), t = 1, . . . , T + 1. The battery
energy satisfies

E(t+ 1) = E(t)− pmg(t)− η|pmg(t)|, t = 1, . . . , T,



Exercises 213

where η > 0 is a known parameter. (The term −pmg(t) represents the energy removed
or added the battery by the motor/generator, ignoring any losses. The term −η|pmg(t)|
represents energy lost through inefficiencies in the battery or motor/generator.)

The battery charge must be between 0 (empty) and its limit Emaxbatt (full), at all times. (If
E(t) = 0, the battery is fully discharged, and no more energy can be extracted from it;
when E(t) = Emaxbatt , the battery is full and cannot be charged.) To make the comparison
with non-hybrid vehicles fair, we fix the initial battery charge to equal the final battery
charge, so the net energy change is zero over the track: E(1) = E(T + 1). We do not
specify the value of the initial (and final) energy.

The objective in the problem (to be minimized) is the total fuel consumed by the engine,
which is

Ftotal =

T∑
t=1

F (peng(t)),

where F : R → R is the fuel use characteristic of the engine. We assume that F is
positive, increasing, and convex.

Formulate this problem as a convex optimization problem, with variables peng(t), pmg(t),
and pbr(t) for t = 1, . . . , T , and E(t) for t = 1, . . . , T + 1. Explain why your formulation
is equivalent to the problem described above.





Chapter 5

Duality

5.1 The Lagrange dual function

5.1.1 The Lagrangian

We consider an optimization problem in the standard form (4.1):

minimize f0(x)
subject to fi(x) ≤ 0, i = 1, . . . ,m

hi(x) = 0, i = 1, . . . , p,
(5.1)

with variable x ∈ Rn. We assume its domain D = ⋂mi=0 dom fi ∩ ⋂pi=1 domhi
is nonempty, and denote the optimal value of (5.1) by p⋆. We do not assume the
problem (5.1) is convex.

The basic idea in Lagrangian duality is to take the constraints in (5.1) into
account by augmenting the objective function with a weighted sum of the constraint
functions. We define the Lagrangian L : Rn ×Rm ×Rp → R associated with the
problem (5.1) as

L(x, λ, ν) = f0(x) +
m∑
i=1

λifi(x) +

p∑
i=1

νihi(x),

with domL = D×Rm×Rp. We refer to λi as the Lagrange multiplier associated
with the ith inequality constraint fi(x) ≤ 0; similarly we refer to νi as the Lagrange
multiplier associated with the ith equality constraint hi(x) = 0. The vectors λ and
ν are called the dual variables or Lagrange multiplier vectors associated with the
problem (5.1).



216 5 Duality

5.1.2 The Lagrange dual function

We define the Lagrange dual function (or just dual function) g : Rm ×Rp → R as
the minimum value of the Lagrangian over x: for λ ∈ Rm, ν ∈ Rp,

g(λ, ν) = inf
x∈D

L(x, λ, ν) = inf
x∈D

(
f0(x) +

m∑
i=1

λifi(x) +

p∑
i=1

νihi(x)

)
.

When the Lagrangian is unbounded below in x, the dual function takes on the
value −∞. Since the dual function is the pointwise infimum of a family of affine
functions of (λ, ν), it is concave, even when the problem (5.1) is not convex.

5.1.3 Lower bounds on optimal value

The dual function yields lower bounds on the optimal value p⋆ of the problem (5.1):
For any λ � 0 and any ν we have

g(λ, ν) ≤ p⋆. (5.2)
This important property is easily verified. Suppose x˜ is a feasible point for the
problem (5.1), i.e., fi(x˜) ≤ 0 and hi(x˜) = 0, and λ � 0. Then we have

m∑
i=1

λifi(x˜) +

p∑
i=1

νihi(x˜) ≤ 0,

since each term in the first sum is nonpositive, and each term in the second sum is
zero, and therefore

L(x˜, λ, ν) = f0(x˜) +
m∑
i=1

λifi(x˜) +

p∑
i=1

νihi(x˜) ≤ f0(x˜).

Hence
g(λ, ν) = inf

x∈D
L(x, λ, ν) ≤ L(x˜, λ, ν) ≤ f0(x˜).

Since g(λ, ν) ≤ f0(x˜) holds for every feasible point x˜, the inequality (5.2) follows.
The lower bound (5.2) is illustrated in figure 5.1, for a simple problem with x ∈ R
and one inequality constraint.

The inequality (5.2) holds, but is vacuous, when g(λ, ν) = −∞. The dual
function gives a nontrivial lower bound on p⋆ only when λ � 0 and (λ, ν) ∈ dom g,
i.e., g(λ, ν) > −∞. We refer to a pair (λ, ν) with λ � 0 and (λ, ν) ∈ dom g as dual
feasible, for reasons that will become clear later.

5.1.4 Linear approximation interpretation

The Lagrangian and lower bound property can be given a simple interpretation,
based on a linear approximation of the indicator functions of the sets {0} and −R+.



5.1 The Lagrange dual function 217

x
−1 −0.5 0 0.5 1−2

−1
0

1

2

3

4

5

Figure 5.1 Lower bound from a dual feasible point. The solid curve shows the
objective function f0, and the dashed curve shows the constraint function f1.
The feasible set is the interval [−0.46, 0.46], which is indicated by the two
dotted vertical lines. The optimal point and value are x⋆ = −0.46, p⋆ = 1.54
(shown as a circle). The dotted curves show L(x, λ) for λ = 0.1, 0.2, . . . , 1.0.
Each of these has a minimum value smaller than p⋆, since on the feasible set
(and for λ ≥ 0) we have L(x, λ) ≤ f0(x).

λ

g
(λ
)

0 0.2 0.4 0.6 0.8 1
1

1.1

1.2

1.3

1.4

1.5

1.6

Figure 5.2 The dual function g for the problem in figure 5.1. Neither f0 nor
f1 is convex, but the dual function is concave. The horizontal dashed line
shows p⋆, the optimal value of the problem.



218 5 Duality

We first rewrite the original problem (5.1) as an unconstrained problem,

minimize f0(x) +
∑m

i=1 I−(fi(x)) +
∑p

i=1 I0(hi(x)), (5.3)

where I− : R→ R is the indicator function for the nonpositive reals,

I−(u) =

{
0 u ≤ 0
∞ u > 0,

and similarly, I0 is the indicator function of {0}. In the formulation (5.3), the func-
tion I−(u) can be interpreted as expressing our irritation or displeasure associated
with a constraint function value u = fi(x): It is zero if fi(x) ≤ 0, and infinite if
fi(x) > 0. In a similar way, I0(u) gives our displeasure for an equality constraint
value u = hi(x). We can think of I− as a “brick wall” or “infinitely hard” displea-
sure function; our displeasure rises from zero to infinite as fi(x) transitions from
nonpositive to positive.

Now suppose in the formulation (5.3) we replace the function I−(u) with the
linear function λiu, where λi ≥ 0, and the function I0(u) with νiu. The objective
becomes the Lagrangian function L(x, λ, ν), and the dual function value g(λ, ν) is
the optimal value of the problem

minimize L(x, λ, ν) = f0(x) +
∑m

i=1 λifi(x) +
∑p

i=1 νihi(x). (5.4)

In this formulation, we use a linear or “soft” displeasure function in place of I−
and I0. For an inequality constraint, our displeasure is zero when fi(x) = 0, and is
positive when fi(x) > 0 (assuming λi > 0); our displeasure grows as the constraint
becomes “more violated”. Unlike the original formulation, in which any nonpositive
value of fi(x) is acceptable, in the soft formulation we actually derive pleasure from
constraints that have margin, i.e., from fi(x) < 0.

Clearly the approximation of the indicator function I−(u) with a linear function
λiu is rather poor. But the linear function is at least an underestimator of the
indicator function. Since λiu ≤ I−(u) and νiu ≤ I0(u) for all u, we see immediately
that the dual function yields a lower bound on the optimal value of the original
problem.

The idea of replacing the “hard” constraints with “soft” versions will come up
again when we consider interior-point methods (§11.2.1).

5.1.5 Examples

In this section we give some examples for which we can derive an analytical ex-
pression for the Lagrange dual function.

Least-squares solution of linear equations

We consider the problem
minimize xTx
subject to Ax = b,

(5.5)

where A ∈ Rp×n. This problem has no inequality constraints and p (linear) equality
constraints. The Lagrangian is L(x, ν) = xTx + νT (Ax − b), with domain Rn ×



5.1 The Lagrange dual function 219

Rp. The dual function is given by g(ν) = infx L(x, ν). Since L(x, ν) is a convex
quadratic function of x, we can find the minimizing x from the optimality condition

∇xL(x, ν) = 2x+AT ν = 0,
which yields x = −(1/2)AT ν. Therefore the dual function is

g(ν) = L(−(1/2)AT ν, ν) = −(1/4)νTAAT ν − bT ν,
which is a concave quadratic function, with domain Rp. The lower bound prop-
erty (5.2) states that for any ν ∈ Rp, we have

−(1/4)νTAAT ν − bT ν ≤ inf{xTx | Ax = b}.

Standard form LP

Consider an LP in standard form,

minimize cTx
subject to Ax = b

x � 0,
(5.6)

which has inequality constraint functions fi(x) = −xi, i = 1, . . . , n. To form
the Lagrangian we introduce multipliers λi for the n inequality constraints and
multipliers νi for the equality constraints, and obtain

L(x, λ, ν) = cTx−
n∑
i=1

λixi + ν
T (Ax− b) = −bT ν + (c+AT ν − λ)Tx.

The dual function is

g(λ, ν) = inf
x
L(x, λ, ν) = −bT ν + inf

x
(c+AT ν − λ)Tx,

which is easily determined analytically, since a linear function is bounded below
only when it is identically zero. Thus, g(λ, ν) = −∞ except when c+AT ν−λ = 0,
in which case it is −bT ν:

g(λ, ν) =

{ −bT ν AT ν − λ+ c = 0
−∞ otherwise.

Note that the dual function g is finite only on a proper affine subset of Rm ×Rp.
We will see that this is a common occurrence.

The lower bound property (5.2) is nontrivial only when λ and ν satisfy λ � 0
and AT ν − λ + c = 0. When this occurs, −bT ν is a lower bound on the optimal
value of the LP (5.6).

Two-way partitioning problem

We consider the (nonconvex) problem

minimize xTWx
subject to x2i = 1, i = 1, . . . , n,

(5.7)



220 5 Duality

where W ∈ Sn. The constraints restrict the values of xi to 1 or −1, so the problem
is equivalent to finding the vector with components ±1 that minimizes xTWx. The
feasible set here is finite (it contains 2n points) so this problem can in principle
be solved by simply checking the objective value of each feasible point. Since the
number of feasible points grows exponentially, however, this is possible only for
small problems (say, with n ≤ 30). In general (and for n larger than, say, 50) the
problem (5.7) is very difficult to solve.

We can interpret the problem (5.7) as a two-way partitioning problem on a set
of n elements, say, {1, . . . , n}: A feasible x corresponds to the partition

{1, . . . , n} = {i | xi = −1} ∪ {i | xi = 1}.
The matrix coefficient Wij can be interpreted as the cost of having the elements i
and j in the same partition, and −Wij is the cost of having i and j in different
partitions. The objective in (5.7) is the total cost, over all pairs of elements, and
the problem (5.7) is to find the partition with least total cost.

We now derive the dual function for this problem. The Lagrangian is

L(x, ν) = xTWx+

n∑
i=1

νi(x
2
i − 1)

= xT (W + diag(ν))x− 1T ν.
We obtain the Lagrange dual function by minimizing over x:

g(ν) = inf
x
xT (W + diag(ν))x− 1T ν

=

{ −1T ν W + diag(ν) � 0
−∞ otherwise,

where we use the fact that the infimum of a quadratic form is either zero (if the
form is positive semidefinite) or −∞ (if the form is not positive semidefinite).

This dual function provides lower bounds on the optimal value of the difficult
problem (5.7). For example, we can take the specific value of the dual variable

ν = −λmin(W )1,
which is dual feasible, since

W + diag(ν) =W − λmin(W )I � 0.
This yields the bound on the optimal value p⋆

p⋆ ≥ −1T ν = nλmin(W ). (5.8)

Remark 5.1 This lower bound on p⋆ can also be obtained without using the Lagrange
dual function. First, we replace the constraints x21 = 1, . . . , x

2
n = 1 with

∑n
i=1

x2i = n,
to obtain the modified problem

minimize xTWx
subject to

∑n
i=1

x2i = n.
(5.9)



5.1 The Lagrange dual function 221

The constraints of the original problem (5.7) imply the constraint here, so the optimal
value of the problem (5.9) is a lower bound on p⋆, the optimal value of (5.7). But the
modified problem (5.9) is easily solved as an eigenvalue problem, with optimal value
nλmin(W ).

5.1.6 The Lagrange dual function and conjugate functions

Recall from §3.3 that the conjugate f∗ of a function f : Rn → R is given by

f∗(y) = sup
x∈dom f

(
yTx− f(x)) .

The conjugate function and Lagrange dual function are closely related. To see one
simple connection, consider the problem

minimize f(x)
subject to x = 0

(which is not very interesting, and solvable by inspection). This problem has
Lagrangian L(x, ν) = f(x) + νTx, and dual function

g(ν) = inf
x

(
f(x) + νTx

)
= − sup

x

(
(−ν)Tx− f(x)) = −f∗(−ν).

More generally (and more usefully), consider an optimization problem with
linear inequality and equality constraints,

minimize f0(x)
subject to Ax � b

Cx = d.
(5.10)

Using the conjugate of f0 we can write the dual function for the problem (5.10) as

g(λ, ν) = inf
x

(
f0(x) + λ

T (Ax− b) + νT (Cx− d))
= −bTλ− dT ν + inf

x

(
f0(x) + (A

Tλ+ CT ν)Tx
)

= −bTλ− dT ν − f∗0 (−ATλ− CT ν). (5.11)

The domain of g follows from the domain of f∗0 :

dom g = {(λ, ν) | −ATλ− CT ν ∈ dom f∗0 }.

Let us illustrate this with a few examples.

Equality constrained norm minimization

Consider the problem
minimize ‖x‖
subject to Ax = b,

(5.12)



222 5 Duality

where ‖ · ‖ is any norm. Recall (from example 3.26 on page 93) that the conjugate
of f0 = ‖ · ‖ is given by

f∗0 (y) =

{
0 ‖y‖∗ ≤ 1
∞ otherwise,

the indicator function of the dual norm unit ball.
Using the result (5.11) above, the dual function for the problem (5.12) is given

by

g(ν) = −bT ν − f∗0 (−AT ν) =
{ −bT ν ‖AT ν‖∗ ≤ 1
−∞ otherwise.

Entropy maximization

Consider the entropy maximization problem

minimize f0(x) =
∑n

i=1 xi log xi
subject to Ax � b

1Tx = 1
(5.13)

where dom f0 = R
n
++. The conjugate of the negative entropy function u log u,

with scalar variable u, is ev−1 (see example 3.21 on page 91). Since f0 is a sum of
negative entropy functions of different variables, we conclude that its conjugate is

f∗0 (y) =
n∑
i=1

eyi−1,

with dom f∗0 = R
n. Using the result (5.11) above, the dual function of (5.13) is

given by

g(λ, ν) = −bTλ− ν −
n∑
i=1

e−a
T
i λ−ν−1 = −bTλ− ν − e−ν−1

n∑
i=1

e−a
T
i λ

where ai is the ith column of A.

Minimum volume covering ellipsoid

Consider the problem with variable X ∈ Sn,

minimize f0(X) = log detX
−1

subject to aTi Xai ≤ 1, i = 1, . . . ,m, (5.14)

where dom f0 = S
n
++. The problem (5.14) has a simple geometric interpretation.

With each X ∈ Sn++ we associate the ellipsoid, centered at the origin,

EX = {z | zTXz ≤ 1}.

The volume of this ellipsoid is proportional to
(
detX−1

)1/2
, so the objective

of (5.14) is, except for a constant and a factor of two, the logarithm of the volume



5.2 The Lagrange dual problem 223

of EX . The constraints of the problem (5.14) are that ai ∈ EX . Thus the prob-
lem (5.14) is to determine the minimum volume ellipsoid, centered at the origin,
that includes the points a1, . . . , am.

The inequality constraints in problem (5.14) are affine; they can be expressed
as

tr
(
(aia

T
i )X

) ≤ 1.
In example 3.23 (page 92) we found that the conjugate of f0 is

f∗0 (Y ) = log det(−Y )−1 − n,

with dom f∗0 = −Sn++. Applying the result (5.11) above, the dual function for the
problem (5.14) is given by

g(λ) =

{
log det

(∑m
i=1 λiaia

T
i

)− 1Tλ+ n ∑mi=1 λiaiaTi ≻ 0
−∞ otherwise. (5.15)

Thus, for any λ � 0 with ∑mi=1 λiaiaTi ≻ 0, the number
log det

(
m∑
i=1

λiaia
T
i

)
− 1Tλ+ n

is a lower bound on the optimal value of the problem (5.14).

5.2 The Lagrange dual problem

For each pair (λ, ν) with λ � 0, the Lagrange dual function gives us a lower bound
on the optimal value p⋆ of the optimization problem (5.1). Thus we have a lower
bound that depends on some parameters λ, ν. A natural question is: What is the
best lower bound that can be obtained from the Lagrange dual function?

This leads to the optimization problem

maximize g(λ, ν)
subject to λ � 0. (5.16)

This problem is called the Lagrange dual problem associated with the problem (5.1).
In this context the original problem (5.1) is sometimes called the primal problem.
The term dual feasible, to describe a pair (λ, ν) with λ � 0 and g(λ, ν) > −∞,
now makes sense. It means, as the name implies, that (λ, ν) is feasible for the dual
problem (5.16). We refer to (λ⋆, ν⋆) as dual optimal or optimal Lagrange multipliers
if they are optimal for the problem (5.16).

The Lagrange dual problem (5.16) is a convex optimization problem, since the
objective to be maximized is concave and the constraint is convex. This is the case
whether or not the primal problem (5.1) is convex.



224 5 Duality

5.2.1 Making dual constraints explicit

The examples above show that it is not uncommon for the domain of the dual
function,

dom g = {(λ, ν) | g(λ, ν) > −∞},
to have dimension smaller than m + p. In many cases we can identify the affine
hull of dom g, and describe it as a set of linear equality constraints. Roughly
speaking, this means we can identify the equality constraints that are ‘hidden’ or
‘implicit’ in the objective g of the dual problem (5.16). In this case we can form
an equivalent problem, in which these equality constraints are given explicitly as
constraints. The following examples demonstrate this idea.

Lagrange dual of standard form LP

On page 219 we found that the Lagrange dual function for the standard form LP

minimize cTx
subject to Ax = b

x � 0
(5.17)

is given by

g(λ, ν) =

{ −bT ν AT ν − λ+ c = 0
−∞ otherwise.

Strictly speaking, the Lagrange dual problem of the standard form LP is to maxi-
mize this dual function g subject to λ � 0, i.e.,

maximize g(λ, ν) =

{ −bT ν AT ν − λ+ c = 0
−∞ otherwise

subject to λ � 0.
(5.18)

Here g is finite only when AT ν − λ + c = 0. We can form an equivalent problem
by making these equality constraints explicit:

maximize −bT ν
subject to AT ν − λ+ c = 0

λ � 0.
(5.19)

This problem, in turn, can be expressed as

maximize −bT ν
subject to AT ν + c � 0, (5.20)

which is an LP in inequality form.
Note the subtle distinctions between these three problems. The Lagrange dual

of the standard form LP (5.17) is the problem (5.18), which is equivalent to (but
not the same as) the problems (5.19) and (5.20). With some abuse of terminology,
we refer to the problem (5.19) or the problem (5.20) as the Lagrange dual of the
standard form LP (5.17).



5.2 The Lagrange dual problem 225

Lagrange dual of inequality form LP

In a similar way we can find the Lagrange dual problem of a linear program in
inequality form

minimize cTx
subject to Ax � b. (5.21)

The Lagrangian is

L(x, λ) = cTx+ λT (Ax− b) = −bTλ+ (ATλ+ c)Tx,
so the dual function is

g(λ) = inf
x
L(x, λ) = −bTλ+ inf

x
(ATλ+ c)Tx.

The infimum of a linear function is −∞, except in the special case when it is
identically zero, so the dual function is

g(λ) =

{ −bTλ ATλ+ c = 0
−∞ otherwise.

The dual variable λ is dual feasible if λ � 0 and ATλ+ c = 0.
The Lagrange dual of the LP (5.21) is to maximize g over all λ � 0. Again

we can reformulate this by explicitly including the dual feasibility conditions as
constraints, as in

maximize −bTλ
subject to ATλ+ c = 0

λ � 0,
(5.22)

which is an LP in standard form.
Note the interesting symmetry between the standard and inequality form LPs

and their duals: The dual of a standard form LP is an LP with only inequality
constraints, and vice versa. One can also verify that the Lagrange dual of (5.22) is
(equivalent to) the primal problem (5.21).

5.2.2 Weak duality

The optimal value of the Lagrange dual problem, which we denote d⋆, is, by def-
inition, the best lower bound on p⋆ that can be obtained from the Lagrange dual
function. In particular, we have the simple but important inequality

d⋆ ≤ p⋆, (5.23)
which holds even if the original problem is not convex. This property is called weak
duality.

The weak duality inequality (5.23) holds when d⋆ and p⋆ are infinite. For
example, if the primal problem is unbounded below, so that p⋆ = −∞, we must
have d⋆ = −∞, i.e., the Lagrange dual problem is infeasible. Conversely, if the
dual problem is unbounded above, so that d⋆ =∞, we must have p⋆ =∞, i.e., the
primal problem is infeasible.



226 5 Duality

We refer to the difference p⋆ − d⋆ as the optimal duality gap of the original
problem, since it gives the gap between the optimal value of the primal problem
and the best (i.e., greatest) lower bound on it that can be obtained from the
Lagrange dual function. The optimal duality gap is always nonnegative.

The bound (5.23) can sometimes be used to find a lower bound on the optimal
value of a problem that is difficult to solve, since the dual problem is always convex,
and in many cases can be solved efficiently, to find d⋆. As an example, consider
the two-way partitioning problem (5.7) described on page 219. The dual problem
is an SDP,

maximize −1T ν
subject to W + diag(ν) � 0,

with variable ν ∈ Rn. This problem can be solved efficiently, even for relatively
large values of n, such as n = 1000. Its optimal value is a lower bound on the
optimal value of the two-way partitioning problem, and is always at least as good
as the lower bound (5.8) based on λmin(W ).

5.2.3 Strong duality and Slater’s constraint qualification

If the equality
d⋆ = p⋆ (5.24)

holds, i.e., the optimal duality gap is zero, then we say that strong duality holds.
This means that the best bound that can be obtained from the Lagrange dual
function is tight.

Strong duality does not, in general, hold. But if the primal problem (5.1) is
convex, i.e., of the form

minimize f0(x)
subject to fi(x) ≤ 0, i = 1, . . . ,m,

Ax = b,
(5.25)

with f0, . . . , fm convex, we usually (but not always) have strong duality. There are
many results that establish conditions on the problem, beyond convexity, under
which strong duality holds. These conditions are called constraint qualifications.

One simple constraint qualification is Slater’s condition: There exists an x ∈
relintD such that

fi(x) < 0, i = 1, . . . ,m, Ax = b. (5.26)

Such a point is sometimes called strictly feasible, since the inequality constraints
hold with strict inequalities. Slater’s theorem states that strong duality holds, if
Slater’s condition holds (and the problem is convex).

Slater’s condition can be refined when some of the inequality constraint func-
tions fi are affine. If the first k constraint functions f1, . . . , fk are affine, then
strong duality holds provided the following weaker condition holds: There exists
an x ∈ relintD with
fi(x) ≤ 0, i = 1, . . . , k, fi(x) < 0, i = k + 1, . . . ,m, Ax = b. (5.27)



5.2 The Lagrange dual problem 227

In other words, the affine inequalities do not need to hold with strict inequal-
ity. Note that the refined Slater condition (5.27) reduces to feasibility when the
constraints are all linear equalities and inequalities, and dom f0 is open.

Slater’s condition (and the refinement (5.27)) not only implies strong duality
for convex problems. It also implies that the dual optimal value is attained when
d⋆ > −∞, i.e., there exists a dual feasible (λ⋆, ν⋆) with g(λ⋆, ν⋆) = d⋆ = p⋆. We
will prove that strong duality obtains, when the primal problem is convex and
Slater’s condition holds, in §5.3.2.

5.2.4 Examples

Least-squares solution of linear equations

Recall the problem (5.5):
minimize xTx
subject to Ax = b.

The associated dual problem is

maximize −(1/4)νTAAT ν − bT ν,
which is an unconstrained concave quadratic maximization problem.

Slater’s condition is simply that the primal problem is feasible, so p⋆ = d⋆

provided b ∈ R(A), i.e., p⋆ < ∞. In fact for this problem we always have strong
duality, even when p⋆ = ∞. This is the case when b 6∈ R(A), so there is a z with
AT z = 0, bT z 6= 0. It follows that the dual function is unbounded above along the
line {tz | t ∈ R}, so d⋆ =∞ as well.

Lagrange dual of LP

By the weaker form of Slater’s condition, we find that strong duality holds for
any LP (in standard or inequality form) provided the primal problem is feasible.
Applying this result to the duals, we conclude that strong duality holds for LPs
if the dual is feasible. This leaves only one possible situation in which strong
duality for LPs can fail: both the primal and dual problems are infeasible. This
pathological case can, in fact, occur; see exercise 5.23.

Lagrange dual of QCQP

We consider the QCQP

minimize (1/2)xTP0x+ q
T
0 x+ r0

subject to (1/2)xTPix+ q
T
i x+ ri ≤ 0, i = 1, . . . ,m, (5.28)

with P0 ∈ Sn++, and Pi ∈ Sn+, i = 1, . . . ,m. The Lagrangian is
L(x, λ) = (1/2)xTP (λ)x+ q(λ)Tx+ r(λ),

where

P (λ) = P0 +

m∑
i=1

λiPi, q(λ) = q0 +

m∑
i=1

λiqi, r(λ) = r0 +

m∑
i=1

λiri.



228 5 Duality

It is possible to derive an expression for g(λ) for general λ, but it is quite compli-
cated. If λ � 0, however, we have P (λ) ≻ 0 and

g(λ) = inf
x
L(x, λ) = −(1/2)q(λ)TP (λ)−1q(λ) + r(λ).

We can therefore express the dual problem as

maximize −(1/2)q(λ)TP (λ)−1q(λ) + r(λ)
subject to λ � 0. (5.29)

The Slater condition says that strong duality between (5.29) and (5.28) holds if the
quadratic inequality constraints are strictly feasible, i.e., there exists an x with

(1/2)xTPix+ q
T
i x+ ri < 0, i = 1, . . . ,m.

Entropy maximization

Our next example is the entropy maximization problem (5.13):

minimize
∑n

i=1 xi log xi
subject to Ax � b

1Tx = 1,

with domain D = Rn+. The Lagrange dual function was derived on page 222; the
dual problem is

maximize −bTλ− ν − e−ν−1∑ni=1 e−aTi λ
subject to λ � 0, (5.30)

with variables λ ∈ Rm, ν ∈ R. The (weaker) Slater condition for (5.13) tells us
that the optimal duality gap is zero if there exists an x ≻ 0 with Ax � b and
1Tx = 1.

We can simplify the dual problem (5.30) by maximizing over the dual variable
ν analytically. For fixed λ, the objective function is maximized when the derivative
with respect to ν is zero, i.e.,

ν = log

n∑
i=1

e−a
T
i λ − 1.

Substituting this optimal value of ν into the dual problem gives

maximize −bTλ− log
(∑n

i=1 e
−aTi λ

)
subject to λ � 0,

which is a geometric program (in convex form) with nonnegativity constraints.

Minimum volume covering ellipsoid

We consider the problem (5.14):

minimize log detX−1

subject to aTi Xai ≤ 1, i = 1, . . . ,m,



5.2 The Lagrange dual problem 229

with domain D = Sn++. The Lagrange dual function is given by (5.15), so the dual
problem can be expressed as

maximize log det
(∑m

i=1 λiaia
T
i

)− 1Tλ+ n
subject to λ � 0 (5.31)

where we take log detX = −∞ if X 6≻ 0.
The (weaker) Slater condition for the problem (5.14) is that there exists an

X ∈ Sn++ with aTi Xai ≤ 1, for i = 1, . . . ,m. This is always satisfied, so strong
duality always obtains between (5.14) and the dual problem (5.31).

A nonconvex quadratic problem with strong duality

On rare occasions strong duality obtains for a nonconvex problem. As an important
example, we consider the problem of minimizing a nonconvex quadratic function
over the unit ball,

minimize xTAx+ 2bTx
subject to xTx ≤ 1, (5.32)

where A ∈ Sn, A 6� 0, and b ∈ Rn. Since A 6� 0, this is not a convex problem. This
problem is sometimes called the trust region problem, and arises in minimizing a
second-order approximation of a function over the unit ball, which is the region in
which the approximation is assumed to be approximately valid.

The Lagrangian is

L(x, λ) = xTAx+ 2bTx+ λ(xTx− 1) = xT (A+ λI)x+ 2bTx− λ,

so the dual function is given by

g(λ) =

{ −bT (A+ λI)†b− λ A+ λI � 0, b ∈ R(A+ λI)
−∞ otherwise,

where (A + λI)† is the pseudo-inverse of A + λI. The Lagrange dual problem is
thus

maximize −bT (A+ λI)†b− λ
subject to A+ λI � 0, b ∈ R(A+ λI), (5.33)

with variable λ ∈ R. Although it is not obvious from this expression, this is a
convex optimization problem. In fact, it is readily solved since it can be expressed
as

maximize −∑ni=1(qTi b)2/(λi + λ)− λ
subject to λ ≥ −λmin(A),

where λi and qi are the eigenvalues and corresponding (orthonormal) eigenvectors
of A, and we interpret (qTi b)

2/0 as 0 if qTi b = 0 and as ∞ otherwise.
Despite the fact that the original problem (5.32) is not convex, we always have

zero optimal duality gap for this problem: The optimal values of (5.32) and (5.33)
are always the same. In fact, a more general result holds: strong duality holds for
any optimization problem with quadratic objective and one quadratic inequality
constraint, provided Slater’s condition holds; see §B.1.



230 5 Duality

5.2.5 Mixed strategies for matrix games

In this section we use strong duality to derive a basic result for zero-sum matrix
games. We consider a game with two players. Player 1 makes a choice (or move)
k ∈ {1, . . . , n}, and player 2 makes a choice l ∈ {1, . . . ,m}. Player 1 then makes a
payment of Pkl to player 2, where P ∈ Rn×m is the payoff matrix for the game.
The goal of player 1 is to make the payment as small as possible, while the goal of
player 2 is to maximize it.

The players use randomized or mixed strategies, which means that each player
makes his or her choice randomly and independently of the other player’s choice,
according to a probability distribution:

prob(k = i) = ui, i = 1, . . . , n, prob(l = i) = vi, i = 1, . . . ,m.

Here u and v give the probability distributions of the choices of the two players,
i.e., their associated strategies. The expected payoff from player 1 to player 2 is
then

n∑
k=1

m∑
l=1

ukvlPkl = u
TPv.

Player 1 wishes to choose u to minimize uTPv, while player 2 wishes to choose v
to maximize uTPv.

Let us first analyze the game from the point of view of player 1, assuming her
strategy u is known to player 2 (which clearly gives an advantage to player 2).
Player 2 will choose v to maximize uTPv, which results in the expected payoff

sup{uTPv | v � 0, 1T v = 1} = max
i=1,...,m

(PTu)i.

The best thing player 1 can do is to choose u to minimize this worst-case payoff to
player 2, i.e., to choose a strategy u that solves the problem

minimize maxi=1,...,m(P
Tu)i

subject to u � 0, 1Tu = 1, (5.34)

which is a piecewise-linear convex optimization problem. We will denote the opti-
mal value of this problem as p⋆1. This is the smallest expected payoff player 1 can
arrange to have, assuming that player 2 knows the strategy of player 1, and plays
to his own maximum advantage.

In a similar way we can consider the situation in which v, the strategy of
player 2, is known to player 1 (which gives an advantage to player 1). In this case
player 1 chooses u to minimize uTPv, which results in an expected payoff of

inf{uTPv | u � 0, 1Tu = 1} = min
i=1,...,n

(Pv)i.

Player 2 chooses v to maximize this, i.e., chooses a strategy v that solves the
problem

maximize mini=1,...,n(Pv)i
subject to v � 0, 1T v = 1, (5.35)



5.2 The Lagrange dual problem 231

which is another convex optimization problem, with piecewise-linear (concave) ob-
jective. We will denote the optimal value of this problem as p⋆2. This is the largest
expected payoff player 2 can guarantee getting, assuming that player 1 knows the
strategy of player 2.

It is intuitively obvious that knowing your opponent’s strategy gives an advan-
tage (or at least, cannot hurt), and indeed, it is easily shown that we always have
p⋆1 ≥ p⋆2. We can interpret the difference, p⋆1 − p⋆2, which is nonnegative, as the
advantage conferred on a player by knowing the opponent’s strategy.

Using duality, we can establish a result that is at first surprising: p⋆1 = p
⋆
2.

In other words, in a matrix game with mixed strategies, there is no advantage to
knowing your opponent’s strategy. We will establish this result by showing that
the two problems (5.34) and (5.35) are Lagrange dual problems, for which strong
duality obtains.

We start by formulating (5.34) as an LP,

minimize t
subject to u � 0, 1Tu = 1

PTu � t1,

with extra variable t ∈ R. Introducing the multiplier λ for PTu � t1, µ for u � 0,
and ν for 1Tu = 1, the Lagrangian is

t+ λT (PTu− t1)− µTu+ ν(1− 1Tu) = ν + (1− 1Tλ)t+ (Pλ− ν1− µ)Tu,

so the dual function is

g(λ, µ, ν) =

{
ν 1Tλ = 1, Pλ− ν1 = µ
−∞ otherwise.

The dual problem is then

maximize ν
subject to λ � 0, 1Tλ = 1, µ � 0

Pλ− ν1 = µ.

Eliminating µ we obtain the following Lagrange dual of (5.34):

maximize ν
subject to λ � 0, 1Tλ = 1

Pλ � ν1,

with variables λ, ν. But this is clearly equivalent to (5.35). Since the LPs are
feasible, we have strong duality; the optimal values of (5.34) and (5.35) are equal.



232 5 Duality

5.3 Geometric interpretation

5.3.1 Weak and strong duality via set of values

We can give a simple geometric interpretation of the dual function in terms of the
set

G = {(f1(x), . . . , fm(x), h1(x), . . . , hp(x), f0(x)) ∈ Rm ×Rp ×R | x ∈ D}, (5.36)
which is the set of values taken on by the constraint and objective functions. The
optimal value p⋆ of (5.1) is easily expressed in terms of G as

p⋆ = inf{t | (u, v, t) ∈ G, u � 0, v = 0}.
To evaluate the dual function at (λ, ν), we minimize the affine function

(λ, ν, 1)T (u, v, t) =
m∑
i=1

λiui +

p∑
i=1

νivi + t

over (u, v, t) ∈ G, i.e., we have
g(λ, ν) = inf{(λ, ν, 1)T (u, v, t) | (u, v, t) ∈ G}.

In particular, we see that if the infimum is finite, then the inequality

(λ, ν, 1)T (u, v, t) ≥ g(λ, ν)
defines a supporting hyperplane to G. This is sometimes referred to as a nonvertical
supporting hyperplane, because the last component of the normal vector is nonzero.

Now suppose λ � 0. Then, obviously, t ≥ (λ, ν, 1)T (u, v, t) if u � 0 and v = 0.
Therefore

p⋆ = inf{t | (u, v, t) ∈ G, u � 0, v = 0}
≥ inf{(λ, ν, 1)T (u, v, t) | (u, v, t) ∈ G, u � 0, v = 0}
≥ inf{(λ, ν, 1)T (u, v, t) | (u, v, t) ∈ G}
= g(λ, ν),

i.e., we have weak duality. This interpretation is illustrated in figures 5.3 and 5.4,
for a simple problem with one inequality constraint.

Epigraph variation

In this section we describe a variation on the geometric interpretation of duality in
terms of G, which explains why strong duality obtains for (most) convex problems.
We define the set A ⊆ Rm ×Rp ×R as

A = G + (Rm+ × {0} ×R+) , (5.37)
or, more explicitly,

A = {(u, v, t) | ∃x ∈ D, fi(x) ≤ ui, i = 1, . . . ,m,
hi(x) = vi, i = 1, . . . , p, f0(x) ≤ t},



5.3 Geometric interpretation 233

G

p⋆

g(λ)
λu+ t = g(λ)

t

u

Figure 5.3 Geometric interpretation of dual function and lower bound g(λ) ≤
p⋆, for a problem with one (inequality) constraint. Given λ, we minimize
(λ, 1)T (u, t) over G = {(f1(x), f0(x)) | x ∈ D}. This yields a supporting
hyperplane with slope −λ. The intersection of this hyperplane with the
u = 0 axis gives g(λ).

G

p⋆

d⋆λ1u+ t = g(λ1)

λ2u+ t = g(λ2)

λ⋆u+ t = g(λ⋆)

t

u

Figure 5.4 Supporting hyperplanes corresponding to three dual feasible val-
ues of λ, including the optimum λ⋆. Strong duality does not hold; the
optimal duality gap p⋆ − d⋆ is positive.



234 5 Duality

A

(0, p⋆)

(0, g(λ))

λu+ t = g(λ)

t

u

Figure 5.5 Geometric interpretation of dual function and lower bound g(λ) ≤
p⋆, for a problem with one (inequality) constraint. Given λ, we minimize
(λ, 1)T (u, t) over A = {(u, t) | ∃x ∈ D, f0(x) ≤ t, f1(x) ≤ u}. This yields
a supporting hyperplane with slope −λ. The intersection of this hyperplane
with the u = 0 axis gives g(λ).

We can think of A as a sort of epigraph form of G, since A includes all the points in
G, as well as points that are ‘worse’, i.e., those with larger objective or inequality
constraint function values.

We can express the optimal value in terms of A as
p⋆ = inf{t | (0, 0, t) ∈ A}.

To evaluate the dual function at a point (λ, ν) with λ � 0, we can minimize the
affine function (λ, ν, 1)T (u, v, t) over A: If λ � 0, then

g(λ, ν) = inf{(λ, ν, 1)T (u, v, t) | (u, v, t) ∈ A}.
If the infimum is finite, then

(λ, ν, 1)T (u, v, t) ≥ g(λ, ν)
defines a nonvertical supporting hyperplane to A.

In particular, since (0, 0, p⋆) ∈ bdA, we have
p⋆ = (λ, ν, 1)T (0, 0, p⋆) ≥ g(λ, ν), (5.38)

the weak duality lower bound. Strong duality holds if and only if we have equality
in (5.38) for some dual feasible (λ, ν), i.e., there exists a nonvertical supporting
hyperplane to A at its boundary point (0, 0, p⋆).

This second interpretation is illustrated in figure 5.5.

5.3.2 Proof of strong duality under constraint qualification

In this section we prove that Slater’s constraint qualification guarantees strong
duality (and that the dual optimum is attained) for a convex problem. We consider



5.3 Geometric interpretation 235

the primal problem (5.25), with f0, . . . , fm convex, and assume Slater’s condition
holds: There exists x˜ ∈ relintD with fi(x˜) < 0, i = 1, . . . ,m, and Ax˜ = b. In
order to simplify the proof, we make two additional assumptions: first that D has
nonempty interior (hence, relintD = intD) and second, that rankA = p. We
assume that p⋆ is finite. (Since there is a feasible point, we can only have p⋆ = −∞
or p⋆ finite; if p⋆ = −∞, then d⋆ = −∞ by weak duality.)

The set A defined in (5.37) is readily shown to be convex if the underlying
problem is convex. We define a second convex set B as

B = {(0, 0, s) ∈ Rm ×Rp ×R | s < p⋆}.

The sets A and B do not intersect. To see this, suppose (u, v, t) ∈ A ∩ B. Since
(u, v, t) ∈ B we have u = 0, v = 0, and t < p⋆. Since (u, v, t) ∈ A, there exists an x
with fi(x) ≤ 0, i = 1, . . . ,m, Ax− b = 0, and f0(x) ≤ t < p⋆, which is impossible
since p⋆ is the optimal value of the primal problem.

By the separating hyperplane theorem of §2.5.1 there exists (λ˜, ν˜, µ) 6= 0 and α
such that

(u, v, t) ∈ A =⇒ λ˜Tu+ ν˜T v + µt ≥ α, (5.39)
and

(u, v, t) ∈ B =⇒ λ˜Tu+ ν˜T v + µt ≤ α. (5.40)
From (5.39) we conclude that λ˜ � 0 and µ ≥ 0. (Otherwise λ˜Tu+µt is unbounded
below overA, contradicting (5.39).) The condition (5.40) simply means that µt ≤ α
for all t < p⋆, and hence, µp⋆ ≤ α. Together with (5.39) we conclude that for any
x ∈ D,

m∑
i=1

λ˜ifi(x) + ν˜
T (Ax− b) + µf0(x) ≥ α ≥ µp⋆. (5.41)

Assume that µ > 0. In that case we can divide (5.41) by µ to obtain

L(x, λ˜/µ, ν˜/µ) ≥ p⋆

for all x ∈ D, from which it follows, by minimizing over x, that g(λ, ν) ≥ p⋆, where
we define

λ = λ˜/µ, ν = ν˜/µ.

By weak duality we have g(λ, ν) ≤ p⋆, so in fact g(λ, ν) = p⋆. This shows that
strong duality holds, and that the dual optimum is attained, at least in the case
when µ > 0.

Now consider the case µ = 0. From (5.41), we conclude that for all x ∈ D,
m∑
i=1

λ˜ifi(x) + ν˜
T (Ax− b) ≥ 0. (5.42)

Applying this to the point x˜ that satisfies the Slater condition, we have

m∑
i=1

λ˜ifi(x˜) ≥ 0.



236 5 Duality

A

B
u

t

(u˜, t˜)

Figure 5.6 Illustration of strong duality proof, for a convex problem that sat-
isfies Slater’s constraint qualification. The set A is shown shaded, and the
set B is the thick vertical line segment, not including the point (0, p⋆), shown
as a small open circle. The two sets are convex and do not intersect, so they
can be separated by a hyperplane. Slater’s constraint qualification guaran-
tees that any separating hyperplane must be nonvertical, since it must pass
to the left of the point (u˜, t˜) = (f1(x˜), f0(x˜)), where x˜ is strictly feasible.

Since fi(x˜) < 0 and λ˜i ≥ 0, we conclude that λ˜ = 0. From (λ˜, ν˜, µ) 6= 0 and
λ˜ = 0, µ = 0, we conclude that ν˜ 6= 0. Then (5.42) implies that for all x ∈ D,
ν˜T (Ax − b) ≥ 0. But x˜ satisfies ν˜T (Ax˜ − b) = 0, and since x˜ ∈ intD, there are
points in D with ν˜T (Ax− b) < 0 unless AT ν˜ = 0. This, of course, contradicts our
assumption that rankA = p.

The geometric idea behind the proof is illustrated in figure 5.6, for a simple
problem with one inequality constraint. The hyperplane separating A and B defines
a supporting hyperplane to A at (0, p⋆). Slater’s constraint qualification is used
to establish that the hyperplane must be nonvertical (i.e., has a normal vector of
the form (λ⋆, 1)). (For a simple example of a convex problem with one inequality
constraint for which strong duality fails, see exercise 5.21.)

5.3.3 Multicriterion interpretation

There is a natural connection between Lagrange duality for a problem without
equality constraints,

minimize f0(x)
subject to fi(x) ≤ 0, i = 1, . . . ,m, (5.43)



5.4 Saddle-point interpretation 237

and the scalarization method for the (unconstrained) multicriterion problem

minimize (w.r.t. Rm+1+ ) F (x) = (f1(x), . . . , fm(x), f0(x)) (5.44)

(see §4.7.4). In scalarization, we choose a positive vector λ˜, and minimize the scalar
function λ˜TF (x); any minimizer is guaranteed to be Pareto optimal. Since we can
scale λ˜ by a positive constant, without affecting the minimizers, we can, without
loss of generality, take λ˜ = (λ, 1). Thus, in scalarization we minimize the function

λ˜TF (x) = f0(x) +
m∑
i=1

λifi(x),

which is exactly the Lagrangian for the problem (5.43).

To establish that every Pareto optimal point of a convex multicriterion problem
minimizes the function λ˜TF (x) for some nonnegative weight vector λ˜, we considered
the set A, defined in (4.62),

A = {t ∈ Rm+1 | ∃x ∈ D, fi(x) ≤ ti, i = 0, . . . ,m},

which is exactly the same as the setA defined in (5.37), that arises in Lagrange dual-
ity. Here too we constructed the required weight vector as a supporting hyperplane
to the set, at an arbitrary Pareto optimal point. In multicriterion optimization,
we interpret the components of the weight vector as giving the relative weights
between the objective functions. When we fix the last component of the weight
vector (associated with f0) to be one, the other weights have the interpretation of
the cost relative to f0, i.e., the cost relative to the objective.

5.4 Saddle-point interpretation

In this section we give several interpretations of Lagrange duality. The material of
this section will not be used in the sequel.

5.4.1 Max-min characterization of weak and strong duality

It is possible to express the primal and the dual optimization problems in a form
that is more symmetric. To simplify the discussion we assume there are no equality
constraints; the results are easily extended to cover them.

First note that

sup
λ�0

L(x, λ) = sup
λ�0

(
f0(x) +

m∑
i=1

λifi(x)

)

=

{
f0(x) fi(x) ≤ 0, i = 1, . . . ,m
∞ otherwise.



238 5 Duality

Indeed, suppose x is not feasible, and fi(x) > 0 for some i. Then supλ�0 L(x, λ) =
∞, as can be seen by choosing λj = 0, j 6= i, and λi → ∞. On the other
hand, if fi(x) ≤ 0, i = 1, . . . ,m, then the optimal choice of λ is λ = 0 and
supλ�0 L(x, λ) = f0(x). This means that we can express the optimal value of the
primal problem as

p⋆ = inf
x

sup
λ�0

L(x, λ).

By the definition of the dual function, we also have

d⋆ = sup
λ�0

inf
x
L(x, λ).

Thus, weak duality can be expressed as the inequality

sup
λ�0

inf
x
L(x, λ) ≤ inf

x
sup
λ�0

L(x, λ), (5.45)

and strong duality as the equality

sup
λ�0

inf
x
L(x, λ) = inf

x
sup
λ�0

L(x, λ).

Strong duality means that the order of the minimization over x and the maximiza-
tion over λ � 0 can be switched without affecting the result.

In fact, the inequality (5.45) does not depend on any properties of L: We have

sup
z∈Z

inf
w∈W

f(w, z) ≤ inf
w∈W

sup
z∈Z

f(w, z) (5.46)

for any f : Rn×Rm → R (and anyW ⊆ Rn and Z ⊆ Rm). This general inequality
is called the max-min inequality. When equality holds, i.e.,

sup
z∈Z

inf
w∈W

f(w, z) = inf
w∈W

sup
z∈Z

f(w, z) (5.47)

we say that f (and W and Z) satisfy the strong max-min property or the saddle-
point property. Of course the strong max-min property holds only in special cases,
for example, when f : Rn × Rm → R is the Lagrangian of a problem for which
strong duality obtains, W = Rn, and Z = Rm+ .

5.4.2 Saddle-point interpretation

We refer to a pair w˜ ∈W , z˜ ∈ Z as a saddle-point for f (and W and Z) if

f(w˜, z) ≤ f(w˜, z˜) ≤ f(w, z˜)

for all w ∈ W and z ∈ Z. In other words, w˜ minimizes f(w, z˜) (over w ∈ W ) and
z˜ maximizes f(w˜, z) (over z ∈ Z):

f(w˜, z˜) = inf
w∈W

f(w, z˜), f(w˜, z˜) = sup
z∈Z

f(w˜, z).



5.4 Saddle-point interpretation 239

This implies that the strong max-min property (5.47) holds, and that the common
value is f(w˜, z˜).

Returning to our discussion of Lagrange duality, we see that if x⋆ and λ⋆ are
primal and dual optimal points for a problem in which strong duality obtains, they
form a saddle-point for the Lagrangian. The converse is also true: If (x, λ) is a
saddle-point of the Lagrangian, then x is primal optimal, λ is dual optimal, and
the optimal duality gap is zero.

5.4.3 Game interpretation

We can interpret the max-min inequality (5.46), the max-min equality (5.47), and
the saddle-point property, in terms of a continuous zero-sum game. If the first
player chooses w ∈ W , and the second player selects z ∈ Z, then player 1 pays an
amount f(w, z) to player 2. Player 1 therefore wants to minimize f , while player 2
wants to maximize f . (The game is called continuous since the choices are vectors,
and not discrete.)

Suppose that player 1 makes his choice first, and then player 2, after learning
the choice of player 1, makes her selection. Player 2 wants to maximize the payoff
f(w, z), and so will choose z ∈ Z to maximize f(w, z). The resulting payoff will
be supz∈Z f(w, z), which depends on w, the choice of the first player. (We assume
here that the supremum is achieved; if not the optimal payoff can be arbitrarily
close to supz∈Z f(w, z).) Player 1 knows (or assumes) that player 2 will follow this
strategy, and so will choose w ∈ W to make this worst-case payoff to player 2 as
small as possible. Thus player 1 chooses

argmin
w∈W

sup
z∈Z

f(w, z),

which results in the payoff
inf
w∈W

sup
z∈Z

f(w, z)

from player 1 to player 2.
Now suppose the order of play is reversed: Player 2 must choose z ∈ Z first, and

then player 1 chooses w ∈W (with knowledge of z). Following a similar argument,
if the players follow the optimal strategy, player 2 should choose z ∈ Z to maximize
infw∈W f(w, z), which results in the payoff of

sup
z∈Z

inf
w∈W

f(w, z)

from player 1 to player 2.
The max-min inequality (5.46) states the (intuitively obvious) fact that it is

better for a player to go second, or more precisely, for a player to know his or her
opponent’s choice before choosing. In other words, the payoff to player 2 will be
larger if player 1 must choose first. When the saddle-point property (5.47) holds,
there is no advantage to playing second.

If (w˜, z˜) is a saddle-point for f (and W and Z), then it is called a solution of
the game; w˜ is called the optimal choice or strategy for player 1, and z˜ is called



240 5 Duality

the optimal choice or strategy for player 2. In this case there is no advantage to
playing second.

Now consider the special case where the payoff function is the Lagrangian,
W = Rn and Z = Rm+ . Here player 1 chooses the primal variable x, while player 2
chooses the dual variable λ � 0. By the argument above, the optimal choice for
player 2, if she must choose first, is any λ⋆ which is dual optimal, which results
in a payoff to player 2 of d⋆. Conversely, if player 1 must choose first, his optimal
choice is any primal optimal x⋆, which results in a payoff of p⋆.

The optimal duality gap for the problem is exactly equal to the advantage
afforded the player who goes second, i.e., the player who has the advantage of
knowing his or her opponent’s choice before choosing. If strong duality holds, then
there is no advantage to the players of knowing their opponent’s choice.

5.4.4 Price or tax interpretation

Lagrange duality has an interesting economic interpretation. Suppose the variable
x denotes how an enterprise operates and f0(x) denotes the cost of operating at
x, i.e., −f0(x) is the profit (say, in dollars) made at the operating condition x.
Each constraint fi(x) ≤ 0 represents some limit, such as a limit on resources (e.g.,
warehouse space, labor) or a regulatory limit (e.g., environmental). The operating
condition that maximizes profit while respecting the limits can be found by solving
the problem

minimize f0(x)
subject to fi(x) ≤ 0, i = 1, . . . ,m.

The resulting optimal profit is −p⋆.
Now imagine a second scenario in which the limits can be violated, by paying an

additional cost which is linear in the amount of violation, measured by fi. Thus the
payment made by the enterprise for the ith limit or constraint is λifi(x). Payments
are also made to the firm for constraints that are not tight; if fi(x) < 0, then λifi(x)
represents a payment to the firm. The coefficient λi has the interpretation of the
price for violating fi(x) ≤ 0; its units are dollars per unit violation (as measured
by fi). For the same price the enterprise can sell any ‘unused’ portion of the ith
constraint. We assume λi ≥ 0, i.e., the firm must pay for violations (and receives
income if a constraint is not tight).

As an example, suppose the first constraint in the original problem, f1(x) ≤
0, represents a limit on warehouse space (say, in square meters). In this new
arrangement, we open the possibility that the firm can rent extra warehouse space
at a cost of λ1 dollars per square meter and also rent out unused space, at the same
rate.

The total cost to the firm, for operating condition x, and constraint prices
λi, is L(x, λ) = f0(x) +

∑m
i=1 λifi(x). The firm will obviously operate so as to

minimize its total cost L(x, λ), which yields a cost g(λ). The dual function therefore
represents the optimal cost to the firm, as a function of the constraint price vector
λ. The optimal dual value, d⋆, is the optimal cost to the enterprise under the least
favorable set of prices.



5.5 Optimality conditions 241

Using this interpretation we can paraphrase weak duality as follows: The opti-
mal cost to the firm in the second scenario (in which constraint violations can be
bought and sold) is less than or equal to the cost in the original situation (which
has constraints that cannot be violated), even with the most unfavorable prices.
This is obvious: If x⋆ is optimal in the first scenario, then the operating cost of x⋆

in the second scenario will be lower than f0(x
⋆), since some income can be derived

from the constraints that are not tight. The optimal duality gap is then the min-
imum possible advantage to the enterprise of being allowed to pay for constraint
violations (and receive payments for nontight constraints).

Now suppose strong duality holds, and the dual optimum is attained. We can
interpret a dual optimal λ⋆ as a set of prices for which there is no advantage to
the firm in being allowed to pay for constraint violations (or receive payments for
nontight constraints). For this reason a dual optimal λ⋆ is sometimes called a set
of shadow prices for the original problem.

5.5 Optimality conditions

We remind the reader that we do not assume the problem (5.1) is convex, unless
explicitly stated.

5.5.1 Certificate of suboptimality and stopping criteria

If we can find a dual feasible (λ, ν), we establish a lower bound on the optimal value
of the primal problem: p⋆ ≥ g(λ, ν). Thus a dual feasible point (λ, ν) provides a
proof or certificate that p⋆ ≥ g(λ, ν). Strong duality means there exist arbitrarily
good certificates.

Dual feasible points allow us to bound how suboptimal a given feasible point
is, without knowing the exact value of p⋆. Indeed, if x is primal feasible and (λ, ν)
is dual feasible, then

f0(x)− p⋆ ≤ f0(x)− g(λ, ν).
In particular, this establishes that x is ǫ-suboptimal, with ǫ = f0(x)− g(λ, ν). (It
also establishes that (λ, ν) is ǫ-suboptimal for the dual problem.)

We refer to the gap between primal and dual objectives,

f0(x)− g(λ, ν),
as the duality gap associated with the primal feasible point x and dual feasible
point (λ, ν). A primal dual feasible pair x, (λ, ν) localizes the optimal value of the
primal (and dual) problems to an interval:

p⋆ ∈ [g(λ, ν), f0(x)], d⋆ ∈ [g(λ, ν), f0(x)],
the width of which is the duality gap.

If the duality gap of the primal dual feasible pair x, (λ, ν) is zero, i.e., f0(x) =
g(λ, ν), then x is primal optimal and (λ, ν) is dual optimal. We can think of (λ, ν)



242 5 Duality

as a certificate that proves x is optimal (and, similarly, we can think of x as a
certificate that proves (λ, ν) is dual optimal).

These observations can be used in optimization algorithms to provide nonheuris-
tic stopping criteria. Suppose an algorithm produces a sequence of primal feasible
x(k) and dual feasible (λ(k), ν(k)), for k = 1, 2, . . ., and ǫabs > 0 is a given required
absolute accuracy. Then the stopping criterion (i.e., the condition for terminating
the algorithm)

f0(x
(k))− g(λ(k), ν(k)) ≤ ǫabs

guarantees that when the algorithm terminates, x(k) is ǫabs-suboptimal. Indeed,
(λ(k), ν(k)) is a certificate that proves it. (Of course strong duality must hold if
this method is to work for arbitrarily small tolerances ǫabs.)

A similar condition can be used to guarantee a given relative accuracy ǫrel > 0.
If

g(λ(k), ν(k)) > 0,
f0(x

(k))− g(λ(k), ν(k))
g(λ(k), ν(k))

≤ ǫrel

holds, or

f0(x
(k)) < 0,

f0(x
(k))− g(λ(k), ν(k))
−f0(x(k)) ≤ ǫrel

holds, then p⋆ 6= 0 and the relative error

f0(x
(k))− p⋆
|p⋆|

is guaranteed to be less than or equal to ǫrel.

5.5.2 Complementary slackness

Suppose that the primal and dual optimal values are attained and equal (so, in
particular, strong duality holds). Let x⋆ be a primal optimal and (λ⋆, ν⋆) be a dual
optimal point. This means that

f0(x
⋆) = g(λ⋆, ν⋆)

= inf
x

(
f0(x) +

m∑
i=1

λ⋆i fi(x) +

p∑
i=1

ν⋆i hi(x)

)

≤ f0(x⋆) +
m∑
i=1

λ⋆i fi(x
⋆) +

p∑
i=1

ν⋆i hi(x
⋆)

≤ f0(x⋆).

The first line states that the optimal duality gap is zero, and the second line is
the definition of the dual function. The third line follows since the infimum of the
Lagrangian over x is less than or equal to its value at x = x⋆. The last inequality
follows from λ⋆i ≥ 0, fi(x⋆) ≤ 0, i = 1, . . . ,m, and hi(x⋆) = 0, i = 1, . . . , p. We
conclude that the two inequalities in this chain hold with equality.



5.5 Optimality conditions 243

We can draw several interesting conclusions from this. For example, since the
inequality in the third line is an equality, we conclude that x⋆ minimizes L(x, λ⋆, ν⋆)
over x. (The Lagrangian L(x, λ⋆, ν⋆) can have other minimizers; x⋆ is simply a
minimizer.)

Another important conclusion is that

m∑
i=1

λ⋆i fi(x
⋆) = 0.

Since each term in this sum is nonpositive, we conclude that

λ⋆i fi(x
⋆) = 0, i = 1, . . . ,m. (5.48)

This condition is known as complementary slackness ; it holds for any primal opti-
mal x⋆ and any dual optimal (λ⋆, ν⋆) (when strong duality holds). We can express
the complementary slackness condition as

λ⋆i > 0 =⇒ fi(x⋆) = 0,
or, equivalently,

fi(x
⋆) < 0 =⇒ λ⋆i = 0.

Roughly speaking, this means the ith optimal Lagrange multiplier is zero unless
the ith constraint is active at the optimum.

5.5.3 KKT optimality conditions

We now assume that the functions f0, . . . , fm, h1, . . . , hp are differentiable (and
therefore have open domains), but we make no assumptions yet about convexity.

KKT conditions for nonconvex problems

As above, let x⋆ and (λ⋆, ν⋆) be any primal and dual optimal points with zero
duality gap. Since x⋆ minimizes L(x, λ⋆, ν⋆) over x, it follows that its gradient
must vanish at x⋆, i.e.,

∇f0(x⋆) +
m∑
i=1

λ⋆i∇fi(x⋆) +
p∑
i=1

ν⋆i∇hi(x⋆) = 0.

Thus we have

fi(x
⋆) ≤ 0, i = 1, . . . ,m

hi(x
⋆) = 0, i = 1, . . . , p
λ⋆i ≥ 0, i = 1, . . . ,m

λ⋆i fi(x
⋆) = 0, i = 1, . . . ,m

∇f0(x⋆) +
∑m

i=1 λ
⋆
i∇fi(x⋆) +

∑p
i=1 ν

⋆
i∇hi(x⋆) = 0,

(5.49)

which are called the Karush-Kuhn-Tucker (KKT) conditions.
To summarize, for any optimization problem with differentiable objective and

constraint functions for which strong duality obtains, any pair of primal and dual
optimal points must satisfy the KKT conditions (5.49).



244 5 Duality

KKT conditions for convex problems

When the primal problem is convex, the KKT conditions are also sufficient for the
points to be primal and dual optimal. In other words, if fi are convex and hi are
affine, and x˜, λ˜, ν˜ are any points that satisfy the KKT conditions

fi(x˜) ≤ 0, i = 1, . . . ,m
hi(x˜) = 0, i = 1, . . . , p

λ˜i ≥ 0, i = 1, . . . ,m
λ˜ifi(x˜) = 0, i = 1, . . . ,m

∇f0(x˜) +
∑m

i=1 λ˜i∇fi(x˜) +
∑p

i=1 ν˜i∇hi(x˜) = 0,
then x˜ and (λ˜, ν˜) are primal and dual optimal, with zero duality gap.

To see this, note that the first two conditions state that x˜ is primal feasible.
Since λ˜i ≥ 0, L(x, λ˜, ν˜) is convex in x; the last KKT condition states that its
gradient with respect to x vanishes at x = x˜, so it follows that x˜minimizes L(x, λ˜, ν˜)
over x. From this we conclude that

g(λ˜, ν˜) = L(x˜, λ˜, ν˜)

= f0(x˜) +

m∑
i=1

λ˜ifi(x˜) +

p∑
i=1

ν˜ihi(x˜)

= f0(x˜),

where in the last line we use hi(x˜) = 0 and λ˜ifi(x˜) = 0. This shows that x˜
and (λ˜, ν˜) have zero duality gap, and therefore are primal and dual optimal. In
summary, for any convex optimization problem with differentiable objective and
constraint functions, any points that satisfy the KKT conditions are primal and
dual optimal, and have zero duality gap.

If a convex optimization problem with differentiable objective and constraint
functions satisfies Slater’s condition, then the KKT conditions provide necessary
and sufficient conditions for optimality: Slater’s condition implies that the optimal
duality gap is zero and the dual optimum is attained, so x is optimal if and only if
there are (λ, ν) that, together with x, satisfy the KKT conditions.

The KKT conditions play an important role in optimization. In a few special
cases it is possible to solve the KKT conditions (and therefore, the optimization
problem) analytically. More generally, many algorithms for convex optimization are
conceived as, or can be interpreted as, methods for solving the KKT conditions.

Example 5.1 Equality constrained convex quadratic minimization. We consider the
problem

minimize (1/2)xTPx+ qTx+ r
subject to Ax = b,

(5.50)

where P ∈ Sn+. The KKT conditions for this problem are
Ax⋆ = b, Px⋆ + q +AT ν⋆ = 0,

which we can write as [
P AT

A 0

][
x⋆

ν⋆

]
=

[
−q
b

]
.



5.5 Optimality conditions 245

Solving this set of m + n equations in the m + n variables x⋆, ν⋆ gives the optimal
primal and dual variables for (5.50).

Example 5.2 Water-filling. We consider the convex optimization problem

minimize −∑n
i=1

log(αi + xi)
subject to x � 0, 1Tx = 1,

where αi > 0. This problem arises in information theory, in allocating power to a
set of n communication channels. The variable xi represents the transmitter power
allocated to the ith channel, and log(αi + xi) gives the capacity or communication
rate of the channel, so the problem is to allocate a total power of one to the channels,
in order to maximize the total communication rate.

Introducing Lagrange multipliers λ⋆ ∈ Rn for the inequality constraints x⋆ � 0,
and a multiplier ν⋆ ∈ R for the equality constraint 1Tx = 1, we obtain the KKT
conditions

x⋆ � 0, 1Tx⋆ = 1, λ⋆ � 0, λ⋆i x⋆i = 0, i = 1, . . . , n,

−1/(αi + x⋆i )− λ⋆i + ν⋆ = 0, i = 1, . . . , n.
We can directly solve these equations to find x⋆, λ⋆, and ν⋆. We start by noting that
λ⋆ acts as a slack variable in the last equation, so it can be eliminated, leaving

x⋆ � 0, 1Tx⋆ = 1, x⋆i (ν⋆ − 1/(αi + x⋆i )) = 0, i = 1, . . . , n,

ν⋆ ≥ 1/(αi + x⋆i ), i = 1, . . . , n.
If ν⋆ < 1/αi, this last condition can only hold if x

⋆
i > 0, which by the third condition

implies that ν⋆ = 1/(αi + x
⋆
i ). Solving for x

⋆
i , we conclude that x

⋆
i = 1/ν

⋆ − αi
if ν⋆ < 1/αi. If ν

⋆ ≥ 1/αi, then x⋆i > 0 is impossible, because it would imply
ν⋆ ≥ 1/αi > 1/(αi + x⋆i ), which violates the complementary slackness condition.
Therefore, x⋆i = 0 if ν

⋆ ≥ 1/αi. Thus we have

x⋆i =

{
1/ν⋆ − αi ν⋆ < 1/αi
0 ν⋆ ≥ 1/αi,

or, put more simply, x⋆i = max {0, 1/ν⋆ − αi}. Substituting this expression for x⋆i
into the condition 1Tx⋆ = 1 we obtain

n∑
i=1

max{0, 1/ν⋆ − αi} = 1.

The lefthand side is a piecewise-linear increasing function of 1/ν⋆, with breakpoints
at αi, so the equation has a unique solution which is readily determined.

This solution method is called water-filling for the following reason. We think of
αi as the ground level above patch i, and then flood the region with water to a
depth 1/ν, as illustrated in figure 5.7. The total amount of water used is then∑n

i=1
max{0, 1/ν⋆ − αi}. We then increase the flood level until we have used a total

amount of water equal to one. The depth of water above patch i is then the optimal
value x⋆i .



246 5 Duality

i

1/ν⋆
xi

αi

Figure 5.7 Illustration of water-filling algorithm. The height of each patch is
given by αi. The region is flooded to a level 1/ν

⋆ which uses a total quantity
of water equal to one. The height of the water (shown shaded) above each
patch is the optimal value of x⋆i .

x1

x2

l

w w

Figure 5.8 Two blocks connected by springs to each other, and the left and
right walls. The blocks have width w > 0, and cannot penetrate each other
or the walls.

5.5.4 Mechanics interpretation of KKT conditions

The KKT conditions can be given a nice interpretation in mechanics (which indeed,
was one of Lagrange’s primary motivations). We illustrate the idea with a simple
example. The system shown in figure 5.8 consists of two blocks attached to each
other, and to walls at the left and right, by three springs. The position of the
blocks are given by x ∈ R2, where x1 is the displacement of the (middle of the) left
block, and x2 is the displacement of the right block. The left wall is at position 0,
and the right wall is at position l.

The potential energy in the springs, as a function of the block positions, is given
by

f0(x1, x2) =
1

2
k1x

2
1 +

1

2
k2(x2 − x1)2 + 1

2
k3(l − x2)2,

where ki > 0 are the stiffness constants of the three springs. The equilibrium
position x⋆ is the position that minimizes the potential energy subject to the in-
equalities

w/2− x1 ≤ 0, w + x1 − x2 ≤ 0, w/2− l + x2 ≤ 0. (5.51)



5.5 Optimality conditions 247

λ1 λ2
k2(x2 − x1)k1x1

λ2 λ3
k3(l − x2)k2(x2 − x1)

Figure 5.9 Force analysis of the block-spring system. The total force on
each block, due to the springs and also to contact forces, must be zero. The
Lagrange multipliers, shown on top, are the contact forces between the walls
and blocks. The spring forces are shown at bottom.

These constraints are called kinematic constraints, and express the fact that the
blocks have width w > 0, and cannot penetrate each other or the walls. The
equilibrium position is therefore given by the solution of the optimization problem

minimize (1/2)
(
k1x

2
1 + k2(x2 − x1)2 + k3(l − x2)2

)
subject to w/2− x1 ≤ 0

w + x1 − x2 ≤ 0
w/2− l + x2 ≤ 0,

(5.52)

which is a QP.

With λ1, λ2, λ3 as Lagrange multipliers, the KKT conditions for this problem
consist of the kinematic constraints (5.51), the nonnegativity constraints λi ≥ 0,
the complementary slackness conditions

λ1(w/2− x1) = 0, λ2(w − x2 + x1) = 0, λ3(w/2− l + x2) = 0, (5.53)

and the zero gradient condition[
k1x1 − k2(x2 − x1)

k2(x2 − x1)− k3(l − x2)
]
+ λ1

[ −1
0

]
+ λ2

[
1
−1

]
+ λ3

[
0
1

]
= 0. (5.54)

The equation (5.54) can be interpreted as the force balance equations for the two
blocks, provided we interpret the Lagrange multipliers as contact forces that act
between the walls and blocks, as illustrated in figure 5.9. The first equation states
that the sum of the forces on the first block is zero: The term −k1x1 is the force
exerted on the left block by the left spring, the term k2(x2−x1) is the force exerted
by the middle spring, λ1 is the force exerted by the left wall, and −λ2 is the force
exerted by the right block. The contact forces must point away from the contact
surface (as expressed by the constraints λ1 ≥ 0 and −λ2 ≤ 0), and are nonzero
only when there is contact (as expressed by the first two complementary slackness
conditions (5.53)). In a similar way, the second equation in (5.54) is the force
balance for the second block, and the last condition in (5.53) states that λ3 is zero
unless the right block touches the wall.

In this example, the potential energy and kinematic constraint functions are
convex, and (the refined form of) Slater’s constraint qualification holds provided
2w ≤ l, i.e., there is enough room between the walls to fit the two blocks, so we
can conclude that the energy formulation of the equilibrium given by (5.52), gives
the same result as the force balance formulation, given by the KKT conditions.



248 5 Duality

5.5.5 Solving the primal problem via the dual

We mentioned at the beginning of §5.5.3 that if strong duality holds and a dual
optimal solution (λ⋆, ν⋆) exists, then any primal optimal point is also a minimizer
of L(x, λ⋆, ν⋆). This fact sometimes allows us to compute a primal optimal solution
from a dual optimal solution.

More precisely, suppose we have strong duality and an optimal (λ⋆, ν⋆) is known.
Suppose that the minimizer of L(x, λ⋆, ν⋆), i.e., the solution of

minimize f0(x) +
∑m

i=1 λ
⋆
i fi(x) +

∑p
i=1 ν

⋆
i hi(x), (5.55)

is unique. (For a convex problem this occurs, for example, if L(x, λ⋆, ν⋆) is a strictly
convex function of x.) Then if the solution of (5.55) is primal feasible, it must be
primal optimal; if it is not primal feasible, then no primal optimal point can exist,
i.e., we can conclude that the primal optimum is not attained. This observation is
interesting when the dual problem is easier to solve than the primal problem, for
example, because it can be solved analytically, or has some special structure that
can be exploited.

Example 5.3 Entropy maximization. We consider the entropy maximization problem

minimize f0(x) =
∑n

i=1
xi log xi

subject to Ax � b
1Tx = 1

with domain Rn++, and its dual problem

maximize −bTλ− ν − e−ν−1∑n
i=1

e−a
T
i
λ

subject to λ � 0
where ai are the columns of A (see pages 222 and 228). We assume that the weak
form of Slater’s condition holds, i.e., there exists an x ≻ 0 with Ax � b and 1Tx = 1,
so strong duality holds and an optimal solution (λ⋆, ν⋆) exists.

Suppose we have solved the dual problem. The Lagrangian at (λ⋆, ν⋆) is

L(x, λ⋆, ν⋆) =

n∑
i=1

xi log xi + λ
⋆T (Ax− b) + ν⋆(1Tx− 1)

which is strictly convex on D and bounded below, so it has a unique solution x⋆,
given by

x⋆i = 1/ exp(a
T
i λ

⋆ + ν⋆ + 1), i = 1, . . . , n.

If x⋆ is primal feasible, it must be the optimal solution of the primal problem (5.13).
If x⋆ is not primal feasible, then we can conclude that the primal optimum is not
attained.

Example 5.4 Minimizing a separable function subject to an equality constraint. We
consider the problem

minimize f0(x) =
∑n

i=1
fi(xi)

subject to aTx = b,



5.6 Perturbation and sensitivity analysis 249

where a ∈ Rn, b ∈ R, and fi : R → R are differentiable and strictly convex. The
objective function is called separable since it is a sum of functions of the individual
variables x1, . . . , xn. We assume that the domain of f0 intersects the constraint set,
i.e., there exists a point x0 ∈ dom f0 with aTx0 = b. This implies the problem has
a unique optimal point x⋆.

The Lagrangian is

L(x, ν) =

n∑
i=1

fi(xi) + ν(a
Tx− b) = −bν +

n∑
i=1

(fi(xi) + νaixi),

which is also separable, so the dual function is

g(ν) = −bν + inf
x

(
n∑
i=1

(fi(xi) + νaixi)

)

= −bν +
n∑
i=1

inf
xi
(fi(xi) + νaixi)

= −bν −
n∑
i=1

f∗i (−νai).

The dual problem is thus

maximize −bν −∑n
i=1

f∗i (−νai),
with (scalar) variable ν ∈ R.
Now suppose we have found an optimal dual variable ν⋆. (There are several simple
methods for solving a convex problem with one scalar variable, such as the bisection
method.) Since each fi is strictly convex, the function L(x, ν

⋆) is strictly convex in
x, and so has a unique minimizer x˜. But we also know that x⋆ minimizes L(x, ν⋆),
so we must have x˜ = x⋆. We can recover x⋆ from ∇xL(x, ν⋆) = 0, i.e., by solving the
equations f ′i(x

⋆
i ) = −ν⋆ai.

5.6 Perturbation and sensitivity analysis

When strong duality obtains, the optimal dual variables give very useful informa-
tion about the sensitivity of the optimal value with respect to perturbations of the
constraints.

5.6.1 The perturbed problem

We consider the following perturbed version of the original optimization prob-
lem (5.1):

minimize f0(x)
subject to fi(x) ≤ ui, i = 1, . . . ,m

hi(x) = vi, i = 1, . . . , p,
(5.56)



250 5 Duality

with variable x ∈ Rn. This problem coincides with the original problem (5.1) when
u = 0, v = 0. When ui is positive it means that we have relaxed the ith inequality
constraint; when ui is negative, it means that we have tightened the constraint.
Thus the perturbed problem (5.56) results from the original problem (5.1) by tight-
ening or relaxing each inequality constraint by ui, and changing the righthand side
of the equality constraints by vi.

We define p⋆(u, v) as the optimal value of the perturbed problem (5.56):

p⋆(u, v) = inf{f0(x) | ∃x ∈ D, fi(x) ≤ ui, i = 1, . . . ,m,
hi(x) = vi, i = 1, . . . , p}.

We can have p⋆(u, v) = ∞, which corresponds to perturbations of the constraints
that result in infeasibility. Note that p⋆(0, 0) = p⋆, the optimal value of the un-
perturbed problem (5.1). (We hope this slight abuse of notation will cause no
confusion.) Roughly speaking, the function p⋆ : Rm ×Rp → R gives the optimal
value of the problem as a function of perturbations to the righthand sides of the
constraints.

When the original problem is convex, the function p⋆ is a convex function of u
and v; indeed, its epigraph is precisely the closure of the set A defined in (5.37)
(see exercise 5.32).

5.6.2 A global inequality

Now we assume that strong duality holds, and that the dual optimum is attained.
(This is the case if the original problem is convex, and Slater’s condition is satisfied).
Let (λ⋆, ν⋆) be optimal for the dual (5.16) of the unperturbed problem. Then for
all u and v we have

p⋆(u, v) ≥ p⋆(0, 0)− λ⋆Tu− ν⋆T v. (5.57)
To establish this inequality, suppose that x is any feasible point for the per-

turbed problem, i.e., fi(x) ≤ ui for i = 1, . . . ,m, and hi(x) = vi for i = 1, . . . , p.
Then we have, by strong duality,

p⋆(0, 0) = g(λ⋆, ν⋆) ≤ f0(x) +
m∑
i=1

λ⋆i fi(x) +

p∑
i=1

ν⋆i hi(x)

≤ f0(x) + λ⋆Tu+ ν⋆T v.
(The first inequality follows from the definition of g(λ⋆, ν⋆); the second follows
since λ⋆ � 0.) We conclude that for any x feasible for the perturbed problem, we
have

f0(x) ≥ p⋆(0, 0)− λ⋆Tu− ν⋆T v,
from which (5.57) follows.

Sensitivity interpretations

When strong duality holds, various sensitivity interpretations of the optimal La-
grange variables follow directly from the inequality (5.57). Some of the conclusions
are:



5.6 Perturbation and sensitivity analysis 251

u

p⋆(u)

p⋆(0)− λ⋆u

u = 0

Figure 5.10 Optimal value p⋆(u) of a convex problem with one constraint
f1(x) ≤ u, as a function of u. For u = 0, we have the original unperturbed
problem; for u < 0 the constraint is tightened, and for u > 0 the constraint
is loosened. The affine function p⋆(0)− λ⋆u is a lower bound on p⋆.

• If λ⋆i is large and we tighten the ith constraint (i.e., choose ui < 0), then the
optimal value p⋆(u, v) is guaranteed to increase greatly.

• If ν⋆i is large and positive and we take vi < 0, or if ν⋆i is large and negative
and we take vi > 0, then the optimal value p

⋆(u, v) is guaranteed to increase
greatly.

• If λ⋆i is small, and we loosen the ith constraint (ui > 0), then the optimal
value p⋆(u, v) will not decrease too much.

• If ν⋆i is small and positive, and vi > 0, or if ν⋆i is small and negative and
vi < 0, then the optimal value p

⋆(u, v) will not decrease too much.

The inequality (5.57), and the conclusions listed above, give a lower bound on
the perturbed optimal value, but no upper bound. For this reason the results are
not symmetric with respect to loosening or tightening a constraint. For example,
suppose that λ⋆i is large, and we loosen the ith constraint a bit (i.e., take ui small
and positive). In this case the inequality (5.57) is not useful; it does not, for
example, imply that the optimal value will decrease considerably.

The inequality (5.57) is illustrated in figure 5.10 for a convex problem with one
inequality constraint. The inequality states that the affine function p⋆(0)− λ⋆u is
a lower bound on the convex function p⋆.

5.6.3 Local sensitivity analysis

Suppose now that p⋆(u, v) is differentiable at u = 0, v = 0. Then, provided strong
duality holds, the optimal dual variables λ⋆, ν⋆ are related to the gradient of p⋆ at



252 5 Duality

u = 0, v = 0:

λ⋆i = −
∂p⋆(0, 0)

∂ui
, ν⋆i = −

∂p⋆(0, 0)

∂vi
. (5.58)

This property can be seen in the example shown in figure 5.10, where −λ⋆ is the
slope of p⋆ near u = 0.

Thus, when p⋆(u, v) is differentiable at u = 0, v = 0, and strong duality holds,
the optimal Lagrange multipliers are exactly the local sensitivities of the optimal
value with respect to constraint perturbations. In contrast to the nondifferentiable
case, this interpretation is symmetric: Tightening the ith inequality constraint
a small amount (i.e., taking ui small and negative) yields an increase in p

⋆ of
approximately −λ⋆i ui; loosening the ith constraint a small amount (i.e., taking ui
small and positive) yields a decrease in p⋆ of approximately λ⋆i ui.

To show (5.58), suppose p⋆(u, v) is differentiable and strong duality holds. For
the perturbation u = tei, v = 0, where ei is the ith unit vector, we have

lim
t→0

p⋆(tei, 0)− p⋆
t

=
∂p⋆(0, 0)

∂ui
.

The inequality (5.57) states that for t > 0,

p⋆(tei, 0)− p⋆
t

≥ −λ⋆i ,

while for t < 0 we have the opposite inequality. Taking the limit t→ 0, with t > 0,
yields

∂p⋆(0, 0)

∂ui
≥ −λ⋆i ,

while taking the limit with t < 0 yields the opposite inequality, so we conclude that

∂p⋆(0, 0)

∂ui
= −λ⋆i .

The same method can be used to establish

∂p⋆(0, 0)

∂vi
= −ν⋆i .

The local sensitivity result (5.58) gives us a quantitative measure of how active
a constraint is at the optimum x⋆. If fi(x

⋆) < 0, then the constraint is inactive,
and it follows that the constraint can be tightened or loosened a small amount
without affecting the optimal value. By complementary slackness, the associated
optimal Lagrange multiplier must be zero. But now suppose that fi(x

⋆) = 0, i.e.,
the ith constraint is active at the optimum. The ith optimal Lagrange multiplier
tells us how active the constraint is: If λ⋆i is small, it means that the constraint
can be loosened or tightened a bit without much effect on the optimal value; if λ⋆i
is large, it means that if the constraint is loosened or tightened a bit, the effect on
the optimal value will be great.



5.7 Examples 253

Shadow price interpretation

We can also give a simple geometric interpretation of the result (5.58) in terms
of economics. We consider (for simplicity) a convex problem with no equality
constraints, which satisfies Slater’s condition. The variable x ∈ Rm determines
how a firm operates, and the objective f0 is the cost, i.e., −f0 is the profit. Each
constraint fi(x) ≤ 0 represents a limit on some resource such as labor, steel, or
warehouse space. The (negative) perturbed optimal cost function −p⋆(u) tells us
how much more or less profit could be made if more, or less, of each resource were
made available to the firm. If it is differentiable near u = 0, then we have

λ⋆i = −
∂p⋆(0)

∂ui
.

In other words, λ⋆i tells us approximately how much more profit the firm could
make, for a small increase in availability of resource i.

It follows that λ⋆i would be the natural or equilibrium price for resource i, if
it were possible for the firm to buy or sell it. Suppose, for example, that the firm
can buy or sell resource i, at a price that is less than λ⋆i . In this case it would
certainly buy some of the resource, which would allow it to operate in a way that
increases its profit more than the cost of buying the resource. Conversely, if the
price exceeds λ⋆i , the firm would sell some of its allocation of resource i, and obtain
a net gain since its income from selling some of the resource would be larger than
its drop in profit due to the reduction in availability of the resource.

5.7 Examples

In this section we show by example that simple equivalent reformulations of a
problem can lead to very different dual problems. We consider the following types
of reformulations:

• Introducing new variables and associated equality constraints.
• Replacing the objective with an increasing function of the original objective.
• Making explicit constraints implicit, i.e., incorporating them into the domain
of the objective.

5.7.1 Introducing new variables and equality constraints

Consider an unconstrained problem of the form

minimize f0(Ax+ b). (5.59)

Its Lagrange dual function is the constant p⋆. So while we do have strong duality,
i.e., p⋆ = d⋆, the Lagrangian dual is neither useful nor interesting.



254 5 Duality

Now let us reformulate the problem (5.59) as

minimize f0(y)
subject to Ax+ b = y.

(5.60)

Here we have introduced new variables y, as well as new equality constraints Ax+
b = y. The problems (5.59) and (5.60) are clearly equivalent.

The Lagrangian of the reformulated problem is

L(x, y, ν) = f0(y) + ν
T (Ax+ b− y).

To find the dual function we minimize L over x and y. Minimizing over x we find
that g(ν) = −∞ unless AT ν = 0, in which case we are left with

g(ν) = bT ν + inf
y
(f0(y)− νT y) = bT ν − f∗0 (ν),

where f∗0 is the conjugate of f0. The dual problem of (5.60) can therefore be
expressed as

maximize bT ν − f∗0 (ν)
subject to AT ν = 0.

(5.61)

Thus, the dual of the reformulated problem (5.60) is considerably more useful than
the dual of the original problem (5.59).

Example 5.5 Unconstrained geometric program. Consider the unconstrained geomet-
ric program

minimize log
(∑m

i=1
exp(aTi x+ bi)

)
.

We first reformulate it by introducing new variables and equality constraints:

minimize f0(y) = log
(∑m

i=1
exp yi

)
subject to Ax+ b = y,

where aTi are the rows of A. The conjugate of the log-sum-exp function is

f∗0 (ν) =

{ ∑m
i=1

νi log νi ν � 0, 1T ν = 1
∞ otherwise

(example 3.25, page 93), so the dual of the reformulated problem can be expressed
as

maximize bT ν −∑m
i=1

νi log νi
subject to 1T ν = 1

AT ν = 0
ν � 0,

(5.62)

which is an entropy maximization problem.

Example 5.6 Norm approximation problem. We consider the unconstrained norm
approximation problem

minimize ‖Ax− b‖, (5.63)
where ‖ · ‖ is any norm. Here too the Lagrange dual function is constant, equal to
the optimal value of (5.63), and therefore not useful.



5.7 Examples 255

Once again we reformulate the problem as

minimize ‖y‖
subject to Ax− b = y.

The Lagrange dual problem is, following (5.61),

maximize bT ν
subject to ‖ν‖∗ ≤ 1

AT ν = 0,
(5.64)

where we use the fact that the conjugate of a norm is the indicator function of the
dual norm unit ball (example 3.26, page 93).

The idea of introducing new equality constraints can be applied to the constraint
functions as well. Consider, for example, the problem

minimize f0(A0x+ b0)
subject to fi(Aix+ bi) ≤ 0, i = 1, . . . ,m, (5.65)

where Ai ∈ Rki×n and fi : Rki → R are convex. (For simplicity we do not include
equality constraints here.) We introduce a new variable yi ∈ Rki , for i = 0, . . . ,m,
and reformulate the problem as

minimize f0(y0)
subject to fi(yi) ≤ 0, i = 1, . . . ,m

Aix+ bi = yi, i = 0, . . . ,m.
(5.66)

The Lagrangian for this problem is

L(x, y0, . . . , ym, λ, ν0, . . . , νm) = f0(y0) +

m∑
i=1

λifi(yi) +

m∑
i=0

νTi (Aix+ bi − yi).

To find the dual function we minimize over x and yi. The minimum over x is −∞
unless

m∑
i=0

ATi νi = 0,

in which case we have, for λ ≻ 0,

g(λ, ν0, . . . , νm)

=
m∑
i=0

νTi bi + inf
y0,...,ym

(
f0(y0) +

m∑
i=1

λifi(yi)−
m∑
i=0

νTi yi

)

=

m∑
i=0

νTi bi + inf
y0

(
f0(y0)− νT0 y0

)
+

m∑
i=1

λi inf
yi

(
fi(yi)− (νi/λi)T yi

)
=

m∑
i=0

νTi bi − f∗0 (ν0)−
m∑
i=1

λif
∗
i (νi/λi).



256 5 Duality

The last expression involves the perspective of the conjugate function, and is there-
fore concave in the dual variables. Finally, we address the question of what happens
when λ � 0, but some λi are zero. If λi = 0 and νi 6= 0, then the dual function is
−∞. If λi = 0 and νi = 0, however, the terms involving yi, νi, and λi are all zero.
Thus, the expression above for g is valid for all λ � 0, if we take λif∗i (νi/λi) = 0
when λi = 0 and νi = 0, and λif

∗
i (νi/λi) =∞ when λi = 0 and νi 6= 0.

Therefore we can express the dual of the problem (5.66) as

maximize
∑m

i=0 ν
T
i bi − f∗0 (ν0)−

∑m
i=1 λif

∗
i (νi/λi)

subject to λ � 0∑m
i=0A

T
i νi = 0.

(5.67)

Example 5.7 Inequality constrained geometric program. The inequality constrained
geometric program

minimize log
(∑K0

k=1
ea

T
0k
x+b0k

)
subject to log

(∑Ki
k=1

ea
T
ik
x+bik

)
≤ 0, i = 1, . . . ,m

is of the form (5.65) with fi : R
Ki → R given by fi(y) = log

(∑Ki
k=1

eyk
)
. The

conjugate of this function is

f∗i (ν) =

{ ∑Ki
k=1

νk log νk ν � 0, 1T ν = 1
∞ otherwise.

Using (5.67) we can immediately write down the dual problem as

maximize bT0 ν0 −
∑K0

k=1
ν0k log ν0k +

∑m
i=1

(
bTi νi −

∑Ki
k=1

νik log(νik/λi)
)

subject to ν0 � 0, 1T ν0 = 1
νi � 0, 1T νi = λi, i = 1, . . . ,m
λi ≥ 0, i = 1, . . . ,m∑m

i=0
ATi νi = 0,

which further simplifies to

maximize bT0 ν0 −
∑K0

k=1
ν0k log ν0k +

∑m
i=1

(
bTi νi −

∑Ki
k=1

νik log(νik/1
T νi)

)
subject to νi � 0, i = 0, . . . ,m

1T ν0 = 1∑m
i=0

ATi νi = 0.

5.7.2 Transforming the objective

If we replace the objective f0 by an increasing function of f0, the resulting problem
is clearly equivalent (see §4.1.3). The dual of this equivalent problem, however, can
be very different from the dual of the original problem.

Example 5.8 We consider again the minimum norm problem

minimize ‖Ax− b‖,



5.7 Examples 257

where ‖ · ‖ is some norm. We reformulate this problem as

minimize (1/2)‖y‖2
subject to Ax− b = y.

Here we have introduced new variables, and replaced the objective by half its square.
Evidently it is equivalent to the original problem.

The dual of the reformulated problem is

maximize −(1/2)‖ν‖2∗ + bT ν
subject to AT ν = 0,

where we use the fact that the conjugate of (1/2)‖ ·‖2 is (1/2)‖ ·‖2∗ (see example 3.27,
page 93).

Note that this dual problem is not the same as the dual problem (5.64) derived earlier.

5.7.3 Implicit constraints

The next simple reformulation we study is to include some of the constraints in
the objective function, by modifying the objective function to be infinite when the
constraint is violated.

Example 5.9 Linear program with box constraints. We consider the linear program

minimize cTx
subject to Ax = b

l � x � u
(5.68)

where A ∈ Rp×n and l ≺ u. The constraints l � x � u are sometimes called box
constraints or variable bounds.

We can, of course, derive the dual of this linear program. The dual will have a
Lagrange multiplier ν associated with the equality constraint, λ1 associated with the
inequality constraint x � u, and λ2 associated with the inequality constraint l � x.
The dual is

maximize −bT ν − λT1 u+ λT2 l
subject to AT ν + λ1 − λ2 + c = 0

λ1 � 0, λ2 � 0.
(5.69)

Instead, let us first reformulate the problem (5.68) as

minimize f0(x)
subject to Ax = b,

(5.70)

where we define

f0(x) =

{
cTx l � x � u
∞ otherwise.

The problem (5.70) is clearly equivalent to (5.68); we have merely made the explicit
box constraints implicit.



258 5 Duality

The dual function for the problem (5.70) is

g(ν) = inf
l�x�u

(
cTx+ νT (Ax− b)

)
= −bT ν − uT (AT ν + c)− + lT (AT ν + c)+

where y+i = max{yi, 0}, y−i = max{−yi, 0}. So here we are able to derive an analyt-
ical formula for g, which is a concave piecewise-linear function.

The dual problem is the unconstrained problem

maximize −bT ν − uT (AT ν + c)− + lT (AT ν + c)+, (5.71)

which has a quite different form from the dual of the original problem.

(The problems (5.69) and (5.71) are closely related, in fact, equivalent; see exer-
cise 5.8.)

5.8 Theorems of alternatives

5.8.1 Weak alternatives via the dual function

In this section we apply Lagrange duality theory to the problem of determining
feasibility of a system of inequalities and equalities

fi(x) ≤ 0, i = 1, . . . ,m, hi(x) = 0, i = 1, . . . , p. (5.72)

We assume the domain of the inequality system (5.72), D = ⋂mi=1 dom fi ∩⋂p
i=1 domhi, is nonempty. We can think of (5.72) as the standard problem (5.1),

with objective f0 = 0, i.e.,

minimize 0
subject to fi(x) ≤ 0, i = 1, . . . ,m

hi(x) = 0, i = 1, . . . , p.
(5.73)

This problem has optimal value

p⋆ =

{
0 (5.72) is feasible
∞ (5.72) is infeasible, (5.74)

so solving the optimization problem (5.73) is the same as solving the inequality
system (5.72).

The dual function

We associate with the inequality system (5.72) the dual function

g(λ, ν) = inf
x∈D

(
m∑
i=1

λifi(x) +

p∑
i=1

νihi(x)

)
,



5.8 Theorems of alternatives 259

which is the same as the dual function for the optimization problem (5.73). Since
f0 = 0, the dual function is positive homogeneous in (λ, ν): For α > 0, g(αλ, αν) =
αg(λ, ν). The dual problem associated with (5.73) is to maximize g(λ, ν) subject
to λ � 0. Since g is homogeneous, the optimal value of this dual problem is given
by

d⋆ =

{ ∞ λ � 0, g(λ, ν) > 0 is feasible
0 λ � 0, g(λ, ν) > 0 is infeasible. (5.75)

Weak duality tells us that d⋆ ≤ p⋆. Combining this fact with (5.74) and (5.75)
yields the following: If the inequality system

λ � 0, g(λ, ν) > 0 (5.76)

is feasible (which means d⋆ = ∞), then the inequality system (5.72) is infeasible
(since we then have p⋆ = ∞). Indeed, we can interpret any solution (λ, ν) of the
inequalities (5.76) as a proof or certificate of infeasibility of the system (5.72).

We can restate this implication in terms of feasibility of the original system: If
the original inequality system (5.72) is feasible, then the inequality system (5.76)
must be infeasible. We can interpret an x which satisfies (5.72) as a certificate
establishing infeasibility of the inequality system (5.76).

Two systems of inequalities (and equalities) are called weak alternatives if at
most one of the two is feasible. Thus, the systems (5.72) and (5.76) are weak
alternatives. This is true whether or not the inequalities (5.72) are convex (i.e.,
fi convex, hi affine); moreover, the alternative inequality system (5.76) is always
convex (i.e., g is concave and the constraints λi ≥ 0 are convex).

Strict inequalities

We can also study feasibility of the strict inequality system

fi(x) < 0, i = 1, . . . ,m, hi(x) = 0, i = 1, . . . , p. (5.77)

With g defined as for the nonstrict inequality system, we have the alternative
inequality system

λ � 0, λ 6= 0, g(λ, ν) ≥ 0. (5.78)
We can show directly that (5.77) and (5.78) are weak alternatives. Suppose there
exists an x˜ with fi(x˜) < 0, hi(x˜) = 0. Then for any λ � 0, λ 6= 0, and ν,

λ1f1(x˜) + · · ·+ λmfm(x˜) + ν1h1(x˜) + · · ·+ νphp(x˜) < 0.

It follows that

g(λ, ν) = inf
x∈D

(
m∑
i=1

λifi(x) +

p∑
i=1

νihi(x)

)

≤
m∑
i=1

λifi(x˜) +

p∑
i=1

νihi(x˜)

< 0.



260 5 Duality

Therefore, feasibility of (5.77) implies that there does not exist (λ, ν) satisfy-
ing (5.78).

Thus, we can prove infeasibility of (5.77) by producing a solution of the sys-
tem (5.78); we can prove infeasibility of (5.78) by producing a solution of the
system (5.77).

5.8.2 Strong alternatives

When the original inequality system is convex, i.e., fi are convex and hi are affine,
and some type of constraint qualification holds, then the pairs of weak alternatives
described above are strong alternatives, which means that exactly one of the two
alternatives holds. In other words, each of the inequality systems is feasible if and
only if the other is infeasible.

In this section we assume that fi are convex and hi are affine, so the inequality
system (5.72) can be expressed as

fi(x) ≤ 0, i = 1, . . . ,m, Ax = b,

where A ∈ Rp×n.

Strict inequalities

We first study the strict inequality system

fi(x) < 0, i = 1, . . . ,m, Ax = b, (5.79)

and its alternative

λ � 0, λ 6= 0, g(λ, ν) ≥ 0. (5.80)
We need one technical condition: There exists an x ∈ relintD with Ax = b. In
other words we not only assume that the linear equality constraints are consistent,
but also that they have a solution in relintD. (Very often D = Rn, so the condition
is satisfied if the equality constraints are consistent.) Under this condition, exactly
one of the inequality systems (5.79) and (5.80) is feasible. In other words, the
inequality systems (5.79) and (5.80) are strong alternatives.

We will establish this result by considering the related optimization problem

minimize s
subject to fi(x)− s ≤ 0, i = 1, . . . ,m

Ax = b
(5.81)

with variables x, s, and domain D ×R. The optimal value p⋆ of this problem is
negative if and only if there exists a solution to the strict inequality system (5.79).

The Lagrange dual function for the problem (5.81) is

inf
x∈D, s

(
s+

m∑
i=1

λi(fi(x)− s) + νT (Ax− b)
)
=

{
g(λ, ν) 1Tλ = 1
−∞ otherwise.



5.8 Theorems of alternatives 261

Therefore we can express the dual problem of (5.81) as

maximize g(λ, ν)
subject to λ � 0, 1Tλ = 1.

Now we observe that Slater’s condition holds for the problem (5.81). By the
hypothesis there exists an x˜ ∈ relintD with Ax˜ = b. Choosing any s˜ > maxi fi(x˜)
yields a point (x˜, s˜) which is strictly feasible for (5.81). Therefore we have d⋆ = p⋆,
and the dual optimum d⋆ is attained. In other words, there exist (λ⋆, ν⋆) such that

g(λ⋆, ν⋆) = p⋆, λ⋆ � 0, 1Tλ⋆ = 1. (5.82)
Now suppose that the strict inequality system (5.79) is infeasible, which means that
p⋆ ≥ 0. Then (λ⋆, ν⋆) from (5.82) satisfy the alternate inequality system (5.80).
Similarly, if the alternate inequality system (5.80) is feasible, then d⋆ = p⋆ ≥
0, which shows that the strict inequality system (5.79) is infeasible. Thus, the
inequality systems (5.79) and (5.80) are strong alternatives; each is feasible if and
only if the other is not.

Nonstrict inequalities

We now consider the nonstrict inequality system

fi(x) ≤ 0, i = 1, . . . ,m, Ax = b, (5.83)
and its alternative

λ � 0, g(λ, ν) > 0. (5.84)
We will show these are strong alternatives, provided the following conditions hold:
There exists an x ∈ relintD with Ax = b, and the optimal value p⋆ of (5.81) is
attained. This holds, for example, if D = Rn and maxi fi(x) → ∞ as x → ∞.
With these assumptions we have, as in the strict case, that p⋆ = d⋆, and that both
the primal and dual optimal values are attained. Now suppose that the nonstrict
inequality system (5.83) is infeasible, which means that p⋆ > 0. (Here we use the
assumption that the primal optimal value is attained.) Then (λ⋆, ν⋆) from (5.82)
satisfy the alternate inequality system (5.84). Thus, the inequality systems (5.83)
and (5.84) are strong alternatives; each is feasible if and only if the other is not.

5.8.3 Examples

Linear inequalities

Consider the system of linear inequalities Ax � b. The dual function is

g(λ) = inf
x
λT (Ax− b) =

{ −bTλ ATλ = 0
−∞ otherwise.

The alternative inequality system is therefore

λ � 0, ATλ = 0, bTλ < 0.



262 5 Duality

These are, in fact, strong alternatives. This follows since the optimum in the related
problem (5.81) is achieved, unless it is unbounded below.

We now consider the system of strict linear inequalities Ax ≺ b, which has the
strong alternative system

λ � 0, λ 6= 0, ATλ = 0, bTλ ≤ 0.
In fact we have encountered (and proved) this result before, in §2.5.1; see (2.17)
and (2.18) (on page 50).

Intersection of ellipsoids

We consider m ellipsoids, described as

Ei = {x | fi(x) ≤ 0},
with fi(x) = x

TAix + 2b
T
i x + ci, i = 1, . . . ,m, where Ai ∈ Sn++. We ask when

the intersection of these ellipsoids has nonempty interior. This is equivalent to
feasibility of the set of strict quadratic inequalities

fi(x) = x
TAix+ 2b

T
i x+ ci < 0, i = 1, . . . ,m. (5.85)

The dual function g is

g(λ) = inf
x

(
xTA(λ)x+ 2b(λ)Tx+ c(λ)

)
=

{ −b(λ)TA(λ)†b(λ) + c(λ) A(λ) � 0, b(λ) ∈ R(A(λ))
−∞ otherwise,

where

A(λ) =

m∑
i=1

λiAi, b(λ) =

m∑
i=1

λibi, c(λ) =

m∑
i=1

λici.

Note that for λ � 0, λ 6= 0, we have A(λ) ≻ 0, so we can simplify the expression
for the dual function as

g(λ) = −b(λ)TA(λ)−1b(λ) + c(λ).
The strong alternative of the system (5.85) is therefore

λ � 0, λ 6= 0, −b(λ)TA(λ)−1b(λ) + c(λ) ≥ 0. (5.86)
We can give a simple geometric interpretation of this pair of strong alternatives.

For any nonzero λ � 0, the (possibly empty) ellipsoid
Eλ = {x | xTA(λ)x+ 2b(λ)Tx+ c(λ) ≤ 0}

contains E1 ∩ · · · ∩ Em, since fi(x) ≤ 0 implies
∑m

i=1 λifi(x) ≤ 0. Now, Eλ has
empty interior if and only if

inf
x

(
xTA(λ)x+ 2b(λ)Tx+ c(λ)

)
= −b(λ)TA(λ)−1b(λ) + c(λ) ≥ 0.

Therefore the alternative system (5.86) means that Eλ has empty interior.
Weak duality is obvious: If (5.86) holds, then Eλ contains the intersection E1 ∩

· · · ∩ Em, and has empty interior, so naturally the intersection has empty interior.
The fact that these are strong alternatives states the (not obvious) fact that if the
intersection E1 ∩ · · · ∩ Em has empty interior, then we can construct an ellipsoid Eλ
that contains the intersection and has empty interior.



5.8 Theorems of alternatives 263

Farkas’ lemma

In this section we describe a pair of strong alternatives for a mixture of strict and
nonstrict linear inequalities, known as Farkas’ lemma: The system of inequalities

Ax � 0, cTx < 0, (5.87)
where A ∈ Rm×n and c ∈ Rn, and the system of equalities and inequalities

AT y + c = 0, y � 0, (5.88)
are strong alternatives.

We can prove Farkas’ lemma directly, using LP duality. Consider the LP

minimize cTx
subject to Ax � 0, (5.89)

and its dual
maximize 0
subject to AT y + c = 0

y � 0.
(5.90)

The primal LP (5.89) is homogeneous, and so has optimal value 0, if (5.87) is
not feasible, and optimal value −∞, if (5.87) is feasible. The dual LP (5.90) has
optimal value 0, if (5.88) is feasible, and optimal value −∞, if (5.88) is infeasible.

Since x = 0 is feasible in (5.89), we can rule out the one case in which strong
duality can fail for LPs, so we must have p⋆ = d⋆. Combined with the remarks
above, this shows that (5.87) and (5.88) are strong alternatives.

Example 5.10 Arbitrage-free bounds on price. We consider a set of n assets, with
prices at the beginning of an investment period p1, . . . , pn, respectively. At the end
of the investment period, the value of the assets is v1, . . . , vn. If x1, . . . , xn represents
the initial investment in each asset (with xj < 0 meaning a short position in asset j),
the cost of the initial investment is pTx, and the final value of the investment is vTx.

The value of the assets at the end of the investment period, v, is uncertain. We will
assume that onlym possible scenarios, or outcomes, are possible. If outcome i occurs,
the final value of the assets is v(i), and therefore, the overall value of the investments
is v(i)Tx.

If there is an investment vector x with pTx < 0, and in all possible scenarios, the
final value is nonnegative, i.e., v(i)Tx ≥ 0 for i = 1, . . . ,m, then an arbitrage is said
to exist. The condition pTx < 0 means you are paid to accept the investment mix,
and the condition v(i)Tx ≥ 0 for i = 1, . . . ,m means that no matter what outcome
occurs, the final value is nonnegative, so an arbitrage corresponds to a guaranteed
money-making investment strategy. It is generally assumed that the prices and values
are such that no arbitrage exists. This means that the inequality system

V x � 0, pTx < 0
is infeasible, where Vij = v

(i)
j .

Using Farkas’ lemma, we have no arbitrage if and only if there exists y such that

−V T y + p = 0, y � 0.



264 5 Duality

We can use this characterization of arbitrage-free prices and values to solve several
interesting problems.

Suppose, for example, that the values V are known, and all prices except the last
one, pn, are known. The set of prices pn that are consistent with the no-arbitrage
assumption is an interval, which can be found by solving a pair of LPs. The optimal
value of the LP

minimize pn
subject to V T y = p, y � 0,

with variables pn and y, gives the smallest possible arbitrage-free price for asset n.
Solving the same LP with maximization instead of minimization yields the largest
possible price for asset n. If the two values are equal, i.e., the no-arbitrage assumption
leads us to a unique price for asset n, we say the market is complete. For an example,
see exercise 5.38.

This method can be used to find bounds on the price of a derivative or option that
is based on the final value of other underlying assets, i.e., when the value or payoff
of asset n is a function of the values of the other assets.

5.9 Generalized inequalities

In this section we examine how Lagrange duality extends to a problem with gen-
eralized inequality constraints

minimize f0(x)
subject to fi(x) �Ki 0, i = 1, . . . ,m

hi(x) = 0, i = 1, . . . , p,
(5.91)

whereKi ⊆ Rki are proper cones. For now, we do not assume convexity of the prob-
lem (5.91). We assume the domain of (5.91), D = ⋂mi=0 dom fi ∩ ⋂pi=1 domhi, is
nonempty.

5.9.1 The Lagrange dual

With each generalized inequality fi(x) �Ki 0 in (5.91) we associate a Lagrange
multiplier vector λi ∈ Rki and define the associated Lagrangian as

L(x, λ, ν) = f0(x) + λ
T
1 f1(x) + · · ·+ λTmfm(x) + ν1h1(x) + · · ·+ νphp(x),

where λ = (λ1, . . . , λm) and ν = (ν1, . . . , νp). The dual function is defined exactly
as in a problem with scalar inequalities:

g(λ, ν) = inf
x∈D

L(x, λ, ν) = inf
x∈D

(
f0(x) +

m∑
i=1

λTi fi(x) +

p∑
i=1

νihi(x)

)
.

Since the Lagrangian is affine in the dual variables (λ, ν), and the dual function is
a pointwise infimum of the Lagrangian, the dual function is concave.



5.9 Generalized inequalities 265

As in a problem with scalar inequalities, the dual function gives lower bounds
on p⋆, the optimal value of the primal problem (5.91). For a problem with scalar
inequalities, we require λi ≥ 0. Here the nonnegativity requirement on the dual
variables is replaced by the condition

λi �K∗
i
0, i = 1, . . . ,m,

where K∗i denotes the dual cone of Ki. In other words, the Lagrange multipliers
associated with inequalities must be dual nonnegative.

Weak duality follows immediately from the definition of dual cone. If λi �K∗
i
0

and fi(x˜) �Ki 0, then λTi fi(x˜) ≤ 0. Therefore for any primal feasible point x˜ and
any λi �K∗

i
0, we have

f0(x˜) +
m∑
i=1

λTi fi(x˜) +

p∑
i=1

νihi(x˜) ≤ f0(x˜).

Taking the infimum over x˜ yields g(λ, ν) ≤ p⋆.
The Lagrange dual optimization problem is

maximize g(λ, ν)
subject to λi �K∗

i
0, i = 1, . . . ,m.

(5.92)

We always have weak duality, i.e., d⋆ ≤ p⋆, where d⋆ denotes the optimal value of
the dual problem (5.92), whether or not the primal problem (5.91) is convex.

Slater’s condition and strong duality

As might be expected, strong duality (d⋆ = p⋆) holds when the primal problem
is convex and satisfies an appropriate constraint qualification. For example, a
generalized version of Slater’s condition for the problem

minimize f0(x)
subject to fi(x) �Ki 0, i = 1, . . . ,m

Ax = b,

where f0 is convex and fi is Ki-convex, is that there exists an x ∈ relintD with
Ax = b and fi(x) ≺Ki 0, i = 1, . . . ,m. This condition implies strong duality (and
also, that the dual optimum is attained).

Example 5.11 Lagrange dual of semidefinite program. We consider a semidefinite
program in inequality form,

minimize cTx
subject to x1F1 + · · ·+ xnFn +G � 0 (5.93)

where F1, . . . , Fn, G ∈ Sk. (Here f1 is affine, and K1 is Sk+, the positive semidefinite
cone.)

We associate with the constraint a dual variable or multiplier Z ∈ Sk, so the La-
grangian is

L(x, Z) = cTx+ tr ((x1F1 + · · ·+ xnFn +G)Z)
= x1(c1 + tr(F1Z)) + · · ·+ xn(cn + tr(FnZ)) + tr(GZ),



266 5 Duality

which is affine in x. The dual function is given by

g(Z) = inf
x
L(x, Z) =

{
tr(GZ) tr(FiZ) + ci = 0, i = 1, . . . , n
−∞ otherwise.

The dual problem can therefore be expressed as

maximize tr(GZ)
subject to tr(FiZ) + ci = 0, i = 1, . . . , n

Z � 0.

(We use the fact that Sk+ is self-dual, i.e., (S
k
+)

∗ = Sk+; see §2.6.)
Strong duality obtains if the semidefinite program (5.93) is strictly feasible, i.e., there
exists an x with

x1F1 + · · ·+ xnFn +G ≺ 0.

Example 5.12 Lagrange dual of cone program in standard form. We consider the
cone program

minimize cTx
subject to Ax = b

x �K 0,
where A ∈ Rm×n, b ∈ Rm, and K ⊆ Rn is a proper cone. We associate with the
equality constraint a multiplier ν ∈ Rm, and with the nonnegativity constraint a
multiplier λ ∈ Rn. The Lagrangian is

L(x, λ, ν) = cTx− λTx+ νT (Ax− b),
so the dual function is

g(λ, ν) = inf
x
L(x, λ, ν) =

{
−bT ν AT ν − λ+ c = 0
−∞ otherwise.

The dual problem can be expressed as

maximize −bT ν
subject to AT ν + c = λ

λ �K∗ 0.
By eliminating λ and defining y = −ν, this problem can be simplified to

maximize bT y
subject to AT y �K∗ c,

which is a cone program in inequality form, involving the dual generalized inequality.

Strong duality obtains if the Slater condition holds, i.e., there is an x ≻K 0 with
Ax = b.

5.9.2 Optimality conditions

The optimality conditions of §5.5 are readily extended to problems with generalized
inequalities. We first derive the complementary slackness conditions.



5.9 Generalized inequalities 267

Complementary slackness

Assume that the primal and dual optimal values are equal, and attained at the
optimal points x⋆, λ⋆, ν⋆. As in §5.5.2, the complementary slackness conditions
follow directly from the equality f0(x

⋆) = g(λ⋆, ν⋆), along with the definition of g.
We have

f0(x
⋆) = g(λ⋆, ν⋆)

≤ f0(x⋆) +
m∑
i=1

λ⋆i
T fi(x

⋆) +

p∑
i=1

ν⋆i hi(x
⋆)

≤ f0(x⋆),

and therefore we conclude that x⋆ minimizes L(x, λ⋆, ν⋆), and also that the two
sums in the second line are zero. Since the second sum is zero (since x⋆ satisfies
the equality constraints), we have

∑m
i=1 λ

⋆
i
T fi(x

⋆) = 0. Since each term in this
sum is nonpositive, we conclude that

λ⋆i
T fi(x

⋆) = 0, i = 1, . . . ,m, (5.94)

which generalizes the complementary slackness condition (5.48). From (5.94) we
can conclude that

λ⋆i ≻K∗i 0 =⇒ fi(x⋆) = 0, fi(x⋆) ≺Ki 0, =⇒ λ⋆i = 0.

However, in contrast to problems with scalar inequalities, it is possible to sat-
isfy (5.94) with λ⋆i 6= 0 and fi(x⋆) 6= 0.

KKT conditions

Now we add the assumption that the functions fi, hi are differentiable, and gener-
alize the KKT conditions of §5.5.3 to problems with generalized inequalities. Since
x⋆ minimizes L(x, λ⋆, ν⋆), its gradient with respect to x vanishes at x⋆:

∇f0(x⋆) +
m∑
i=1

Dfi(x
⋆)Tλ⋆i +

p∑
i=1

ν⋆i∇hi(x⋆) = 0,

where Dfi(x
⋆) ∈ Rki×n is the derivative of fi evaluated at x⋆ (see §A.4.1). Thus,

if strong duality holds, any primal optimal x⋆ and any dual optimal (λ⋆, ν⋆) must
satisfy the optimality conditions (or KKT conditions)

fi(x
⋆) �Ki 0, i = 1, . . . ,m

hi(x
⋆) = 0, i = 1, . . . , p
λ⋆i �K∗i 0, i = 1, . . . ,m

λ⋆i
T fi(x

⋆) = 0, i = 1, . . . ,m
∇f0(x⋆) +

∑m
i=1Dfi(x

⋆)Tλ⋆i +
∑p

i=1 ν
⋆
i∇hi(x⋆) = 0.

(5.95)
If the primal problem is convex, the converse also holds, i.e., the conditions (5.95)
are sufficient conditions for optimality of x⋆, (λ⋆, ν⋆).



268 5 Duality

5.9.3 Perturbation and sensitivity analysis

The results of §5.6 can be extended to problems involving generalized inequalities.
We consider the associated perturbed version of the problem,

minimize f0(x)
subject to fi(x) �Ki ui, i = 1, . . . ,m

hi(x) = vi, i = 1, . . . , p,

where ui ∈ Rki , and v ∈ Rp. We define p⋆(u, v) as the optimal value of the
perturbed problem. As in the case with scalar inequalities, p⋆ is a convex function
when the original problem is convex.

Now let (λ⋆, ν⋆) be optimal for the dual of the original (unperturbed) problem,
which we assume has zero duality gap. Then for all u and v we have

p⋆(u, v) ≥ p⋆ −
m∑
i=1

λ⋆i
Tui − ν⋆T v,

the analog of the global sensitivity inequality (5.57). The local sensitivity result
holds as well: If p⋆(u, v) is differentiable at u = 0, v = 0, then the optimal dual
variables λ⋆i satisfies

λ⋆i = −∇uip⋆(0, 0),
the analog of (5.58).

Example 5.13 Semidefinite program in inequality form. We consider a semidefinite
program in inequality form, as in example 5.11. The primal problem is

minimize cTx
subject to F (x) = x1F1 + · · ·+ xnFn +G � 0,

with variable x ∈ Rn (and F1, . . . , Fn, G ∈ Sk), and the dual problem is

maximize tr(GZ)
subject to tr(FiZ) + ci = 0, i = 1, . . . , n

Z � 0,

with variable Z ∈ Sk.
Suppose that x⋆ and Z⋆ are primal and dual optimal, respectively, with zero duality
gap. The complementary slackness condition is tr(F (x⋆)Z⋆) = 0. Since F (x⋆) � 0
and Z⋆ � 0, we can conclude that F (x⋆)Z⋆ = 0. Thus, the complementary slackness
condition can be expressed as

R(F (x⋆)) ⊥ R(Z⋆),

i.e., the ranges of the primal and dual matrices are orthogonal.

Let p⋆(U) denote the optimal value of the perturbed SDP

minimize cTx
subject to F (x) = x1F1 + · · ·+ xnFn +G � U.



5.9 Generalized inequalities 269

Then we have, for all U , p⋆(U) ≥ p⋆ − tr(Z⋆U). If p⋆(U) is differentiable at U = 0,
then we have

∇p⋆(0) = −Z⋆.
This means that for U small, the optimal value of the perturbed SDP is very close
to (the lower bound) p⋆ − tr(Z⋆U).

5.9.4 Theorems of alternatives

We can derive theorems of alternatives for systems of generalized inequalities and
equalities

fi(x) �Ki 0, i = 1, . . . ,m, hi(x) = 0, i = 1, . . . , p, (5.96)
where Ki ⊆ Rki are proper cones. We will also consider systems with strict in-
equalities,

fi(x) ≺Ki 0, i = 1, . . . ,m, hi(x) = 0, i = 1, . . . , p. (5.97)
We assume that D = ⋂mi=0 dom fi ∩ ⋂pi=1 domhi is nonempty.
Weak alternatives

We associate with the systems (5.96) and (5.97) the dual function

g(λ, ν) = inf
x∈D

(
m∑
i=1

λTi fi(x) +

p∑
i=1

νihi(x)

)

where λ = (λ1, . . . , λm) with λi ∈ Rki and ν ∈ Rp. In analogy with (5.76), we
claim that

λi �K⋆
i
0, i = 1, . . . ,m, g(λ, ν) > 0 (5.98)

is a weak alternative to the system (5.96). To verify this, suppose there exists an
x satisfying (5.96) and (λ, ν) satisfying (5.98). Then we have a contradiction:

0 < g(λ, ν) ≤ λT1 f1(x) + · · ·+ λTmfm(x) + ν1h1(x) + · · ·+ νphp(x) ≤ 0.
Therefore at least one of the two systems (5.96) and (5.98) must be infeasible, i.e.,
the two systems are weak alternatives.

In a similar way, we can prove that (5.97) and the system

λi �K∗
i
0, i = 1, . . . ,m, λ 6= 0, g(λ, ν) ≥ 0.

form a pair of weak alternatives.

Strong alternatives

We now assume that the functions fi are Ki-convex, and the functions hi are affine.
We first consider a system with strict inequalities

fi(x) ≺Ki 0, i = 1, . . . ,m, Ax = b, (5.99)



270 5 Duality

and its alternative

λi �K⋆
i
0, i = 1, . . . ,m, λ 6= 0, g(λ, ν) ≥ 0. (5.100)

We have already seen that (5.99) and (5.100) are weak alternatives. They are also
strong alternatives provided the following constraint qualification holds: There
exists an x˜ ∈ relintD with Ax˜ = b. To prove this, we select a set of vectors
ei ≻Ki 0, and consider the problem

minimize s
subject to fi(x) �Ki sei, i = 1, . . . ,m

Ax = b
(5.101)

with variables x and s ∈ R. Slater’s condition holds since (x˜, s˜) satisfies the strict
inequalities fi(x˜) ≺Ki s˜ei provided s˜ is large enough.

The dual of (5.101) is

maximize g(λ, ν)
subject to λi �K∗

i
0, i = 1, . . . ,m∑m

i=1 e
T
i λi = 1

(5.102)

with variables λ = (λ1, . . . , λm) and ν.
Now suppose the system (5.99) is infeasible. Then the optimal value of (5.101)

is nonnegative. Since Slater’s condition is satisfied, we have strong duality and the
dual optimum is attained. Therefore there exist (λ˜, ν˜) that satisfy the constraints
of (5.102) and g(λ˜, ν˜) ≥ 0, i.e., the system (5.100) has a solution.

As we noted in the case of scalar inequalities, existence of an x ∈ relintD with
Ax = b is not sufficient for the system of nonstrict inequalities

fi(x) �Ki 0, i = 1, . . . ,m, Ax = b

and its alternative

λi �K⋆
i
0, i = 1, . . . ,m, g(λ, ν) > 0

to be strong alternatives. An additional condition is required, e.g., that the optimal
value of (5.101) is attained.

Example 5.14 Feasibility of a linear matrix inequality. The following systems are
strong alternatives:

F (x) = x1F1 + · · ·+ xnFn +G ≺ 0,
where Fi, G ∈ Sk, and

Z � 0, Z 6= 0, tr(GZ) ≥ 0, tr(FiZ) = 0, i = 1, . . . , n,

where Z ∈ Sk. This follows from the general result, if we take for K the positive
semidefinite cone Sk+, and

g(Z) = inf
x
(tr(F (x)Z)) =

{
tr(GZ) tr(FiZ) = 0, i = 1, . . . , n
−∞ otherwise.



5.9 Generalized inequalities 271

The nonstrict inequality case is slightly more involved, and we need an extra assump-
tion on the matrices Fi to have strong alternatives. One such condition is

n∑
i=1

viFi � 0 =⇒
n∑
i=1

viFi = 0.

If this condition holds, the following systems are strong alternatives:

F (x) = x1F1 + · · ·+ xnFn +G � 0
and

Z � 0, tr(GZ) > 0, tr(FiZ) = 0, i = 1, . . . , n
(see exercise 5.44).



272 5 Duality

Bibliography

Lagrange duality is covered in detail by Luenberger [Lue69, chapter 8], Rockafellar [Roc70,
part VI], Whittle [Whi71], Hiriart-Urruty and Lemare´chal [HUL93], and Bertsekas, Nedic´,
and Ozdaglar [Ber03]. The name is derived from Lagrange’s method of multipliers for
optimization problems with equality constraints; see Courant and Hilbert [CH53, chapter
IV].

The max-min result for matrix games in §5.2.5 predates linear programming duality.
It is proved via a theorem of alternatives by von Neuman and Morgenstern [vNM53,
page 153]. The strong duality result for linear programming on page 227 is due to von
Neumann [vN63] and Gale, Kuhn, and Tucker [GKT51]. Strong duality for the nonconvex
quadratic problem (5.32) is a fundamental result in the literature on trust region methods
for nonlinear optimization (Nocedal and Wright [NW99, page 78]). It is also related to the
S-procedure in control theory, discussed in appendix §B.1. For an extension of the proof
of strong duality of §5.3.2 to the refined Slater condition (5.27), see Rockafellar [Roc70,
page 277].

Conditions that guarantee the saddle-point property (5.47) can be found in Rockafel-
lar [Roc70, part VII] and Bertsekas, Nedic´, and Ozdaglar [Ber03, chapter 2]; see also
exercise 5.25.

The KKT conditions are named after Karush (whose unpublished 1939 Master’s thesis
is summarized in Kuhn [Kuh76]), Kuhn, and Tucker [KT51]. Related optimality condi-
tions were also derived by John [Joh85]. The water-filling algorithm in example 5.2 has
applications in information theory and communications (Cover and Thomas [CT91, page
252]).

Farkas’ lemma was published by Farkas [Far02]. It is the best known theorem of al-
ternatives for systems of linear inequalities and equalities, but many variants exist; see
Mangasarian [Man94, §2.4]. The application of Farkas’ lemma to asset pricing (exam-
ple 5.10) is discussed by Bertsimas and Tsitsiklis [BT97, page 167] and Ross [Ros99].

The extension of Lagrange duality to problems with generalized inequalities appears in
Isii [Isi64], Luenberger [Lue69, chapter 8], Berman [Ber73], and Rockafellar [Roc89, page
47]. It is discussed in the context of cone programming in Nesterov and Nemirovski
[NN94, §4.2] and Ben-Tal and Nemirovski [BTN01, lecture 2]. Theorems of alternatives
for generalized inequalities were studied by Ben-Israel [BI69], Berman and Ben-Israel
[BBI71], and Craven and Kohila [CK77]. Bellman and Fan [BF63], Wolkowicz [Wol81],
and Lasserre [Las95] give extensions of Farkas’ lemma to linear matrix inequalities.



Exercises 273

Exercises

Basic definitions

5.1 A simple example. Consider the optimization problem

minimize x2 + 1
subject to (x− 2)(x− 4) ≤ 0,

with variable x ∈ R.
(a) Analysis of primal problem. Give the feasible set, the optimal value, and the optimal

solution.

(b) Lagrangian and dual function. Plot the objective x2+1 versus x. On the same plot,
show the feasible set, optimal point and value, and plot the Lagrangian L(x, λ) versus
x for a few positive values of λ. Verify the lower bound property (p⋆ ≥ infx L(x, λ)
for λ ≥ 0). Derive and sketch the Lagrange dual function g.

(c) Lagrange dual problem. State the dual problem, and verify that it is a concave
maximization problem. Find the dual optimal value and dual optimal solution λ⋆.
Does strong duality hold?

(d) Sensitivity analysis. Let p⋆(u) denote the optimal value of the problem

minimize x2 + 1
subject to (x− 2)(x− 4) ≤ u,

as a function of the parameter u. Plot p⋆(u). Verify that dp⋆(0)/du = −λ⋆.
5.2 Weak duality for unbounded and infeasible problems. The weak duality inequality, d⋆ ≤ p⋆,

clearly holds when d⋆ = −∞ or p⋆ = ∞. Show that it holds in the other two cases as
well: If p⋆ = −∞, then we must have d⋆ = −∞, and also, if d⋆ =∞, then we must have
p⋆ =∞.

5.3 Problems with one inequality constraint. Express the dual problem of

minimize cTx
subject to f(x) ≤ 0,

with c 6= 0, in terms of the conjugate f∗. Explain why the problem you give is convex.
We do not assume f is convex.

Examples and applications

5.4 Interpretation of LP dual via relaxed problems. Consider the inequality form LP

minimize cTx
subject to Ax � b,

with A ∈ Rm×n, b ∈ Rm. In this exercise we develop a simple geometric interpretation
of the dual LP (5.22).

Let w ∈ Rm+ . If x is feasible for the LP, i.e., satisfies Ax � b, then it also satisfies the
inequality

wTAx ≤ wT b.
Geometrically, for any w � 0, the halfspace Hw = {x | wTAx ≤ wT b} contains the feasible
set for the LP. Therefore if we minimize the objective cTx over the halfspace Hw we get
a lower bound on p⋆.



274 5 Duality

(a) Derive an expression for the minimum value of cTx over the halfspace Hw (which
will depend on the choice of w � 0).

(b) Formulate the problem of finding the best such bound, by maximizing the lower
bound over w � 0.

(c) Relate the results of (a) and (b) to the Lagrange dual of the LP, given by (5.22).

5.5 Dual of general LP. Find the dual function of the LP

minimize cTx
subject to Gx � h

Ax = b.

Give the dual problem, and make the implicit equality constraints explicit.

5.6 Lower bounds in Chebyshev approximation from least-squares. Consider the Chebyshev
or ℓ∞-norm approximation problem

minimize ‖Ax− b‖∞, (5.103)

where A ∈ Rm×n and rankA = n. Let xch denote an optimal solution (there may be
multiple optimal solutions; xch denotes one of them).

The Chebyshev problem has no closed-form solution, but the corresponding least-squares
problem does. Define

xls = argmin ‖Ax− b‖2 = (ATA)−1AT b.

We address the following question. Suppose that for a particular A and b we have com-
puted the least-squares solution xls (but not xch). How suboptimal is xls for the Chebyshev
problem? In other words, how much larger is ‖Axls − b‖∞ than ‖Axch − b‖∞?
(a) Prove the lower bound

‖Axls − b‖∞ ≤
√
m ‖Axch − b‖∞,

using the fact that for all z ∈ Rm,
1√
m
‖z‖2 ≤ ‖z‖∞ ≤ ‖z‖2.

(b) In example 5.6 (page 254) we derived a dual for the general norm approximation
problem. Applying the results to the ℓ∞-norm (and its dual norm, the ℓ1-norm), we
can state the following dual for the Chebyshev approximation problem:

maximize bT ν
subject to ‖ν‖1 ≤ 1

AT ν = 0.
(5.104)

Any feasible ν corresponds to a lower bound bT ν on ‖Axch − b‖∞.
Denote the least-squares residual as rls = b−Axls. Assuming rls 6= 0, show that

νˆ = −rls/‖rls‖1, ν˜ = rls/‖rls‖1,

are both feasible in (5.104). By duality bT νˆ and bT ν˜ are lower bounds on ‖Axch −
b‖∞. Which is the better bound? How do these bounds compare with the bound
derived in part (a)?



Exercises 275

5.7 Piecewise-linear minimization. We consider the convex piecewise-linear minimization
problem

minimize maxi=1,...,m(a
T
i x+ bi) (5.105)

with variable x ∈ Rn.
(a) Derive a dual problem, based on the Lagrange dual of the equivalent problem

minimize maxi=1,...,m yi
subject to aTi x+ bi = yi, i = 1, . . . ,m,

with variables x ∈ Rn, y ∈ Rm.
(b) Formulate the piecewise-linear minimization problem (5.105) as an LP, and form the

dual of the LP. Relate the LP dual to the dual obtained in part (a).

(c) Suppose we approximate the objective function in (5.105) by the smooth function

f0(x) = log

(
m∑
i=1

exp(aTi x+ bi)

)
,

and solve the unconstrained geometric program

minimize log
(∑m

i=1
exp(aTi x+ bi)

)
. (5.106)

A dual of this problem is given by (5.62). Let p⋆pwl and p
⋆
gp be the optimal values

of (5.105) and (5.106), respectively. Show that

0 ≤ p⋆gp − p⋆pwl ≤ logm.

(d) Derive similar bounds for the difference between p⋆pwl and the optimal value of

minimize (1/γ) log
(∑m

i=1
exp(γ(aTi x+ bi))

)
,

where γ > 0 is a parameter. What happens as we increase γ?

5.8 Relate the two dual problems derived in example 5.9 on page 257.

5.9 Suboptimality of a simple covering ellipsoid. Recall the problem of determining the min-
imum volume ellipsoid, centered at the origin, that contains the points a1, . . . , am ∈ Rn
(problem (5.14), page 222):

minimize f0(X) = log det(X
−1)

subject to aTi Xai ≤ 1, i = 1, . . . ,m,

with dom f0 = S
n
++. We assume that the vectors a1, . . . , am span R

n (which implies that
the problem is bounded below).

(a) Show that the matrix

Xsim =

(
m∑
k=1

aka
T
k

)−1
,

is feasible. Hint. Show that [ ∑m
k=1

aka
T
k ai

aTi 1

]
� 0,

and use Schur complements (§A.5.5) to prove that aTi Xai ≤ 1 for i = 1, . . . ,m.



276 5 Duality

(b) Now we establish a bound on how suboptimal the feasible point Xsim is, via the dual
problem,

maximize log det
(∑m

i=1
λiaia

T
i

)
− 1Tλ+ n

subject to λ � 0,
with the implicit constraint

∑m
i=1

λiaia
T
i ≻ 0. (This dual is derived on page 222.)

To derive a bound, we restrict our attention to dual variables of the form λ = t1,
where t > 0. Find (analytically) the optimal value of t, and evaluate the dual
objective at this λ. Use this to prove that the volume of the ellipsoid {u | uTXsimu ≤
1} is no more than a factor (m/n)n/2 more than the volume of the minimum volume
ellipsoid.

5.10 Optimal experiment design. The following problems arise in experiment design (see §7.5).
(a) D-optimal design.

minimize log det
(∑p

i=1
xiviv

T
i

)−1
subject to x � 0, 1Tx = 1.

(b) A-optimal design.

minimize tr
(∑p

i=1
xiviv

T
i

)−1
subject to x � 0, 1Tx = 1.

The domain of both problems is {x | ∑p
i=1

xiviv
T
i ≻ 0}. The variable is x ∈ Rp; the

vectors v1, . . . , vp ∈ Rn are given.
Derive dual problems by first introducing a new variable X ∈ Sn and an equality con-
straint X =

∑p
i=1

xiviv
T
i , and then applying Lagrange duality. Simplify the dual prob-

lems as much as you can.

5.11 Derive a dual problem for

minimize
∑N

i=1
‖Aix+ bi‖2 + (1/2)‖x− x0‖22.

The problem data are Ai ∈ Rmi×n, bi ∈ Rmi , and x0 ∈ Rn. First introduce new variables
yi ∈ Rmi and equality constraints yi = Aix+ bi.

5.12 Analytic centering. Derive a dual problem for

minimize −∑m
i=1

log(bi − aTi x)
with domain {x | aTi x < bi, i = 1, . . . ,m}. First introduce new variables yi and equality
constraints yi = bi − aTi x.
(The solution of this problem is called the analytic center of the linear inequalities aTi x ≤
bi, i = 1, . . . ,m. Analytic centers have geometric applications (see §8.5.3), and play an
important role in barrier methods (see chapter 11).)

5.13 Lagrangian relaxation of Boolean LP. A Boolean linear program is an optimization prob-
lem of the form

minimize cTx
subject to Ax � b

xi ∈ {0, 1}, i = 1, . . . , n,
and is, in general, very difficult to solve. In exercise 4.15 we studied the LP relaxation of
this problem,

minimize cTx
subject to Ax � b

0 ≤ xi ≤ 1, i = 1, . . . , n,
(5.107)

which is far easier to solve, and gives a lower bound on the optimal value of the Boolean
LP. In this problem we derive another lower bound for the Boolean LP, and work out the
relation between the two lower bounds.



Exercises 277

(a) Lagrangian relaxation. The Boolean LP can be reformulated as the problem

minimize cTx
subject to Ax � b

xi(1− xi) = 0, i = 1, . . . , n,
which has quadratic equality constraints. Find the Lagrange dual of this problem.
The optimal value of the dual problem (which is convex) gives a lower bound on
the optimal value of the Boolean LP. This method of finding a lower bound on the
optimal value is called Lagrangian relaxation.

(b) Show that the lower bound obtained via Lagrangian relaxation, and via the LP
relaxation (5.107), are the same. Hint. Derive the dual of the LP relaxation (5.107).

5.14 A penalty method for equality constraints. We consider the problem

minimize f0(x)
subject to Ax = b,

(5.108)

where f0 : R
n → R is convex and differentiable, and A ∈ Rm×n with rankA = m.

In a quadratic penalty method, we form an auxiliary function

φ(x) = f0(x) + α‖Ax− b‖22,
where α > 0 is a parameter. This auxiliary function consists of the objective plus the
penalty term α‖Ax−b‖22. The idea is that a minimizer of the auxiliary function, x˜, should
be an approximate solution of the original problem. Intuition suggests that the larger the
penalty weight α, the better the approximation x˜ to a solution of the original problem.

Suppose x˜ is a minimizer of φ. Show how to find, from x˜, a dual feasible point for (5.108).
Find the corresponding lower bound on the optimal value of (5.108).

5.15 Consider the problem

minimize f0(x)
subject to fi(x) ≤ 0, i = 1, . . . ,m, (5.109)

where the functions fi : R
n → R are differentiable and convex. Let h1, . . . , hm : R→ R

be increasing differentiable convex functions. Show that

φ(x) = f0(x) +

m∑
i=1

hi(fi(x))

is convex. Suppose x˜ minimizes φ. Show how to find from x˜ a feasible point for the dual
of (5.109). Find the corresponding lower bound on the optimal value of (5.109).

5.16 An exact penalty method for inequality constraints. Consider the problem

minimize f0(x)
subject to fi(x) ≤ 0, i = 1, . . . ,m, (5.110)

where the functions fi : R
n → R are differentiable and convex. In an exact penalty

method, we solve the auxiliary problem

minimize φ(x) = f0(x) + αmaxi=1,...,mmax{0, fi(x)}, (5.111)
where α > 0 is a parameter. The second term in φ penalizes deviations of x from feasibility.
The method is called an exact penalty method if for sufficiently large α, solutions of the
auxiliary problem (5.111) also solve the original problem (5.110).

(a) Show that φ is convex.



278 5 Duality

(b) The auxiliary problem can be expressed as

minimize f0(x) + αy
subject to fi(x) ≤ y, i = 1, . . . ,m

0 ≤ y
where the variables are x and y ∈ R. Find the Lagrange dual of this problem, and
express it in terms of the Lagrange dual function g of (5.110).

(c) Use the result in (b) to prove the following property. Suppose λ⋆ is an optimal
solution of the Lagrange dual of (5.110), and that strong duality holds. If α >
1Tλ⋆, then any solution of the auxiliary problem (5.111) is also an optimal solution
of (5.110).

5.17 Robust linear programming with polyhedral uncertainty. Consider the robust LP

minimize cTx
subject to supa∈Pi a

Tx ≤ bi, i = 1, . . . ,m,
with variable x ∈ Rn, where Pi = {a | Cia � di}. The problem data are c ∈ Rn,
Ci ∈ Rmi×n, di ∈ Rmi , and b ∈ Rm. We assume the polyhedra Pi are nonempty.
Show that this problem is equivalent to the LP

minimize cTx
subject to dTi zi ≤ bi, i = 1, . . . ,m

CTi zi = x, i = 1, . . . ,m
zi � 0, i = 1, . . . ,m

with variables x ∈ Rn and zi ∈ Rmi , i = 1, . . . ,m. Hint. Find the dual of the problem
of maximizing aTi x over ai ∈ Pi (with variable ai).

5.18 Separating hyperplane between two polyhedra. Formulate the following problem as an LP
or an LP feasibility problem. Find a separating hyperplane that strictly separates two
polyhedra

P1 = {x | Ax � b}, P2 = {x | Cx � d},
i.e., find a vector a ∈ Rn and a scalar γ such that

aTx > γ for x ∈ P1, aTx < γ for x ∈ P2.
You can assume that P1 and P2 do not intersect.
Hint. The vector a and scalar γ must satisfy

inf
x∈P1

aTx > γ > sup
x∈P2

aTx.

Use LP duality to simplify the infimum and supremum in these conditions.

5.19 The sum of the largest elements of a vector. Define f : Rn → R as

f(x) =

r∑
i=1

x[i],

where r is an integer between 1 and n, and x[1] ≥ x[2] ≥ · · · ≥ x[r] are the components of
x sorted in decreasing order. In other words, f(x) is the sum of the r largest elements of
x. In this problem we study the constraint

f(x) ≤ α.
As we have seen in chapter 3, page 80, this is a convex constraint, and equivalent to a set
of n!/(r!(n− r)!) linear inequalities

xi1 + · · ·+ xir ≤ α, 1 ≤ i1 < i2 < · · · < ir ≤ n.
The purpose of this problem is to derive a more compact representation.



Exercises 279

(a) Given a vector x ∈ Rn, show that f(x) is equal to the optimal value of the LP

maximize xT y
subject to 0 � y � 1

1T y = r

with y ∈ Rn as variable.
(b) Derive the dual of the LP in part (a). Show that it can be written as

minimize rt+ 1Tu
subject to t1+ u � x

u � 0,

where the variables are t ∈ R, u ∈ Rn. By duality this LP has the same optimal
value as the LP in (a), i.e., f(x). We therefore have the following result: x satisfies
f(x) ≤ α if and only if there exist t ∈ R, u ∈ Rn such that

rt+ 1Tu ≤ α, t1+ u � x, u � 0.

These conditions form a set of 2n+1 linear inequalities in the 2n+1 variables x, u, t.

(c) As an application, we consider an extension of the classical Markowitz portfolio
optimization problem

minimize xTΣx
subject to pTx ≥ rmin

1Tx = 1, x � 0

discussed in chapter 4, page 155. The variable is the portfolio x ∈ Rn; p and Σ are
the mean and covariance matrix of the price change vector p.

Suppose we add a diversification constraint, requiring that no more than 80% of
the total budget can be invested in any 10% of the assets. This constraint can be
expressed as

⌊0.1n⌋∑
i=1

x[i] ≤ 0.8.

Formulate the portfolio optimization problem with diversification constraint as a
QP.

5.20 Dual of channel capacity problem. Derive a dual for the problem

minimize −cTx+∑m
i=1

yi log yi
subject to Px = y

x � 0, 1Tx = 1,

where P ∈ Rm×n has nonnegative elements, and its columns add up to one (i.e., PT1 =
1). The variables are x ∈ Rn, y ∈ Rm. (For cj =

∑m
i=1

pij log pij , the optimal value is,
up to a factor log 2, the negative of the capacity of a discrete memoryless channel with
channel transition probability matrix P ; see exercise 4.57.)

Simplify the dual problem as much as possible.



280 5 Duality

Strong duality and Slater’s condition

5.21 A convex problem in which strong duality fails. Consider the optimization problem

minimize e−x

subject to x2/y ≤ 0
with variables x and y, and domain D = {(x, y) | y > 0}.
(a) Verify that this is a convex optimization problem. Find the optimal value.

(b) Give the Lagrange dual problem, and find the optimal solution λ⋆ and optimal value
d⋆ of the dual problem. What is the optimal duality gap?

(c) Does Slater’s condition hold for this problem?

(d) What is the optimal value p⋆(u) of the perturbed problem

minimize e−x

subject to x2/y ≤ u
as a function of u? Verify that the global sensitivity inequality

p⋆(u) ≥ p⋆(0)− λ⋆u
does not hold.

5.22 Geometric interpretation of duality. For each of the following optimization problems,
draw a sketch of the sets

G = {(u, t) | ∃x ∈ D, f0(x) = t, f1(x) = u},
A = {(u, t) | ∃x ∈ D, f0(x) ≤ t, f1(x) ≤ u},

give the dual problem, and solve the primal and dual problems. Is the problem convex?
Is Slater’s condition satisfied? Does strong duality hold?

The domain of the problem is R unless otherwise stated.

(a) Minimize x subject to x2 ≤ 1.
(b) Minimize x subject to x2 ≤ 0.
(c) Minimize x subject to |x| ≤ 0.
(d) Minimize x subject to f1(x) ≤ 0 where

f1(x) =

{ −x+ 2 x ≥ 1
x −1 ≤ x ≤ 1
−x− 2 x ≤ −1.

(e) Minimize x3 subject to −x+ 1 ≤ 0.
(f) Minimize x3 subject to −x+ 1 ≤ 0 with domain D = R+.

5.23 Strong duality in linear programming. We prove that strong duality holds for the LP

minimize cTx
subject to Ax � b

and its dual
maximize −bT z
subject to AT z + c = 0, z � 0,

provided at least one of the problems is feasible. In other words, the only possible excep-
tion to strong duality occurs when p⋆ =∞ and d⋆ = −∞.



Exercises 281

(a) Suppose p⋆ is finite and x⋆ is an optimal solution. (If finite, the optimal value of an
LP is attained.) Let I ⊆ {1, 2, . . . ,m} be the set of active constraints at x⋆:

aTi x
⋆ = bi, i ∈ I, aTi x⋆ < bi, i 6∈ I.

Show that there exists a z ∈ Rm that satisfies

zi ≥ 0, i ∈ I, zi = 0, i 6∈ I,
∑
i∈I

ziai + c = 0.

Show that z is dual optimal with objective value cTx⋆.

Hint. Assume there exists no such z, i.e., −c 6∈ {∑
i∈I

ziai | zi ≥ 0}. Reduce
this to a contradiction by applying the strict separating hyperplane theorem of
example 2.20, page 49. Alternatively, you can use Farkas’ lemma (see §5.8.3).

(b) Suppose p⋆ =∞ and the dual problem is feasible. Show that d⋆ =∞. Hint. Show
that there exists a nonzero v ∈ Rm such that AT v = 0, v � 0, bT v < 0. If the dual
is feasible, it is unbounded in the direction v.

(c) Consider the example

minimize x

subject to

[
0
1

]
x �

[
−1
1

]
.

Formulate the dual LP, and solve the primal and dual problems. Show that p⋆ =∞
and d⋆ = −∞.

5.24 Weak max-min inequality. Show that the weak max-min inequality

sup
z∈Z

inf
w∈W

f(w, z) ≤ inf
w∈W

sup
z∈Z

f(w, z)

always holds, with no assumptions on f : Rn ×Rm → R, W ⊆ Rn, or Z ⊆ Rm.
5.25 [BL00, page 95] Convex-concave functions and the saddle-point property. We derive con-

ditions under which the saddle-point property

sup
z∈Z

inf
w∈W

f(w, z) = inf
w∈W

sup
z∈Z

f(w, z) (5.112)

holds, where f : Rn ×Rm → R, W × Z ⊆ dom f , and W and Z are nonempty. We will
assume that the function

gz(w) =

{
f(w, z) w ∈W
∞ otherwise

is closed and convex for all z ∈ Z, and the function

hw(z) =

{
−f(w, z) z ∈ Z
∞ otherwise

is closed and convex for all w ∈W .
(a) The righthand side of (5.112) can be expressed as p(0), where

p(u) = inf
w∈W

sup
z∈Z

(f(w, z) + uT z).

Show that p is a convex function.



282 5 Duality

(b) Show that the conjugate of p is given by

p∗(v) =

{
− infw∈W f(w, v) v ∈ Z
∞ otherwise.

(c) Show that the conjugate of p∗ is given by

p∗∗(u) = sup
z∈Z

inf
w∈W

(f(w, z) + uT z).

Combining this with (a), we can express the max-min equality (5.112) as p∗∗(0) =
p(0).

(d) From exercises 3.28 and 3.39 (d), we know that p∗∗(0) = p(0) if 0 ∈ int dom p.
Conclude that this is the case if W and Z are bounded.

(e) As another consequence of exercises 3.28 and 3.39, we have p∗∗(0) = p(0) if 0 ∈
dom p and p is closed. Show that p is closed if the sublevel sets of gz are bounded.

Optimality conditions

5.26 Consider the QCQP

minimize x21 + x
2
2

subject to (x1 − 1)2 + (x2 − 1)2 ≤ 1
(x1 − 1)2 + (x2 + 1)2 ≤ 1

with variable x ∈ R2.
(a) Sketch the feasible set and level sets of the objective. Find the optimal point x⋆ and

optimal value p⋆.

(b) Give the KKT conditions. Do there exist Lagrange multipliers λ⋆1 and λ
⋆
2 that prove

that x⋆ is optimal?

(c) Derive and solve the Lagrange dual problem. Does strong duality hold?

5.27 Equality constrained least-squares. Consider the equality constrained least-squares prob-
lem

minimize ‖Ax− b‖22
subject to Gx = h

where A ∈ Rm×n with rankA = n, and G ∈ Rp×n with rankG = p.
Give the KKT conditions, and derive expressions for the primal solution x⋆ and the dual
solution ν⋆.

5.28 Prove (without using any linear programming code) that the optimal solution of the LP

minimize 47x1 + 93x2 + 17x3 − 93x4

subject to


−1 −6 1 3
−1 −2 7 1
0 3 −10 −1

−6 −11 −2 12
1 6 −1 −3


 x1x2x3

x4

 �

−3
5

−8
−7
4


is unique, and given by x⋆ = (1, 1, 1, 1).

5.29 The problem
minimize −3x21 + x22 + 2x23 + 2(x1 + x2 + x3)
subject to x21 + x

2
2 + x

2
3 = 1,

is a special case of (5.32), so strong duality holds even though the problem is not convex.
Derive the KKT conditions. Find all solutions x, ν that satisfy the KKT conditions.
Which pair corresponds to the optimum?



Exercises 283

5.30 Derive the KKT conditions for the problem

minimize trX − log detX
subject to Xs = y,

with variable X ∈ Sn and domain Sn++. y ∈ Rn and s ∈ Rn are given, with sT y = 1.
Verify that the optimal solution is given by

X⋆ = I + yyT − 1
sT s

ssT .

5.31 Supporting hyperplane interpretation of KKT conditions. Consider a convex problem with
no equality constraints,

minimize f0(x)
subject to fi(x) ≤ 0, i = 1, . . . ,m.

Assume that x⋆ ∈ Rn and λ⋆ ∈ Rm satisfy the KKT conditions
fi(x

⋆) ≤ 0, i = 1, . . . ,m
λ⋆i ≥ 0, i = 1, . . . ,m

λ⋆i fi(x
⋆) = 0, i = 1, . . . ,m

∇f0(x⋆) +
∑m

i=1
λ⋆i∇fi(x⋆) = 0.

Show that
∇f0(x⋆)T (x− x⋆) ≥ 0

for all feasible x. In other words the KKT conditions imply the simple optimality criterion
of §4.2.3.

Perturbation and sensitivity analysis

5.32 Optimal value of perturbed problem. Let f0, f1, . . . , fm : R
n → R be convex. Show that

the function

p⋆(u, v) = inf{f0(x) | ∃x ∈ D, fi(x) ≤ ui, i = 1, . . . ,m, Ax− b = v}
is convex. This function is the optimal cost of the perturbed problem, as a function of
the perturbations u and v (see §5.6.1).

5.33 Parametrized ℓ1-norm approximation. Consider the ℓ1-norm minimization problem

minimize ‖Ax+ b+ ǫd‖1

with variable x ∈ R3, and

A =


−2 7 1
−5 −1 3
−7 3 −5
−1 4 −4
1 5 5
2 −5 −1

 , b =


−4
3
9
0

−11
5

 , d =

−10
−13
−27
−10
−7
14

 .

We denote by p⋆(ǫ) the optimal value as a function of ǫ.

(a) Suppose ǫ = 0. Prove that x⋆ = 1 is optimal. Are there any other optimal points?

(b) Show that p⋆(ǫ) is affine on an interval that includes ǫ = 0.



284 5 Duality

5.34 Consider the pair of primal and dual LPs

minimize (c+ ǫd)Tx
subject to Ax � b+ ǫf

and
maximize −(b+ ǫf)T z
subject to AT z + c+ ǫd = 0

z � 0
where

A =


−4 12 −2 1
−17 12 7 11

1 0 −6 1
3 3 22 −1

−11 2 −1 −8

 , b =


8
13
−4
27

−18

 , f =


6
15

−13
48
8

 ,
c = (49,−34,−50,−5), d = (3, 8, 21, 25), and ǫ is a parameter.
(a) Prove that x⋆ = (1, 1, 1, 1) is optimal when ǫ = 0, by constructing a dual optimal

point z⋆ that has the same objective value as x⋆. Are there any other primal or dual
optimal solutions?

(b) Give an explicit expression for the optimal value p⋆(ǫ) as a function of ǫ on an
interval that contains ǫ = 0. Specify the interval on which your expression is valid.
Also give explicit expressions for the primal solution x⋆(ǫ) and the dual solution
z⋆(ǫ) as a function of ǫ, on the same interval.

Hint. First calculate x⋆(ǫ) and z⋆(ǫ), assuming that the primal and dual constraints
that are active at the optimum for ǫ = 0, remain active at the optimum for values
of ǫ around 0. Then verify that this assumption is correct.

5.35 Sensitivity analysis for GPs. Consider a GP

minimize f0(x)
subject to fi(x) ≤ 1, i = 1, . . . ,m

hi(x) = 1, i = 1, . . . , p,

where f0, . . . , fm are posynomials, h1, . . . , hp are monomials, and the domain of the prob-
lem is Rn++. We define the perturbed GP as

minimize f0(x)
subject to fi(x) ≤ eui , i = 1, . . . ,m

hi(x) = e
vi , i = 1, . . . , p,

and we denote the optimal value of the perturbed GP as p⋆(u, v). We can think of ui and
vi as relative, or fractional, perturbations of the constraints. For example, u1 = −0.01
corresponds to tightening the first inequality constraint by (approximately) 1%.

Let λ⋆ and ν⋆ be optimal dual variables for the convex form GP

minimize log f0(y)
subject to log fi(y) ≤ 0, i = 1, . . . ,m

log hi(y) = 0, i = 1, . . . , p,

with variables yi = log xi. Assuming that p
⋆(u, v) is differentiable at u = 0, v = 0, relate

λ⋆ and ν⋆ to the derivatives of p⋆(u, v) at u = 0, v = 0. Justify the statement “Relaxing
the ith constraint by α percent will give an improvement in the objective of around αλ⋆i
percent, for α small.”



Exercises 285

Theorems of alternatives

5.36 Alternatives for linear equalities. Consider the linear equations Ax = b, where A ∈ Rm×n.
From linear algebra we know that this equation has a solution if and only b ∈ R(A), which
occurs if and only if b ⊥ N (AT ). In other words, Ax = b has a solution if and only if
there exists no y ∈ Rm such that AT y = 0 and bT y 6= 0.
Derive this result from the theorems of alternatives in §5.8.2.

5.37 [BT97] Existence of equilibrium distribution in finite state Markov chain. Let P ∈ Rn×n
be a matrix that satisfies

pij ≥ 0, i, j = 1, . . . , n, PT1 = 1,
i.e., the coefficients are nonnegative and the columns sum to one. Use Farkas’ lemma to
prove there exists a y ∈ Rn such that

Py = y, y � 0, 1T y = 1.
(We can interpret y as an equilibrium distribution of the Markov chain with n states and
transition probability matrix P .)

5.38 [BT97] Option pricing. We apply the results of example 5.10, page 263, to a simple
problem with three assets: a riskless asset with fixed return r > 1 over the investment
period of interest (for example, a bond), a stock, and an option on the stock. The option
gives us the right to purchase the stock at the end of the period, for a predetermined
price K.

We consider two scenarios. In the first scenario, the price of the stock goes up from
S at the beginning of the period, to Su at the end of the period, where u > r. In this
scenario, we exercise the option only if Su > K, in which case we make a profit of Su−K.
Otherwise, we do not exercise the option, and make zero profit. The value of the option
at the end of the period, in the first scenario, is therefore max{0, Su−K}.
In the second scenario, the price of the stock goes down from S to Sd, where d < 1. The
value at the end of the period is max{0, Sd−K}.
In the notation of example 5.10,

V =

[
r uS max{0, Su−K}
r dS max{0, Sd−K}

]
, p1 = 1, p2 = S, p3 = C,

where C is the price of the option.

Show that for given r, S, K, u, d, the option price C is uniquely determined by the
no-arbitrage condition. In other words, the market for the option is complete.

Generalized inequalities

5.39 SDP relaxations of two-way partitioning problem. We consider the two-way partitioning
problem (5.7), described on page 219,

minimize xTWx
subject to x2i = 1, i = 1, . . . , n,

(5.113)

with variable x ∈ Rn. The Lagrange dual of this (nonconvex) problem is given by the
SDP

maximize −1T ν
subject to W + diag(ν) � 0 (5.114)

with variable ν ∈ Rn. The optimal value of this SDP gives a lower bound on the optimal
value of the partitioning problem (5.113). In this exercise we derive another SDP that
gives a lower bound on the optimal value of the two-way partitioning problem, and explore
the connection between the two SDPs.



286 5 Duality

(a) Two-way partitioning problem in matrix form. Show that the two-way partitioning
problem can be cast as

minimize tr(WX)
subject to X � 0, rankX = 1

Xii = 1, i = 1, . . . , n,

with variable X ∈ Sn. Hint. Show that if X is feasible, then it has the form
X = xxT , where x ∈ Rn satisfies xi ∈ {−1, 1} (and vice versa).

(b) SDP relaxation of two-way partitioning problem. Using the formulation in part (a),
we can form the relaxation

minimize tr(WX)
subject to X � 0

Xii = 1, i = 1, . . . , n,
(5.115)

with variable X ∈ Sn. This problem is an SDP, and therefore can be solved effi-
ciently. Explain why its optimal value gives a lower bound on the optimal value of
the two-way partitioning problem (5.113). What can you say if an optimal point
X⋆ for this SDP has rank one?

(c) We now have two SDPs that give a lower bound on the optimal value of the two-way
partitioning problem (5.113): the SDP relaxation (5.115) found in part (b), and the
Lagrange dual of the two-way partitioning problem, given in (5.114). What is the
relation between the two SDPs? What can you say about the lower bounds found
by them? Hint: Relate the two SDPs via duality.

5.40 E-optimal experiment design. A variation on the two optimal experiment design problems
of exercise 5.10 is the E-optimal design problem

minimize λmax
(∑p

i=1
xiviv

T
i

)−1
subject to x � 0, 1Tx = 1.

(See also §7.5.) Derive a dual for this problem, by first reformulating it as
minimize 1/t
subject to

∑p
i=1

xiviv
T
i � tI

x � 0, 1Tx = 1,
with variables t ∈ R, x ∈ Rp and domain R++ × Rp, and applying Lagrange duality.
Simplify the dual problem as much as you can.

5.41 Dual of fastest mixing Markov chain problem. On page 174, we encountered the SDP

minimize t
subject to −tI � P − (1/n)11T � tI

P1 = 1
Pij ≥ 0, i, j = 1, . . . , n
Pij = 0 for (i, j) 6∈ E ,

with variables t ∈ R, P ∈ Sn.
Show that the dual of this problem can be expressed as

maximize 1T z − (1/n)1TY 1
subject to ‖Y ‖2∗ ≤ 1

(zi + zj) ≤ Yij for (i, j) ∈ E
with variables z ∈ Rn and Y ∈ Sn. The norm ‖ · ‖2∗ is the dual of the spectral norm
on Sn: ‖Y ‖2∗ =

∑n
i=1

|λi(Y )|, the sum of the absolute values of the eigenvalues of Y .
(See §A.1.6, page 637.)



Exercises 287

5.42 Lagrange dual of conic form problem in inequality form. Find the Lagrange dual problem
of the conic form problem in inequality form

minimize cTx
subject to Ax �K b

where A ∈ Rm×n, b ∈ Rm, and K is a proper cone in Rm. Make any implicit equality
constraints explicit.

5.43 Dual of SOCP. Show that the dual of the SOCP

minimize fTx
subject to ‖Aix+ bi‖2 ≤ cTi x+ di, i = 1, . . . ,m,

with variables x ∈ Rn, can be expressed as
maximize

∑m
i=1

(bTi ui − divi)
subject to

∑m
i=1

(ATi ui − civi) + f = 0
‖ui‖2 ≤ vi, i = 1, . . . ,m,

with variables ui ∈ Rni , vi ∈ R, i = 1, . . . ,m. The problem data are f ∈ Rn, Ai ∈ Rni×n,
bi ∈ Rni , ci ∈ R and di ∈ R, i = 1, . . . ,m.
Derive the dual in the following two ways.

(a) Introduce new variables yi ∈ Rni and ti ∈ R and equalities yi = Aix + bi, ti =
cTi x+ di, and derive the Lagrange dual.

(b) Start from the conic formulation of the SOCP and use the conic dual. Use the fact
that the second-order cone is self-dual.

5.44 Strong alternatives for nonstrict LMIs. In example 5.14, page 270, we mentioned that
the system

Z � 0, tr(GZ) > 0, tr(FiZ) = 0, i = 1, . . . , n, (5.116)
is a strong alternative for the nonstrict LMI

F (x) = x1F1 + · · ·+ xnFn +G � 0, (5.117)
if the matrices Fi satisfy

n∑
i=1

viFi � 0 =⇒
n∑
i=1

viFi = 0. (5.118)

In this exercise we prove this result, and give an example to illustrate that the systems
are not always strong alternatives.

(a) Suppose (5.118) holds, and that the optimal value of the auxiliary SDP

minimize s
subject to F (x) � sI

is positive. Show that the optimal value is attained. If follows from the discussion
in §5.9.4 that the systems (5.117) and (5.116) are strong alternatives.
Hint. The proof simplifies if you assume, without loss of generality, that the matrices
F1, . . . , Fn are independent, so (5.118) may be replaced by

∑n
i=1

viFi � 0⇒ v = 0.
(b) Take n = 1, and

G =

[
0 1
1 0

]
, F1 =

[
0 0
0 1

]
.

Show that (5.117) and (5.116) are both infeasible.





Part II

Applications





Chapter 6

Approximation and fitting

6.1 Norm approximation

6.1.1 Basic norm approximation problem

The simplest norm approximation problem is an unconstrained problem of the form

minimize ‖Ax− b‖ (6.1)

where A ∈ Rm×n and b ∈ Rm are problem data, x ∈ Rn is the variable, and ‖ · ‖ is
a norm on Rm. A solution of the norm approximation problem is sometimes called
an approximate solution of Ax ≈ b, in the norm ‖ · ‖. The vector

r = Ax− b
is called the residual for the problem; its components are sometimes called the
individual residuals associated with x.

The norm approximation problem (6.1) is a convex problem, and is solvable,
i.e., there is always at least one optimal solution. Its optimal value is zero if
and only if b ∈ R(A); the problem is more interesting and useful, however, when
b 6∈ R(A). We can assume without loss of generality that the columns of A are
independent; in particular, that m ≥ n. When m = n the optimal point is simply
A−1b, so we can assume that m > n.

Approximation interpretation

By expressing Ax as
Ax = x1a1 + · · ·+ xnan,

where a1, . . . , an ∈ Rm are the columns of A, we see that the goal of the norm
approximation problem is to fit or approximate the vector b by a linear combination
of the columns of A, as closely as possible, with deviation measured in the norm
‖ · ‖.

The approximation problem is also called the regression problem. In this context
the vectors a1, . . . , an are called the regressors, and the vector x1a1 + · · · + xnan,



292 6 Approximation and fitting

where x is an optimal solution of the problem, is called the regression of b (onto
the regressors).

Estimation interpretation

A closely related interpretation of the norm approximation problem arises in the
problem of estimating a parameter vector on the basis of an imperfect linear vector
measurement. We consider a linear measurement model

y = Ax+ v,

where y ∈ Rm is a vector measurement, x ∈ Rn is a vector of parameters to be
estimated, and v ∈ Rm is some measurement error that is unknown, but presumed
to be small (in the norm ‖ · ‖). The estimation problem is to make a sensible guess
as to what x is, given y.

If we guess that x has the value xˆ, then we are implicitly making the guess that
v has the value y −Axˆ. Assuming that smaller values of v (measured by ‖ · ‖) are
more plausible than larger values, the most plausible guess for x is

xˆ = argminz‖Az − y‖.

(These ideas can be expressed more formally in a statistical framework; see chap-
ter 7.)

Geometric interpretation

We consider the subspace A = R(A) ⊆ Rm, and a point b ∈ Rm. A projection of
the point b onto the subspace A, in the norm ‖ · ‖, is any point in A that is closest
to b, i.e., any optimal point for the problem

minimize ‖u− b‖
subject to u ∈ A.

Parametrizing an arbitrary element of R(A) as u = Ax, we see that solving the
norm approximation problem (6.1) is equivalent to computing a projection of b
onto A.

Design interpretation

We can interpret the norm approximation problem (6.1) as a problem of optimal
design. The n variables x1, . . . , xn are design variables whose values are to be
determined. The vector y = Ax gives a vector of m results, which we assume to
be linear functions of the design variables x. The vector b is a vector of target or
desired results. The goal is to choose a vector of design variables that achieves, as
closely as possible, the desired results, i.e., Ax ≈ b. We can interpret the residual
vector r as the deviation between the actual results (i.e., Ax) and the desired
or target results (i.e., b). If we measure the quality of a design by the norm of
the deviation between the actual results and the desired results, then the norm
approximation problem (6.1) is the problem of finding the best design.



6.1 Norm approximation 293

Weighted norm approximation problems

An extension of the norm approximation problem is the weighted norm approxima-
tion problem

minimize ‖W (Ax− b)‖
where the problem data W ∈ Rm×m is called the weighting matrix. The weight-
ing matrix is often diagonal, in which case it gives different relative emphasis to
different components of the residual vector r = Ax− b.

The weighted norm problem can be considered as a norm approximation prob-
lem with norm ‖·‖, and data A˜ =WA, b˜ =Wb, and therefore treated as a standard
norm approximation problem (6.1). Alternatively, the weighted norm approxima-
tion problem can be considered a norm approximation problem with data A and
b, and the W -weighted norm defined by

‖z‖W = ‖Wz‖
(assuming here that W is nonsingular).

Least-squares approximation

The most common norm approximation problem involves the Euclidean or ℓ2-
norm. By squaring the objective, we obtain an equivalent problem which is called
the least-squares approximation problem,

minimize ‖Ax− b‖22 = r21 + r22 + · · ·+ r2m,
where the objective is the sum of squares of the residuals. This problem can be
solved analytically by expressing the objective as the convex quadratic function

f(x) = xTATAx− 2bTAx+ bT b.
A point x minimizes f if and only if

∇f(x) = 2ATAx− 2AT b = 0,
i.e., if and only if x satisfies the so-called normal equations

ATAx = AT b,

which always have a solution. Since we assume the columns of A are independent,
the least-squares approximation problem has the unique solution x = (ATA)−1AT b.

Chebyshev or minimax approximation

When the ℓ∞-norm is used, the norm approximation problem

minimize ‖Ax− b‖∞ = max{|r1|, . . . , |rm|}
is called the Chebyshev approximation problem, or minimax approximation problem,
since we are to minimize the maximum (absolute value) residual. The Chebyshev
approximation problem can be cast as an LP

minimize t
subject to −t1 � Ax− b � t1,

with variables x ∈ Rn and t ∈ R.



294 6 Approximation and fitting

Sum of absolute residuals approximation

When the ℓ1-norm is used, the norm approximation problem

minimize ‖Ax− b‖1 = |r1|+ · · ·+ |rm|

is called the sum of (absolute) residuals approximation problem, or, in the context
of estimation, a robust estimator (for reasons that will be clear soon). Like the
Chebyshev approximation problem, the ℓ1-norm approximation problem can be
cast as an LP

minimize 1T t
subject to −t � Ax− b � t,

with variables x ∈ Rn and t ∈ Rm.

6.1.2 Penalty function approximation

In ℓp-norm approximation, for 1 ≤ p <∞, the objective is

(|r1|p + · · ·+ |rm|p)1/p .

As in least-squares problems, we can consider the equivalent problem with objective

|r1|p + · · ·+ |rm|p,

which is a separable and symmetric function of the residuals. In particular, the
objective depends only on the amplitude distribution of the residuals, i.e., the
residuals in sorted order.

We will consider a useful generalization of the ℓp-norm approximation problem,
in which the objective depends only on the amplitude distribution of the residuals.
The penalty function approximation problem has the form

minimize φ(r1) + · · ·+ φ(rm)
subject to r = Ax− b, (6.2)

where φ : R → R is called the (residual) penalty function. We assume that φ is
convex, so the penalty function approximation problem is a convex optimization
problem. In many cases, the penalty function φ is symmetric, nonnegative, and
satisfies φ(0) = 0, but we will not use these properties in our analysis.

Interpretation

We can interpret the penalty function approximation problem (6.2) as follows. For
the choice x, we obtain the approximation Ax of b, which has the associated resid-
ual vector r. A penalty function assesses a cost or penalty for each component
of residual, given by φ(ri); the total penalty is the sum of the penalties for each
residual, i.e., φ(r1) + · · ·+ φ(rm). Different choices of x lead to different resulting
residuals, and therefore, different total penalties. In the penalty function approxi-
mation problem, we minimize the total penalty incurred by the residuals.



6.1 Norm approximation 295

u

φ
(u
)

deadzone-linear

quadratic

log barrier

−1.5 −1 −0.5 0 0.5 1 1.50

0.5

1

1.5

2

Figure 6.1 Some common penalty functions: the quadratic penalty function
φ(u) = u2, the deadzone-linear penalty function with deadzone width a =
1/4, and the log barrier penalty function with limit a = 1.

Example 6.1 Some common penalty functions and associated approximation problems.

• By taking φ(u) = |u|p, where p ≥ 1, the penalty function approximation prob-
lem is equivalent to the ℓp-norm approximation problem. In particular, the
quadratic penalty function φ(u) = u2 yields least-squares or Euclidean norm
approximation, and the absolute value penalty function φ(u) = |u| yields ℓ1-
norm approximation.

• The deadzone-linear penalty function (with deadzone width a > 0) is given by

φ(u) =

{
0 |u| ≤ a
|u| − a |u| > a.

The deadzone-linear function assesses no penalty for residuals smaller than a.

• The log barrier penalty function (with limit a > 0) has the form

φ(u) =

{
−a2 log(1− (u/a)2) |u| < a
∞ |u| ≥ a.

The log barrier penalty function assesses an infinite penalty for residuals larger
than a.

A deadzone-linear, log barrier, and quadratic penalty function are plotted in fig-
ure 6.1. Note that the log barrier function is very close to the quadratic penalty for
|u/a| ≤ 0.25 (see exercise 6.1).

Scaling the penalty function by a positive number does not affect the solution of
the penalty function approximation problem, since this merely scales the objective



296 6 Approximation and fitting

function. But the shape of the penalty function has a large effect on the solution of
the penalty function approximation problem. Roughly speaking, φ(u) is a measure
of our dislike of a residual of value u. If φ is very small (or even zero) for small
values of u, it means we care very little (or not at all) if residuals have these values.
If φ(u) grows rapidly as u becomes large, it means we have a strong dislike for
large residuals; if φ becomes infinite outside some interval, it means that residuals
outside the interval are unacceptable. This simple interpretation gives insight into
the solution of a penalty function approximation problem, as well as guidelines for
choosing a penalty function.

As an example, let us compare ℓ1-norm and ℓ2-norm approximation, associ-
ated with the penalty functions φ1(u) = |u| and φ2(u) = u2, respectively. For
|u| = 1, the two penalty functions assign the same penalty. For small u we have
φ1(u)≫ φ2(u), so ℓ1-norm approximation puts relatively larger emphasis on small
residuals compared to ℓ2-norm approximation. For large u we have φ2(u)≫ φ1(u),
so ℓ1-norm approximation puts less weight on large residuals, compared to ℓ2-norm
approximation. This difference in relative weightings for small and large residuals
is reflected in the solutions of the associated approximation problems. The ampli-
tude distribution of the optimal residual for the ℓ1-norm approximation problem
will tend to have more zero and very small residuals, compared to the ℓ2-norm ap-
proximation solution. In contrast, the ℓ2-norm solution will tend to have relatively
fewer large residuals (since large residuals incur a much larger penalty in ℓ2-norm
approximation than in ℓ1-norm approximation).

Example

An example will illustrate these ideas. We take a matrix A ∈ R100×30 and vector
b ∈ R100 (chosen at random, but the results are typical), and compute the ℓ1-norm
and ℓ2-norm approximate solutions of Ax ≈ b, as well as the penalty function
approximations with a deadzone-linear penalty (with a = 0.5) and log barrier
penalty (with a = 1). Figure 6.2 shows the four associated penalty functions,
and the amplitude distributions of the optimal residuals for these four penalty
approximations. From the plots of the penalty functions we note that

• The ℓ1-norm penalty puts the most weight on small residuals and the least
weight on large residuals.

• The ℓ2-norm penalty puts very small weight on small residuals, but strong
weight on large residuals.

• The deadzone-linear penalty function puts no weight on residuals smaller
than 0.5, and relatively little weight on large residuals.

• The log barrier penalty puts weight very much like the ℓ2-norm penalty for
small residuals, but puts very strong weight on residuals larger than around
0.8, and infinite weight on residuals larger than 1.

Several features are clear from the amplitude distributions:

• For the ℓ1-optimal solution, many residuals are either zero or very small. The
ℓ1-optimal solution also has relatively more large residuals.



6.1 Norm approximation 297

p
=
1

p
=
2

D
ea
d
zo
n
e

L
og

b
ar
ri
er

r
−2

−2

−2

−2

−1

−1

−1

−1

0

0

0

0

1

1

1

1

2

2

2

2
0

40

0

10

0

20

0

10

Figure 6.2 Histogram of residual amplitudes for four penalty functions, with
the (scaled) penalty functions also shown for reference. For the log barrier
plot, the quadratic penalty is also shown, in dashed curve.



298 6 Approximation and fitting

u

φ
(u
)

−1.5 −1 −0.5 0 0.5 1 1.50

0.5

1

1.5

Figure 6.3 A (nonconvex) penalty function that assesses a fixed penalty to
residuals larger than a threshold (which in this example is one): φ(u) = u2

if |u| ≤ 1 and φ(u) = 1 if |u| > 1. As a result, penalty approximation with
this function would be relatively insensitive to outliers.

• The ℓ2-norm approximation has many modest residuals, and relatively few
larger ones.

• For the deadzone-linear penalty, we see that many residuals have the value
±0.5, right at the edge of the ‘free’ zone, for which no penalty is assessed.

• For the log barrier penalty, we see that no residuals have a magnitude larger
than 1, but otherwise the residual distribution is similar to the residual dis-
tribution for ℓ2-norm approximation.

Sensitivity to outliers or large errors

In the estimation or regression context, an outlier is a measurement yi = a
T
i x+ vi

for which the noise vi is relatively large. This is often associated with faulty data
or a flawed measurement. When outliers occur, any estimate of x will be associated
with a residual vector with some large components. Ideally we would like to guess
which measurements are outliers, and either remove them from the estimation
process or greatly lower their weight in forming the estimate. (We cannot, however,
assign zero penalty for very large residuals, because then the optimal point would
likely make all residuals large, which yields a total penalty of zero.) This could be
accomplished using penalty function approximation, with a penalty function such
as

φ(u) =

{
u2 |u| ≤M
M2 |u| > M, (6.3)

shown in figure 6.3. This penalty function agrees with least-squares for any residual
smaller than M , but puts a fixed weight on any residual larger than M , no matter
how much larger it is. In other words, residuals larger than M are ignored; they
are assumed to be associated with outliers or bad data. Unfortunately, the penalty



6.1 Norm approximation 299

u

φ
h
u
b
(u
)

−1.5 −1 −0.5 0 0.5 1 1.50

0.5

1

1.5

2

Figure 6.4 The solid line is the robust least-squares or Huber penalty func-
tion φhub, with M = 1. For |u| ≤ M it is quadratic, and for |u| > M it
grows linearly.

function (6.3) is not convex, and the associated penalty function approximation
problem becomes a hard combinatorial optimization problem.

The sensitivity of a penalty function based estimation method to outliers de-
pends on the (relative) value of the penalty function for large residuals. If we
restrict ourselves to convex penalty functions (which result in convex optimization
problems), the ones that are least sensitive are those for which φ(u) grows linearly,
i.e., like |u|, for large u. Penalty functions with this property are sometimes called
robust, since the associated penalty function approximation methods are much less
sensitive to outliers or large errors than, for example, least-squares.

One obvious example of a robust penalty function is φ(u) = |u|, corresponding
to ℓ1-norm approximation. Another example is the robust least-squares or Huber
penalty function, given by

φhub(u) =

{
u2 |u| ≤M
M(2|u| −M) |u| > M, (6.4)

shown in figure 6.4. This penalty function agrees with the least-squares penalty
function for residuals smaller than M , and then reverts to ℓ1-like linear growth for
larger residuals. The Huber penalty function can be considered a convex approx-
imation of the outlier penalty function (6.3), in the following sense: They agree
for |u| ≤ M , and for |u| > M , the Huber penalty function is the convex function
closest to the outlier penalty function (6.3).

Example 6.2 Robust regression. Figure 6.5 shows 42 points (ti, yi) in a plane, with
two obvious outliers (one at the upper left, and one at lower right). The dashed line
shows the least-squares approximation of the points by a straight line f(t) = α+ βt.
The coefficients α and β are obtained by solving the least-squares problem

minimize
∑42

i=1
(yi − α− βti)2,



300 6 Approximation and fitting

t

f
(t
)

−10 −5 0 5 10−20

−10

0

10

20

Figure 6.5 The 42 circles show points that can be well approximated by
an affine function, except for the two outliers at upper left and lower right.
The dashed line is the least-squares fit of a straight line f(t) = α + βt
to the points, and is rotated away from the main locus of points, toward
the outliers. The solid line shows the robust least-squares fit, obtained by
minimizing Huber’s penalty function with M = 1. This gives a far better fit
to the non-outlier data.

with variables α and β. The least-squares approximation is clearly rotated away from
the main locus of the points, toward the two outliers.

The solid line shows the robust least-squares approximation, obtained by minimizing
the Huber penalty function

minimize
∑42

i=1
φhub(yi − α− βti),

with M = 1. This approximation is far less affected by the outliers.

Since ℓ1-norm approximation is among the (convex) penalty function approxi-
mation methods that are most robust to outliers, ℓ1-norm approximation is some-
times called robust estimation or robust regression. The robustness property of
ℓ1-norm estimation can also be understood in a statistical framework; see page 353.

Small residuals and ℓ1-norm approximation

We can also focus on small residuals. Least-squares approximation puts very small
weight on small residuals, since φ(u) = u2 is very small when u is small. Penalty
functions such as the deadzone-linear penalty function put zero weight on small
residuals. For penalty functions that are very small for small residuals, we expect
the optimal residuals to be small, but not very small. Roughly speaking, there is
little or no incentive to drive small residuals smaller.

In contrast, penalty functions that put relatively large weight on small residuals,
such as φ(u) = |u|, corresponding to ℓ1-norm approximation, tend to produce



6.1 Norm approximation 301

optimal residuals many of which are very small, or even exactly zero. This means
that in ℓ1-norm approximation, we typically find that many of the equations are
satisfied exactly, i.e., we have aTi x = bi for many i. This phenomenon can be seen
in figure 6.2.

6.1.3 Approximation with constraints

It is possible to add constraints to the basic norm approximation problem (6.1).
When these constraints are convex, the resulting problem is convex. Constraints
arise for a variety of reasons.

• In an approximation problem, constraints can be used to rule out certain un-
acceptable approximations of the vector b, or to ensure that the approximator
Ax satisfies certain properties.

• In an estimation problem, the constraints arise as prior knowledge of the
vector x to be estimated, or from prior knowledge of the estimation error v.

• Constraints arise in a geometric setting in determining the projection of a
point b on a set more complicated than a subspace, for example, a cone or
polyhedron.

Some examples will make these clear.

Nonnegativity constraints on variables

We can add the constraint x � 0 to the basic norm approximation problem:

minimize ‖Ax− b‖
subject to x � 0.

In an estimation setting, nonnegativity constraints arise when we estimate a vector
x of parameters known to be nonnegative, e.g., powers, intensities, or rates. The
geometric interpretation is that we are determining the projection of a vector b onto
the cone generated by the columns of A. We can also interpret this problem as
approximating b using a nonnegative linear (i.e., conic) combination of the columns
of A.

Variable bounds

Here we add the constraint l � x � u, where l, u ∈ Rn are problem parameters:

minimize ‖Ax− b‖
subject to l � x � u.

In an estimation setting, variable bounds arise as prior knowledge of intervals in
which each variable lies. The geometric interpretation is that we are determining
the projection of a vector b onto the image of a box under the linear mapping
induced by A.



302 6 Approximation and fitting

Probability distribution

We can impose the constraint that x satisfy x � 0, 1Tx = 1:
minimize ‖Ax− b‖
subject to x � 0, 1Tx = 1.

This would arise in the estimation of proportions or relative frequencies, which are
nonnegative and sum to one. It can also be interpreted as approximating b by a
convex combination of the columns of A. (We will have much more to say about
estimating probabilities in §7.2.)

Norm ball constraint

We can add to the basic norm approximation problem the constraint that x lie in
a norm ball:

minimize ‖Ax− b‖
subject to ‖x− x0‖ ≤ d,

where x0 and d are problem parameters. Such a constraint can be added for several
reasons.

• In an estimation setting, x0 is a prior guess of what the parameter x is, and d
is the maximum plausible deviation of our estimate from our prior guess. Our
estimate of the parameter x is the value xˆ which best matches the measured
data (i.e., minimizes ‖Az − b‖) among all plausible candidates (i.e., z that
satisfy ‖z − x0‖ ≤ d).

• The constraint ‖x−x0‖ ≤ d can denote a trust region. Here the linear relation
y = Ax is only an approximation of some nonlinear relation y = f(x) that is
valid when x is near some point x0, specifically ‖x − x0‖ ≤ d. The problem
is to minimize ‖Ax− b‖ but only over those x for which the model y = Ax is
trusted.

These ideas also come up in the context of regularization; see §6.3.2.

6.2 Least-norm problems

The basic least-norm problem has the form

minimize ‖x‖
subject to Ax = b

(6.5)

where the data are A ∈ Rm×n and b ∈ Rm, the variable is x ∈ Rn, and ‖ · ‖ is a
norm on Rn. A solution of the problem, which always exists if the linear equations
Ax = b have a solution, is called a least-norm solution of Ax = b. The least-norm
problem is, of course, a convex optimization problem.

We can assume without loss of generality that the rows of A are independent, so
m ≤ n. When m = n, the only feasible point is x = A−1b; the least-norm problem
is interesting only whenm < n, i.e., when the equation Ax = b is underdetermined.



6.2 Least-norm problems 303

Reformulation as norm approximation problem

The least-norm problem (6.5) can be formulated as a norm approximation problem
by eliminating the equality constraint. Let x0 be any solution of Ax = b, and let
Z ∈ Rn×k be a matrix whose columns are a basis for the nullspace of A. The
general solution of Ax = b can then be expressed as x0 + Zu where u ∈ Rk. The
least-norm problem (6.5) can be expressed as

minimize ‖x0 + Zu‖,

with variable u ∈ Rk, which is a norm approximation problem. In particular,
our analysis and discussion of norm approximation problems applies to least-norm
problems as well (when interpreted correctly).

Control or design interpretation

We can interpret the least-norm problem (6.5) as a problem of optimal design or
optimal control. The n variables x1, . . . , xn are design variables whose values are
to be determined. In a control setting, the variables x1, . . . , xn represent inputs,
whose values we are to choose. The vector y = Ax gives m attributes or results of
the design x, which we assume to be linear functions of the design variables x. The
m < n equations Ax = b represent m specifications or requirements on the design.
Since m < n, the design is underspecified; there are n −m degrees of freedom in
the design (assuming A is rank m).

Among all the designs that satisfy the specifications, the least-norm problem
chooses the smallest design, as measured by the norm ‖ · ‖. This can be thought of
as the most efficient design, in the sense that it achieves the specifications Ax = b,
with the smallest possible x.

Estimation interpretation

We assume that x is a vector of parameters to be estimated. We have m < n
perfect (noise free) linear measurements, given by Ax = b. Since we have fewer
measurements than parameters to estimate, our measurements do not completely
determine x. Any parameter vector x that satisfies Ax = b is consistent with our
measurements.

To make a good guess about what x is, without taking further measurements,
we must use prior information. Suppose our prior information, or assumption, is
that x is more likely to be small (as measured by ‖ · ‖) than large. The least-norm
problem chooses as our estimate of the parameter vector x the one that is smallest
(hence, most plausible) among all parameter vectors that are consistent with the
measurements Ax = b. (For a statistical interpretation of the least-norm problem,
see page 359.)

Geometric interpretation

We can also give a simple geometric interpretation of the least-norm problem (6.5).
The feasible set {x | Ax = b} is affine, and the objective is the distance (measured
by the norm ‖ · ‖) between x and the point 0. The least-norm problem finds the



304 6 Approximation and fitting

point in the affine set with minimum distance to 0, i.e., it determines the projection
of the point 0 on the affine set {x | Ax = b}.

Least-squares solution of linear equations

The most common least-norm problem involves the Euclidean or ℓ2-norm. By
squaring the objective we obtain the equivalent problem

minimize ‖x‖22
subject to Ax = b,

the unique solution of which is called the least-squares solution of the equations
Ax = b. Like the least-squares approximation problem, this problem can be solved
analytically. Introducing the dual variable ν ∈ Rm, the optimality conditions are

2x⋆ +AT ν⋆ = 0, Ax⋆ = b,

which is a pair of linear equations, and readily solved. From the first equation
we obtain x⋆ = −(1/2)AT ν⋆; substituting this into the second equation we obtain
−(1/2)AAT ν⋆ = b, and conclude

ν⋆ = −2(AAT )−1b, x⋆ = AT (AAT )−1b.
(Since rankA = m < n, the matrix AAT is invertible.)

Least-penalty problems

A useful variation on the least-norm problem (6.5) is the least-penalty problem

minimize φ(x1) + · · ·+ φ(xn)
subject to Ax = b,

(6.6)

where φ : R → R is convex, nonnegative, and satisfies φ(0) = 0. The penalty
function value φ(u) quantifies our dislike of a component of x having value u;
the least-penalty problem then finds x that has least total penalty, subject to the
constraint Ax = b.

All of the discussion and interpretation of penalty functions in penalty function
approximation can be transposed to the least-penalty problem, by substituting
the amplitude distribution of x (in the least-penalty problem) for the amplitude
distribution of the residual r (in the penalty approximation problem).

Sparse solutions via least ℓ1-norm

Recall from the discussion on page 300 that ℓ1-norm approximation gives relatively
large weight to small residuals, and therefore results in many optimal residuals
small, or even zero. A similar effect occurs in the least-norm context. The least
ℓ1-norm problem,

minimize ‖x‖1
subject to Ax = b,

tends to produce a solution x with a large number of components equal to zero.
In other words, the least ℓ1-norm problem tends to produce sparse solutions of
Ax = b, often with m nonzero components.



6.3 Regularized approximation 305

It is easy to find solutions of Ax = b that have only m nonzero components.
Choose any set of m indices (out of 1, . . . , n) which are to be the nonzero com-
ponents of x. The equation Ax = b reduces to A˜x˜ = b, where A˜ is the m × m
submatrix of A obtained by selecting only the chosen columns, and x˜ ∈ Rm is the
subvector of x containing the m selected components. If A˜ is nonsingular, then
we can take x˜ = A˜−1b, which gives a feasible solution x with m or less nonzero
components. If A˜ is singular and b 6∈ R(A˜), the equation A˜x˜ = b is unsolvable,
which means there is no feasible x with the chosen set of nonzero components. If
A˜ is singular and b ∈ R(A˜), there is a feasible solution with fewer than m nonzero
components.

This approach can be used to find the smallest x with m (or fewer) nonzero
entries, but in general requires examining and comparing all n!/(m!(n−m)!) choices
of m nonzero coefficients of the n coefficients in x. Solving the least ℓ1-norm
problem, on the other hand, gives a good heuristic for finding a sparse, and small,
solution of Ax = b.

6.3 Regularized approximation

6.3.1 Bi-criterion formulation

In the basic form of regularized approximation, the goal is to find a vector x that
is small (if possible), and also makes the residual Ax − b small. This is naturally
described as a (convex) vector optimization problem with two objectives, ‖Ax− b‖
and ‖x‖:

minimize (w.r.t. R2+) (‖Ax− b‖, ‖x‖) . (6.7)

The two norms can be different: the first, used to measure the size of the residual,
is on Rm; the second, used to measure the size of x, is on Rn.

The optimal trade-off between the two objectives can be found using several
methods. The optimal trade-off curve of ‖Ax − b‖ versus ‖x‖, which shows how
large one of the objectives must be made to have the other one small, can then be
plotted. One endpoint of the optimal trade-off curve between ‖Ax − b‖ and ‖x‖
is easy to describe. The minimum value of ‖x‖ is zero, and is achieved only when
x = 0. For this value of x, the residual norm has the value ‖b‖.

The other endpoint of the trade-off curve is more complicated to describe. Let
C denote the set of minimizers of ‖Ax− b‖ (with no constraint on ‖x‖). Then any
minimum norm point in C is Pareto optimal, corresponding to the other endpoint
of the trade-off curve. In other words, Pareto optimal points at this endpoint are
given by minimum norm minimizers of ‖Ax− b‖. If both norms are Euclidean, this
Pareto optimal point is unique, and given by x = A†b, where A† is the pseudo-
inverse of A. (See §4.7.6, page 184, and §A.5.4.)



306 6 Approximation and fitting

6.3.2 Regularization

Regularization is a common scalarization method used to solve the bi-criterion
problem (6.7). One form of regularization is to minimize the weighted sum of the
objectives:

minimize ‖Ax− b‖+ γ‖x‖, (6.8)
where γ > 0 is a problem parameter. As γ varies over (0,∞), the solution of (6.8)
traces out the optimal trade-off curve.

Another common method of regularization, especially when the Euclidean norm
is used, is to minimize the weighted sum of squared norms, i.e.,

minimize ‖Ax− b‖2 + δ‖x‖2, (6.9)
for a variety of values of δ > 0.

These regularized approximation problems each solve the bi-criterion problem
of making both ‖Ax − b‖ and ‖x‖ small, by adding an extra term or penalty
associated with the norm of x.

Interpretations

Regularization is used in several contexts. In an estimation setting, the extra term
penalizing large ‖x‖ can be interpreted as our prior knowledge that ‖x‖ is not too
large. In an optimal design setting, the extra term adds the cost of using large
values of the design variables to the cost of missing the target specifications.

The constraint that ‖x‖ be small can also reflect a modeling issue. It might be,
for example, that y = Ax is only a good approximation of the true relationship
y = f(x) between x and y. In order to have f(x) ≈ b, we want Ax ≈ b, and also
need x small in order to ensure that f(x) ≈ Ax.

We will see in §6.4.1 and §6.4.2 that regularization can be used to take into
account variation in the matrix A. Roughly speaking, a large x is one for which
variation in A causes large variation in Ax, and hence should be avoided.

Regularization is also used when the matrix A is square, and the goal is to
solve the linear equations Ax = b. In cases where A is poorly conditioned, or even
singular, regularization gives a compromise between solving the equations (i.e.,
making ‖Ax− b‖ zero) and keeping x of reasonable size.

Regularization comes up in a statistical setting; see §7.1.2.

Tikhonov regularization

The most common form of regularization is based on (6.9), with Euclidean norms,
which results in a (convex) quadratic optimization problem:

minimize ‖Ax− b‖22 + δ‖x‖22 = xT (ATA+ δI)x− 2bTAx+ bT b. (6.10)
This Tikhonov regularization problem has the analytical solution

x = (ATA+ δI)−1AT b.

Since ATA+ δI ≻ 0 for any δ > 0, the Tikhonov regularized least-squares solution
requires no rank (or dimension) assumptions on the matrix A.



6.3 Regularized approximation 307

Smoothing regularization

The idea of regularization, i.e., adding to the objective a term that penalizes large
x, can be extended in several ways. In one useful extension we add a regularization
term of the form ‖Dx‖, in place of ‖x‖. In many applications, the matrix D
represents an approximate differentiation or second-order differentiation operator,
so ‖Dx‖ represents a measure of the variation or smoothness of x.

For example, suppose that the vector x ∈ Rn represents the value of some
continuous physical parameter, say, temperature, along the interval [0, 1]: xi is
the temperature at the point i/n. A simple approximation of the gradient or
first derivative of the parameter near i/n is given by n(xi+1 − xi), and a simple
approximation of its second derivative is given by the second difference

n (n(xi+1 − xi)− n(xi − xi−1)) = n2(xi+1 − 2xi + xi−1).
If ∆ is the (tridiagonal, Toeplitz) matrix

∆ = n2



1 −2 1 0 · · · 0 0 0 0
0 1 −2 1 · · · 0 0 0 0
0 0 1 −2 · · · 0 0 0 0
...

...
...

...
...

...
...

...
0 0 0 0 · · · −2 1 0 0
0 0 0 0 · · · 1 −2 1 0
0 0 0 0 · · · 0 1 −2 1


∈ R(n−2)×n,

then ∆x represents an approximation of the second derivative of the parameter, so
‖∆x‖22 represents a measure of the mean-square curvature of the parameter over
the interval [0, 1].

The Tikhonov regularized problem

minimize ‖Ax− b‖22 + δ‖∆x‖22
can be used to trade off the objective ‖Ax− b‖2, which might represent a measure
of fit, or consistency with experimental data, and the objective ‖∆x‖2, which is
(approximately) the mean-square curvature of the underlying physical parameter.
The parameter δ is used to control the amount of regularization required, or to
plot the optimal trade-off curve of fit versus smoothness.

We can also add several regularization terms. For example, we can add terms
associated with smoothness and size, as in

minimize ‖Ax− b‖22 + δ‖∆x‖22 + η‖x‖22.
Here, the parameter δ ≥ 0 is used to control the smoothness of the approximate
solution, and the parameter η ≥ 0 is used to control its size.

Example 6.3 Optimal input design. We consider a dynamical system with scalar
input sequence u(0), u(1), . . . , u(N), and scalar output sequence y(0), y(1), . . . , y(N),
related by convolution:

y(t) =

t∑
τ=0

h(τ)u(t− τ), t = 0, 1, . . . , N.



308 6 Approximation and fitting

The sequence h(0), h(1), . . . , h(N) is called the convolution kernel or impulse response
of the system.

Our goal is to choose the input sequence u to achieve several goals.

• Output tracking. The primary goal is that the output y should track, or follow,
a desired target or reference signal ydes. We measure output tracking error by
the quadratic function

Jtrack =
1

N + 1

N∑
t=0

(y(t)− ydes(t))2.

• Small input. The input should not be large. We measure the magnitude of the
input by the quadratic function

Jmag =
1

N + 1

N∑
t=0

u(t)2.

• Small input variations. The input should not vary rapidly. We measure the
magnitude of the input variations by the quadratic function

Jder =
1

N

N−1∑
t=0

(u(t+ 1)− u(t))2.

By minimizing a weighted sum

Jtrack + δJder + ηJmag,

where δ > 0 and η > 0, we can trade off the three objectives.

Now we consider a specific example, with N = 200, and impulse response

h(t) =
1

9
(0.9)t(1− 0.4 cos(2t)).

Figure 6.6 shows the optimal input, and corresponding output (along with the desired
trajectory ydes), for three values of the regularization parameters δ and η. The top
row shows the optimal input and corresponding output for δ = 0, η = 0.005. In this
case we have some regularization for the magnitude of the input, but no regularization
for its variation. While the tracking is good (i.e., we have Jtrack is small), the input
required is large, and rapidly varying. The second row corresponds to δ = 0, η = 0.05.
In this case we have more magnitude regularization, but still no regularization for
variation in u. The corresponding input is indeed smaller, at the cost of a larger
tracking error. The bottom row shows the results for δ = 0.3, η = 0.05. In this
case we have added some regularization for the variation. The input variation is
substantially reduced, with not much increase in output tracking error.

ℓ1-norm regularization

Regularization with an ℓ1-norm can be used as a heuristic for finding a sparse
solution. For example, consider the problem

minimize ‖Ax− b‖2 + γ‖x‖1, (6.11)



6.3 Regularized approximation 309

t

u
(t
)

0 50 100 150 200
−10

−5

0

5

t
y
(t
)

0 50 100 150 200
−1

−0.5

0

0.5

1

t

u
(t
)

0 50 100 150 200
−4

−2

0

2

4

t

y
(t
)

0 50 100 150 200
−1

−0.5

0

0.5

1

t

u
(t
)

0 50 100 150 200
−4

−2

0

2

4

t

y
(t
)

0 50 100 150 200
−1

−0.5

0

0.5

1

Figure 6.6 Optimal inputs (left) and resulting outputs (right) for three values
of the regularization parameters δ (which corresponds to input variation) and
η (which corresponds to input magnitude). The dashed line in the righthand
plots shows the desired output ydes. Top row: δ = 0, η = 0.005; middle row:
δ = 0, η = 0.05; bottom row: δ = 0.3, η = 0.05.



310 6 Approximation and fitting

in which the residual is measured with the Euclidean norm and the regularization is
done with an ℓ1-norm. By varying the parameter γ we can sweep out the optimal
trade-off curve between ‖Ax − b‖2 and ‖x‖1, which serves as an approximation
of the optimal trade-off curve between ‖Ax − b‖2 and the sparsity or cardinality
card(x) of the vector x, i.e., the number of nonzero elements. The problem (6.11)
can be recast and solved as an SOCP.

Example 6.4 Regressor selection problem. We are given a matrix A ∈ Rm×n,
whose columns are potential regressors, and a vector b ∈ Rm that is to be fit by a
linear combination of k < n columns of A. The problem is to choose the subset of k
regressors to be used, and the associated coefficients. We can express this problem
as

minimize ‖Ax− b‖2
subject to card(x) ≤ k.

In general, this is a hard combinatorial problem.

One straightforward approach is to check every possible sparsity pattern in x with k
nonzero entries. For a fixed sparsity pattern, we can find the optimal x by solving
a least-squares problem, i.e., minimizing ‖A˜x˜− b‖2, where A˜ denotes the submatrix
of A obtained by keeping the columns corresponding to the sparsity pattern, and
x˜ is the subvector with the nonzero components of x. This is done for each of the
n!/(k!(n− k)!) sparsity patterns with k nonzeros.
A good heuristic approach is to solve the problem (6.11) for different values of γ,
finding the smallest value of γ that results in a solution with card(x) = k. We then
fix this sparsity pattern and find the value of x that minimizes ‖Ax− b‖2.
Figure 6.7 illustrates a numerical example with A ∈ R10×20, x ∈ R20, b ∈ R10. The
circles on the dashed curve are the (globally) Pareto optimal values for the trade-off
between card(x) (vertical axis) and the residual ‖Ax − b‖2 (horizontal axis). For
each k, the Pareto optimal point was obtained by enumerating all possible sparsity
patterns with k nonzero entries, as described above. The circles on the solid curve
were obtained with the heuristic approach, by using the sparsity patterns of the
solutions of problem (6.11) for different values of γ. Note that for card(x) = 1, the
heuristic method actually finds the global optimum.

This idea will come up again in basis pursuit (§6.5.4).

6.3.3 Reconstruction, smoothing, and de-noising

In this section we describe an important special case of the bi-criterion approxi-
mation problem described above, and give some examples showing how different
regularization methods perform. In reconstruction problems, we start with a signal
represented by a vector x ∈ Rn. The coefficients xi correspond to the value of
some function of time, evaluated (or sampled, in the language of signal processing)
at evenly spaced points. It is usually assumed that the signal does not vary too
rapidly, which means that usually, we have xi ≈ xi+1. (In this section we consider
signals in one dimension, e.g., audio signals, but the same ideas can be applied to
signals in two or more dimensions, e.g., images or video.)



6.3 Regularized approximation 311

‖Ax− b‖2

c
a
r
d
(x
)

0 1 2 3 4
0

2

4

6

8

10

Figure 6.7 Sparse regressor selection with a matrix A ∈ R10×20. The circles
on the dashed line are the Pareto optimal values for the trade-off between
the residual ‖Ax − b‖2 and the number of nonzero elements card(x). The
points indicated by circles on the solid line are obtained via the ℓ1-norm
regularized heuristic.

The signal x is corrupted by an additive noise v:

xcor = x+ v.

The noise can be modeled in many different ways, but here we simply assume that
it is unknown, small, and, unlike the signal, rapidly varying. The goal is to form an
estimate xˆ of the original signal x, given the corrupted signal xcor. This process is
called signal reconstruction (since we are trying to reconstruct the original signal
from the corrupted version) or de-noising (since we are trying to remove the noise
from the corrupted signal). Most reconstruction methods end up performing some
sort of smoothing operation on xcor to produce xˆ, so the process is also called
smoothing.

One simple formulation of the reconstruction problem is the bi-criterion problem

minimize (w.r.t. R2+) (‖xˆ− xcor‖2, φ(xˆ)) , (6.12)

where xˆ is the variable and xcor is a problem parameter. The function φ : R
n → R

is convex, and is called the regularization function or smoothing objective. It is
meant to measure the roughness, or lack of smoothness, of the estimate xˆ. The
reconstruction problem (6.12) seeks signals that are close (in ℓ2-norm) to the cor-
rupted signal, and that are smooth, i.e., for which φ(xˆ) is small. The reconstruction
problem (6.12) is a convex bi-criterion problem. We can find the Pareto optimal
points by scalarization, and solving a (scalar) convex optimization problem.



312 6 Approximation and fitting

Quadratic smoothing

The simplest reconstruction method uses the quadratic smoothing function

φquad(x) =

n−1∑
i=1

(xi+1 − xi)2 = ‖Dx‖22,

where D ∈ R(n−1)×n is the bidiagonal matrix

D =


−1 1 0 · · · 0 0 0
0 −1 1 · · · 0 0 0
...

...
...

...
...

...
0 0 0 · · · −1 1 0
0 0 0 · · · 0 −1 1

 .

We can obtain the optimal trade-off between ‖xˆ−xcor‖2 and ‖Dxˆ‖2 by minimizing
‖xˆ− xcor‖22 + δ‖Dxˆ‖22,

where δ > 0 parametrizes the optimal trade-off curve. The solution of this quadratic
problem,

xˆ = (I + δDTD)−1xcor,

can be computed very efficiently since I + δDTD is tridiagonal; see appendix C.

Quadratic smoothing example

Figure 6.8 shows a signal x ∈ R4000 (top) and the corrupted signal xcor (bottom).
The optimal trade-off curve between the objectives ‖xˆ−xcor‖2 and ‖Dxˆ‖2 is shown
in figure 6.9. The extreme point on the left of the trade-off curve corresponds to
xˆ = xcor, and has objective value ‖Dxcor‖2 = 4.4. The extreme point on the right
corresponds to xˆ = 0, for which ‖xˆ− xcor‖2 = ‖xcor‖2 = 16.2. Note the clear knee
in the trade-off curve near ‖xˆ− xcor‖2 ≈ 3.

Figure 6.10 shows three smoothed signals on the optimal trade-off curve, cor-
responding to ‖xˆ − xcor‖2 = 8 (top), 3 (middle), and 1 (bottom). Comparing the
reconstructed signals with the original signal x, we see that the best reconstruction
is obtained for ‖xˆ − xcor‖2 = 3, which corresponds to the knee of the trade-off
curve. For higher values of ‖xˆ − xcor‖2, there is too much smoothing; for smaller
values there is too little smoothing.

Total variation reconstruction

Simple quadratic smoothing works well as a reconstruction method when the orig-
inal signal is very smooth, and the noise is rapidly varying. But any rapid varia-
tions in the original signal will, obviously, be attenuated or removed by quadratic
smoothing. In this section we describe a reconstruction method that can remove
much of the noise, while still preserving occasional rapid variations in the original
signal. The method is based on the smoothing function

φtv(xˆ) =

n−1∑
i=1

|xˆi+1 − xˆi| = ‖Dxˆ‖1,



6.3 Regularized approximation 313

i

x
x
c
o
r

0

0

1000

1000

2000

2000

3000

3000

4000

4000

−0.5

−0.5

0

0

0.5

0.5

Figure 6.8 Top: the original signal x ∈ R4000. Bottom: the corrupted signal
xcor.

‖xˆ− xcor‖2

‖D
xˆ
‖ 2

0 5 10 15 20
0

1

2

3

4

Figure 6.9 Optimal trade-off curve between ‖Dxˆ‖2 and ‖xˆ − xcor‖2. The
curve has a clear knee near ‖xˆ− xcor‖ ≈ 3.



314 6 Approximation and fitting

i

xˆ
xˆ

xˆ

0

0

0

1000

1000

1000

2000

2000

2000

3000

3000

3000

4000

4000

4000

−0.5

−0.5

−0.5

0

0

0

0.5

0.5

0.5

Figure 6.10 Three smoothed or reconstructed signals xˆ. The top one cor-
responds to ‖xˆ − xcor‖2 = 8, the middle one to ‖xˆ − xcor‖2 = 3, and the
bottom one to ‖xˆ− xcor‖2 = 1.

which is called the total variation of x ∈ Rn. Like the quadratic smoothness
measure φquad, the total variation function assigns large values to rapidly varying
xˆ. The total variation measure, however, assigns relatively less penalty to large
values of |xi+1 − xi|.

Total variation reconstruction example

Figure 6.11 shows a signal x ∈ R2000 (in the top plot), and the signal corrupted
with noise xcor. The signal is mostly smooth, but has several rapid variations or
jumps in value; the noise is rapidly varying.

We first use quadratic smoothing. Figure 6.12 shows three smoothed signals on
the optimal trade-off curve between ‖Dxˆ‖2 and ‖xˆ−xcor‖2. In the first two signals,
the rapid variations in the original signal are also smoothed. In the third signal
the steep edges in the signal are better preserved, but there is still a significant
amount of noise left.

Now we demonstrate total variation reconstruction. Figure 6.13 shows the
optimal trade-off curve between ‖Dxˆ‖1 and ‖xˆ−xcorr‖2. Figure 6.14 shows the re-
constructed signals on the optimal trade-off curve, for ‖Dxˆ‖1 = 5 (top), ‖Dxˆ‖1 = 8
(middle), and ‖Dxˆ‖1 = 10 (bottom). We observe that, unlike quadratic smoothing,
total variation reconstruction preserves the sharp transitions in the signal.



6.3 Regularized approximation 315

i

x
x
c
o
r

0

0

500

500

1000

1000

1500

1500

2000

2000

−2

−2

−1

−1

0

0

1

1

2

2

Figure 6.11 A signal x ∈ R2000, and the corrupted signal xcor ∈ R2000. The
noise is rapidly varying, and the signal is mostly smooth, with a few rapid
variations.



316 6 Approximation and fitting

i

xˆ
xˆ

xˆ

0

0

0

500

500

500

1000

1000

1000

1500

1500

1500

2000

2000

2000

−2

−2

−2

0

0

0

2

2

2

Figure 6.12 Three quadratically smoothed signals xˆ. The top one corre-
sponds to ‖xˆ − xcor‖2 = 10, the middle one to ‖xˆ − xcor‖2 = 7, and the
bottom one to ‖xˆ − xcor‖2 = 4. The top one greatly reduces the noise, but
also excessively smooths out the rapid variations in the signal. The bottom
smoothed signal does not give enough noise reduction, and still smooths out
the rapid variations in the original signal. The middle smoothed signal gives
the best compromise, but still smooths out the rapid variations.

‖xˆ− xcor‖2

‖D
xˆ
‖ 1

0 10 20 30 40 50
0

50

100

150

200

250

Figure 6.13 Optimal trade-off curve between ‖Dxˆ‖1 and ‖xˆ− xcor‖2.



6.3 Regularized approximation 317

i

xˆ
xˆ

xˆ

0

0

0

500

500

500

1000

1000

1000

1500

1500

1500

2000

2000

2000

−2

−2

−2

0

0

0

2

2

2

Figure 6.14 Three reconstructed signals xˆ, using total variation reconstruc-
tion. The top one corresponds to ‖Dxˆ‖1 = 5, the middle one to ‖Dxˆ‖1 = 8,
and the bottom one to ‖Dxˆ‖1 = 10. The bottom one does not give quite
enough noise reduction, while the top one eliminates some of the slowly vary-
ing parts of the signal. Note that in total variation reconstruction, unlike
quadratic smoothing, the sharp changes in the signal are preserved.



318 6 Approximation and fitting

6.4 Robust approximation

6.4.1 Stochastic robust approximation

We consider an approximation problem with basic objective ‖Ax−b‖, but also wish
to take into account some uncertainty or possible variation in the data matrix A.
(The same ideas can be extended to handle the case where there is uncertainty in
both A and b.) In this section we consider some statistical models for the variation
in A.

We assume that A is a random variable taking values in Rm×n, with mean A¯,
so we can describe A as

A = A¯+ U,

where U is a random matrix with zero mean. Here, the constant matrix A¯ gives
the average value of A, and U describes its statistical variation.

It is natural to use the expected value of ‖Ax− b‖ as the objective:

minimize E ‖Ax− b‖. (6.13)

We refer to this problem as the stochastic robust approximation problem. It is
always a convex optimization problem, but usually not tractable since in most
cases it is very difficult to evaluate the objective or its derivatives.

One simple case in which the stochastic robust approximation problem (6.13)
can be solved occurs when A assumes only a finite number of values, i.e.,

prob(A = Ai) = pi, i = 1, . . . , k,

where Ai ∈ Rm×n, 1T p = 1, p � 0. In this case the problem (6.13) has the form

minimize p1‖A1x− b‖+ · · ·+ pk‖Akx− b‖,

which is often called a sum-of-norms problem. It can be expressed as

minimize pT t
subject to ‖Aix− b‖ ≤ ti, i = 1, . . . , k,

where the variables are x ∈ Rn and t ∈ Rk. If the norm is the Euclidean norm,
this sum-of-norms problem is an SOCP. If the norm is the ℓ1- or ℓ∞-norm, the
sum-of-norms problem can be expressed as an LP; see exercise 6.8.

Some variations on the statistical robust approximation problem (6.13) are
tractable. As an example, consider the statistical robust least-squares problem

minimize E ‖Ax− b‖22,

where the norm is the Euclidean norm. We can express the objective as

E ‖Ax− b‖22 = E(A¯x− b+ Ux)T (A¯x− b+ Ux)
= (A¯x− b)T (A¯x− b) +ExTUTUx
= ‖A¯x− b‖22 + xTPx,



6.4 Robust approximation 319

where P = EUTU . Therefore the statistical robust approximation problem has
the form of a regularized least-squares problem

minimize ‖A¯x− b‖22 + ‖P 1/2x‖22,
with solution

x = (A¯T A¯+ P )−1A¯T b.

This makes perfect sense: when the matrix A is subject to variation, the vector
Ax will have more variation the larger x is, and Jensen’s inequality tells us that
variation in Ax will increase the average value of ‖Ax− b‖2. So we need to balance
making A¯x − b small with the desire for a small x (to keep the variation in Ax
small), which is the essential idea of regularization.

This observation gives us another interpretation of the Tikhonov regularized
least-squares problem (6.10), as a robust least-squares problem, taking into account
possible variation in the matrix A. The solution of the Tikhonov regularized least-
squares problem (6.10) minimizes E ‖(A + U)x − b‖2, where Uij are zero mean,
uncorrelated random variables, with variance δ/m (and here, A is deterministic).

6.4.2 Worst-case robust approximation

It is also possible to model the variation in the matrix A using a set-based, worst-
case approach. We describe the uncertainty by a set of possible values for A:

A ∈ A ⊆ Rm×n,
which we assume is nonempty and bounded. We define the associated worst-case
error of a candidate approximate solution x ∈ Rn as

ewc(x) = sup{‖Ax− b‖ | A ∈ A},
which is always a convex function of x. The (worst-case) robust approximation
problem is to minimize the worst-case error:

minimize ewc(x) = sup{‖Ax− b‖ | A ∈ A}, (6.14)
where the variable is x, and the problem data are b and the set A. When A is the
singleton A = {A}, the robust approximation problem (6.14) reduces to the basic
norm approximation problem (6.1). The robust approximation problem is always
a convex optimization problem, but its tractability depends on the norm used and
the description of the uncertainty set A.

Example 6.5 Comparison of stochastic and worst-case robust approximation. To
illustrate the difference between the stochastic and worst-case formulations of the
robust approximation problem, we consider the least-squares problem

minimize ‖A(u)x− b‖22,
where u ∈ R is an uncertain parameter and A(u) = A0 + uA1. We consider a
specific instance of the problem, with A(u) ∈ R20×10, ‖A0‖ = 10, ‖A1‖ = 1, and u



320 6 Approximation and fitting

u

r(
u
)

xnom

xstoch

xwc

−2 −1 0 1 20

2

4

6

8

10

12

Figure 6.15 The residual r(u) = ‖A(u)x − b‖2 as a function of the un-
certain parameter u for three approximate solutions x: (1) the nominal
least-squares solution xnom; (2) the solution of the stochastic robust approx-
imation problem xstoch (assuming u is uniformly distributed on [−1, 1]); and
(3) the solution of the worst-case robust approximation problem xwc, as-
suming the parameter u lies in the interval [−1, 1]. The nominal solution
achieves the smallest residual when u = 0, but gives much larger residuals
as u approaches −1 or 1. The worst-case solution has a larger residual when
u = 0, but its residuals do not rise much as the parameter u varies over the
interval [−1, 1].

in the interval [−1, 1]. (So, roughly speaking, the variation in the matrix A is around
±10%.)
We find three approximate solutions:

• Nominal optimal. The optimal solution xnom is found, assuming A(u) has its
nominal value A0.

• Stochastic robust approximation. We find xstoch, which minimizes E ‖A(u)x −
b‖22, assuming the parameter u is uniformly distributed on [−1, 1].

• Worst-case robust approximation. We find xwc, which minimizes

sup
−1≤u≤1

‖A(u)x− b‖2 = max{‖(A0 −A1)x− b‖2, ‖(A0 +A1)x− b‖2}.

For each of these three values of x, we plot the residual r(u) = ‖A(u)x − b‖2 as a
function of the uncertain parameter u, in figure 6.15. These plots show how sensitive
an approximate solution can be to variation in the parameter u. The nominal solu-
tion achieves the smallest residual when u = 0, but is quite sensitive to parameter
variation: it gives much larger residuals as u deviates from 0, and approaches −1 or
1. The worst-case solution has a larger residual when u = 0, but its residuals do not
rise much as u varies over the interval [−1, 1]. The stochastic robust approximate
solution is in between.



6.4 Robust approximation 321

The robust approximation problem (6.14) arises in many contexts and applica-
tions. In an estimation setting, the set A gives our uncertainty in the linear relation
between the vector to be estimated and our measurement vector. Sometimes the
noise term v in the model y = Ax + v is called additive noise or additive error,
since it is added to the ‘ideal’ measurement Ax. In contrast, the variation in A is
called multiplicative error, since it multiplies the variable x.

In an optimal design setting, the variation can represent uncertainty (arising in
manufacture, say) of the linear equations that relate the design variables x to the
results vector Ax. The robust approximation problem (6.14) is then interpreted as
the robust design problem: find design variables x that minimize the worst possible
mismatch between Ax and b, over all possible values of A.

Finite set

Here we have A = {A1, . . . , Ak}, and the robust approximation problem is
minimize maxi=1,...,k ‖Aix− b‖.

This problem is equivalent to the robust approximation problem with the polyhe-
dral set A = conv{A1, . . . , Ak}:

minimize sup {‖Ax− b‖ | A ∈ conv{A1, . . . , Ak}} .
We can cast the problem in epigraph form as

minimize t
subject to ‖Aix− b‖ ≤ t, i = 1, . . . , k,

which can be solved in a variety of ways, depending on the norm used. If the norm
is the Euclidean norm, this is an SOCP. If the norm is the ℓ1- or ℓ∞-norm, we can
express it as an LP.

Norm bound error

Here the uncertainty set A is a norm ball, A = {A¯+U | ‖U‖ ≤ a}, where ‖ · ‖ is a
norm on Rm×n. In this case we have

ewc(x) = sup{‖A¯x− b+ Ux‖ | ‖U‖ ≤ a},
which must be carefully interpreted since the first norm appearing is on Rm (and
is used to measure the size of the residual) and the second one appearing is on
Rm×n (used to define the norm ball A).

This expression for ewc(x) can be simplified in several cases. As an example,
let us take the Euclidean norm on Rn and the associated induced norm on Rm×n,
i.e., the maximum singular value. If A¯x − b 6= 0 and x 6= 0, the supremum in the
expression for ewc(x) is attained for U = auv

T , with

u =
A¯x− b

‖A¯x− b‖2 , v =
x

‖x‖2 ,

and the resulting worst-case error is

ewc(x) = ‖A¯x− b‖2 + a‖x‖2.



322 6 Approximation and fitting

(It is easily verified that this expression is also valid if x or A¯x − b is zero.) The
robust approximation problem (6.14) then becomes

minimize ‖A¯x− b‖2 + a‖x‖2,
which is a regularized norm problem, solvable as the SOCP

minimize t1 + at2
subject to ‖A¯x− b‖2 ≤ t1, ‖x‖2 ≤ t2.

Since the solution of this problem is the same as the solution of the regularized
least-squares problem

minimize ‖A¯x− b‖22 + δ‖x‖22
for some value of the regularization parameter δ, we have another interpretation of
the regularized least-squares problem as a worst-case robust approximation prob-
lem.

Uncertainty ellipsoids

We can also describe the variation in A by giving an ellipsoid of possible values for
each row:

A = {[a1 · · · am]T | ai ∈ Ei, i = 1, . . . ,m},
where

Ei = {a¯i + Piu | ‖u‖2 ≤ 1}.
The matrix Pi ∈ Rn×n describes the variation in ai. We allow Pi to have a nontriv-
ial nullspace, in order to model the situation when the variation in ai is restricted
to a subspace. As an extreme case, we take Pi = 0 if there is no uncertainty in ai.

With this ellipsoidal uncertainty description, we can give an explicit expression
for the worst-case magnitude of each residual:

sup
ai∈Ei

|aTi x− bi| = sup{|a¯Ti x− bi + (Piu)Tx| | ‖u‖2 ≤ 1}

= |a¯Ti x− bi|+ ‖PTi x‖2.
Using this result we can solve several robust approximation problems. For

example, the robust ℓ2-norm approximation problem

minimize ewc(x) = sup{‖Ax− b‖2 | ai ∈ Ei, i = 1, . . . ,m}
can be reduced to an SOCP, as follows. An explicit expression for the worst-case
error is given by

ewc(x) =

(
m∑
i=1

(
sup
ai∈Ei

|aTi x− bi|
)2)1/2

=

(
m∑
i=1

(|a¯Ti x− bi|+ ‖PTi x‖2)2
)1/2

.

To minimize ewc(x) we can solve

minimize ‖t‖2
subject to |a¯Ti x− bi|+ ‖PTi x‖2 ≤ ti, i = 1, . . . ,m,



6.4 Robust approximation 323

where we introduced new variables t1, . . . , tm. This problem can be formulated as

minimize ‖t‖2
subject to a¯Ti x− bi + ‖PTi x‖2 ≤ ti, i = 1, . . . ,m

−a¯Ti x+ bi + ‖PTi x‖2 ≤ ti, i = 1, . . . ,m,
which becomes an SOCP when put in epigraph form.

Norm bounded error with linear structure

As a generalization of the norm bound description A = {A¯+U | ‖U‖ ≤ a}, we can
define A as the image of a norm ball under an affine transformation:

A = {A¯+ u1A1 + u2A2 + · · ·+ upAp | ‖u‖ ≤ 1},

where ‖ · ‖ is a norm on Rp, and the p + 1 matrices A¯, A1, . . . , Ap ∈ Rm×n are
given. The worst-case error can be expressed as

ewc(x) = sup
‖u‖≤1

‖(A¯+ u1A1 + · · ·+ upAp)x− b‖

= sup
‖u‖≤1

‖P (x)u+ q(x)‖,

where P and q are defined as

P (x) =
[
A1x A2x · · · Apx

] ∈ Rm×p, q(x) = A¯x− b ∈ Rm.
As a first example, we consider the robust Chebyshev approximation problem

minimize ewc(x) = sup‖u‖∞≤1 ‖(A¯+ u1A1 + · · ·+ upAp)x− b‖∞.

In this case we can derive an explicit expression for the worst-case error. Let pi(x)
T

denote the ith row of P (x). We have

ewc(x) = sup
‖u‖∞≤1

‖P (x)u+ q(x)‖∞

= max
i=1,...,m

sup
‖u‖∞≤1

|pi(x)Tu+ qi(x)|

= max
i=1,...,m

(‖pi(x)‖1 + |qi(x)|).

The robust Chebyshev approximation problem can therefore be cast as an LP

minimize t
subject to −y0 � A¯x− b � y0

−yk � Akx � yk, k = 1, . . . , p
y0 +

∑p
k=1 yk � t1,

with variables x ∈ Rn, yk ∈ Rm, t ∈ R.
As another example, we consider the robust least-squares problem

minimize ewc(x) = sup‖u‖2≤1 ‖(A¯+ u1A1 + · · ·+ upAp)x− b‖2.



324 6 Approximation and fitting

Here we use Lagrange duality to evaluate ewc. The worst-case error ewc(x) is the
squareroot of the optimal value of the (nonconvex) quadratic optimization problem

maximize ‖P (x)u+ q(x)‖22
subject to uTu ≤ 1,

with u as variable. The Lagrange dual of this problem can be expressed as the
SDP

minimize t+ λ

subject to

 I P (x) q(x)P (x)T λI 0
q(x)T 0 t

 � 0 (6.15)
with variables t, λ ∈ R. Moreover, as mentioned in §5.2 and §B.1 (and proved
in §B.4), strong duality holds for this pair of primal and dual problems. In other
words, for fixed x, we can compute ewc(x)

2 by solving the SDP (6.15) with variables
t and λ. Optimizing jointly over t, λ, and x is equivalent to minimizing ewc(x)

2.
We conclude that the robust least-squares problem is equivalent to the SDP (6.15)
with x, λ, t as variables.

Example 6.6 Comparison of worst-case robust, Tikhonov regularized, and nominal
least-squares solutions. We consider an instance of the robust approximation problem

minimize sup‖u‖2≤1 ‖(A¯+ u1A1 + u2A2)x− b‖2, (6.16)
with dimensions m = 50, n = 20. The matrix A¯ has norm 10, and the two matrices
A1 and A2 have norm 1, so the variation in the matrix A is, roughly speaking, around
10%. The uncertainty parameters u1 and u2 lie in the unit disk in R

2.

We compute the optimal solution of the robust least-squares problem (6.16) xrls, as
well as the solution of the nominal least-squares problem xls (i.e., assuming u = 0),
and also the Tikhonov regularized solution xtik, with δ = 1.

To illustrate the sensitivity of each of these approximate solutions to the parameter
u, we generate 105 parameter vectors, uniformly distributed on the unit disk, and
evaluate the residual

‖(A0 + u1A1 + u2A2)x− b‖2
for each parameter value. The distributions of the residuals are shown in figure 6.16.

We can make several observations. First, the residuals of the nominal least-squares
solution are widely spread, from a smallest value around 0.52 to a largest value
around 4.9. In particular, the least-squares solution is very sensitive to parameter
variation. In contrast, both the robust least-squares and Tikhonov regularized so-
lutions exhibit far smaller variation in residual as the uncertainty parameter varies
over the unit disk. The robust least-squares solution, for example, achieves a residual
between 2.0 and 2.6 for all parameters in the unit disk.

6.5 Function fitting and interpolation

In function fitting problems, we select a member of a finite-dimensional subspace
of functions that best fits some given data or requirements. For simplicity we



6.5 Function fitting and interpolation 325

‖(A0 + u1A1 + u2A2)x− b‖2

xls

xtik

xrls

fr
eq
u
en
cy

0 1 2 3 4 5
0

0.05

0.1

0.15

0.2

0.25

Figure 6.16 Distribution of the residuals for the three solutions of a least-
squares problem (6.16): xls, the least-squares solution assuming u = 0; xtik,
the Tikhonov regularized solution with δ = 1; and xrls, the robust least-
squares solution. The histograms were obtained by generating 105 values of
the uncertain parameter vector u from a uniform distribution on the unit
disk in R2. The bins have width 0.1.



326 6 Approximation and fitting

consider real-valued functions; the ideas are readily extended to handle vector-
valued functions as well.

6.5.1 Function families

We consider a family of functions f1, . . . , fn : R
k → R, with common domain

dom fi = D. With each x ∈ Rn we associate the function f : Rk → R given by
f(u) = x1f1(u) + · · ·+ xnfn(u) (6.17)

with dom f = D. The family {f1, . . . , fn} is sometimes called the set of basis
functions (for the fitting problem) even when the functions are not independent.
The vector x ∈ Rn, which parametrizes the subspace of functions, is our optimiza-
tion variable, and is sometimes called the coefficient vector. The basis functions
generate a subspace F of functions on D.

In many applications the basis functions are specially chosen, using prior knowl-
edge or experience, in order to reasonably model functions of interest with the
finite-dimensional subspace of functions. In other cases, more generic function
families are used. We describe a few of these below.

Polynomials

One common subspace of functions on R consists of polynomials of degree less
than n. The simplest basis consists of the powers, i.e., fi(t) = t

i−1, i = 1, . . . , n.
In many applications, the same subspace is described using a different basis, for
example, a set of polynomials f1, . . . , fn, of degree less than n, that are orthonormal
with respect to some positive function (or measure) φ : Rn → R+, i.e.,∫

fi(t)fj(t)φ(t) dt =

{
1 i = j
0 i 6= j.

Another common basis for polynomials is the Lagrange basis f1, . . . , fn associated
with distinct points t1, . . . , tn, which satisfy

fi(tj) =

{
1 i = j
0 i 6= j.

We can also consider polynomials on Rk, with a maximum total degree, or a
maximum degree for each variable.

As a related example, we have trigonometric polynomials of degree less than n,
with basis

sin kt, k = 1, . . . , n− 1, cos kt, k = 0, . . . , n− 1.

Piecewise-linear functions

We start with a triangularization of the domain D, which means the following. We
have a set of mesh or grid points g1, . . . , gn ∈ Rk, and a partition of D into a set
of simplexes:

D = S1 ∪ · · · ∪ Sm, int(Si ∩ Sj) = ∅ for i 6= j.



6.5 Function fitting and interpolation 327

u1

0

10 1

0

1

u2

f
(u

1
,u

2
)

Figure 6.17 A piecewise-linear function of two variables, on the unit square.
The triangulation consists of 98 simplexes, and a uniform grid of 64 points
in the unit square.

Each simplex is the convex hull of k+ 1 grid points, and we require that each grid
point is a vertex of any simplex it lies in.

Given a triangularization, we can construct a piecewise-linear (or more precisely,
piecewise-affine) function f by assigning function values f(gi) = xi to the grid
points, and then extending the function affinely on each simplex. The function f
can be expressed as (6.17) where the basis functions fi are affine on each simplex
and are defined by the conditions

fi(gj) =

{
1 i = j
0 i 6= j.

By construction, such a function is continuous.

Figure 6.17 shows an example for k = 2.

Piecewise polynomials and splines

The idea of piecewise-affine functions on a triangulated domain is readily extended
to piecewise polynomials and other functions.

Piecewise polynomials are defined as polynomials (of some maximum degree)
on each simplex of the triangulation, which are continuous, i.e., the polynomials
agree at the boundaries between simplexes. By further restricting the piecewise
polynomials to have continuous derivatives up to a certain order, we can define
various classes of spline functions. Figure 6.18 shows an example of a cubic spline,
i.e., a piecewise polynomial of degree 3 on R, with continuous first and second
derivatives.



328 6 Approximation and fitting

u0 u1 u2 u3

f
(u
)

u

p1(u)

p2(u) p3(u)

Figure 6.18 Cubic spline. A cubic spline is a piecewise polynomial, with
continuous first and second derivatives. In this example, the cubic spline f
is formed from the three cubic polynomials p1 (on [u0, u1]), p2 (on [u1, u2]),
and p3 (on [u2, u3]). Adjacent polynomials have the same function value,
and equal first and second derivatives, at the boundary points u1 and u2.
In this example, the dimension of the family of functions is n = 6, since
we have 12 polynomial coefficients (4 per cubic polynomial), and 6 equality
constraints (3 each at u1 and u2).



6.5 Function fitting and interpolation 329

6.5.2 Constraints

In this section we describe some constraints that can be imposed on the function
f , and therefore, on the variable x ∈ Rn.

Function value interpolation and inequalities

Let v be a point in D. The value of f at v,

f(v) =

n∑
i=1

xifi(v),

is a linear function of x. Therefore interpolation conditions

f(vj) = zj , j = 1, . . . ,m,

which require the function f to have the values zj ∈ R at specified points vj ∈ D,
form a set of linear equalities in x. More generally, inequalities on the function
value at a given point, as in l ≤ f(v) ≤ u, are linear inequalities on the variable x.
There are many other interesting convex constraints on f (hence, x) that involve
the function values at a finite set of points v1, . . . , vN . For example, the Lipschitz
constraint

|f(vj)− f(vk)| ≤ L‖vj − vk‖, j, k = 1, . . . ,m,
forms a set of linear inequalities in x.

We can also impose inequalities on the function values at an infinite number of
points. As an example, consider the nonnegativity constraint

f(u) ≥ 0 for all u ∈ D.

This is a convex constraint on x (since it is the intersection of an infinite number
of halfspaces), but may not lead to a tractable problem except in special cases
that exploit the particular structure of the functions. One simple example occurs
when the functions are piecewise-linear. In this case, if the function values are
nonnegative at the grid points, the function is nonnegative everywhere, so we obtain
a simple (finite) set of linear inequalities.

As a less trivial example, consider the case when the functions are polynomials
on R, with even maximum degree 2k (i.e., n = 2k + 1), and D = R. As shown in
exercise 2.37, page 65, the nonnegativity constraint

p(u) = x1 + x2u+ · · ·+ x2k+1u2k ≥ 0 for all u ∈ R,

is equivalent to

xi =
∑

m+n=i+1

Ymn, i = 1, . . . , 2k + 1, Y � 0,

where Y ∈ Sk+1 is an auxiliary variable.



330 6 Approximation and fitting

Derivative constraints

Suppose the basis functions fi are differentiable at a point v ∈ D. The gradient

∇f(v) =
n∑
i=1

xi∇fi(v),

is a linear function of x, so interpolation conditions on the derivative of f at v
reduce to linear equality constraints on x. Requiring that the norm of the gradient
at v not exceed a given limit,

‖∇f(v)‖ =
∥∥∥∥∥

n∑
i=1

xi∇fi(v)
∥∥∥∥∥ ≤M,

is a convex constraint on x. The same idea extends to higher derivatives. For
example, if f is twice differentiable at v, the requirement that

lI � ∇2f(v) � uI

is a linear matrix inequality in x, hence convex.
We can also impose constraints on the derivatives at an infinite number of

points. For example, we can require that f is monotone:

f(u) ≥ f(v) for all u, v ∈ D, u � v.

This is a convex constraint in x, but may not lead to a tractable problem except in
special cases. When f is piecewise affine, for example, the monotonicity constraint
is equivalent to the condition ∇f(v) � 0 inside each of the simplexes. Since the
gradient is a linear function of the grid point values, this leads to a simple (finite)
set of linear inequalities.

As another example, we can require that the function be convex, i.e., satisfy

f((u+ v)/2) ≤ (f(u) + f(v))/2 for all u, v ∈ D

(which is enough to ensure convexity when f is continuous). This is a convex con-
straint, which has a tractable representation in some cases. One obvious example
is when f is quadratic, in which case the convexity constraint reduces to the re-
quirement that the quadratic part of f be nonnegative, which is an LMI. Another
example in which a convexity constraint leads to a tractable problem is described
in more detail in §6.5.5.

Integral constraints

Any linear functional L on the subspace of functions can be expressed as a linear
function of x, i.e., we have L(f) = cTx. Evaluation of f (or a derivative) at a point
is just a special case. As another example, the linear functional

L(f) =
∫
D

φ(u)f(u) du,



6.5 Function fitting and interpolation 331

where φ : Rk → R, can be expressed as L(f) = cTx, where

ci =

∫
D

φ(u)fi(u) du.

Thus, a constraint of the form L(f) = a is a linear equality constraint on x. One
example of such a constraint is the moment constraint∫

D

tmf(t) dt = a

(where f : R→ R).

6.5.3 Fitting and interpolation problems

Minimum norm function fitting

In a fitting problem, we are given data

(u1, y1), . . . , (um, ym)

with ui ∈ D and yi ∈ R, and seek a function f ∈ F that matches this data as
closely as possible. For example in least-squares fitting we consider the problem

minimize
∑m

i=1(f(ui)− yi)2,

which is a simple least-squares problem in the variable x. We can add a variety of
constraints, for example linear inequalities that must be satisfied by f at various
points, constraints on the derivatives of f , monotonicity constraints, or moment
constraints.

Example 6.7 Polynomial fitting. We are given data u1, . . . , um ∈ R and v1, . . . , vm ∈
R, and hope to approximately fit a polynomial of the form

p(u) = x1 + x2u+ · · ·+ xnun−1

to the data. For each x we form the vector of errors,

e = (p(u1)− v1, . . . , p(um)− vm) .

To find the polynomial that minimizes the norm of the error, we solve the norm
approximation problem

minimize ‖e‖ = ‖Ax− v‖

with variable x ∈ Rn, where Aij = uj−1i , i = 1, . . . ,m, j = 1, . . . , n.
Figure 6.19 shows an example with m = 40 data points and n = 6 (i.e., polynomials
of maximum degree 5), for the ℓ2- and ℓ∞-norms.



332 6 Approximation and fitting

u

p
(u
)

−1 −0.5 0 0.5 1−0.1

0

0.1

0.2

Figure 6.19 Two polynomials of degree 5 that approximate the 40 data
points shown as circles. The polynomial shown as a solid line minimizes the
ℓ2-norm of the error; the polynomial shown as a dashed line minimizes the
ℓ∞-norm.

u

f
(u
)

−1 −0.5 0 0.5 1−0.1

0

0.1

0.2

Figure 6.20 Two cubic splines that approximate the 40 data points shown as
circles (which are the same as the data in figure 6.19). The spline shown as
a solid line minimizes the ℓ2-norm of the error; the spline shown as a dashed
line minimizes the ℓ∞-norm. As in the polynomial approximation shown in
figure 6.19, the dimension of the subspace of fitting functions is 6.



6.5 Function fitting and interpolation 333

Example 6.8 Spline fitting. Figure 6.20 shows the same data as in example 6.7,
and two optimal fits with cubic splines. The interval [−1, 1] is divided into three
equal intervals, and we consider piecewise polynomials, with maximum degree 3, with
continuous first and second derivatives. The dimension of this subspace of functions
is 6, the same as the dimension of polynomials with maximum degree 5, considered
in example 6.7.

In the simplest forms of function fitting, we have m ≫ n, i.e., the number
of data points is much larger than the dimension of the subspace of functions.
Smoothing is accomplished automatically, since all members of the subspace are
smooth.

Least-norm interpolation

In another variation of function fitting, we have fewer data points than the dimen-
sion of the subspace of functions. In the simplest case, we require that the function
we choose must satisfy the interpolation conditions

f(ui) = yi, i = 1, . . . ,m,

which are linear equality constraints on x. Among the functions that satisfy these
interpolation conditions, we might seek one that is smoothest, or smallest. These
lead to least-norm problems.

In the most general function fitting problem, we can optimize an objective
(such as some measure of the error e), subject to a variety of convex constraints
that represent our prior knowledge of the underlying function.

Interpolation, extrapolation, and bounding

By evaluating the optimal function fit fˆ at a point v not in the original data set,
we obtain a guess of what the value of the underlying function is, at the point v.
This is called interpolation when v is between or near the given data points (e.g.,
v ∈ conv{v1, . . . , vm}), and extrapolation otherwise.

We can also produce an interval in which the value f(v) can lie, by maximizing
and minimizing (the linear function) f(v), subject to the constraints. We can use
the function fit to help identify faulty data or outliers. Here we might use, for
example, an ℓ1-norm fit, and look for data points with large errors.

6.5.4 Sparse descriptions and basis pursuit

In basis pursuit, there is a very large number of basis functions, and the goal is to
find a good fit of the given data as a linear combination of a small number of the
basis functions. (In this context the function family is linearly dependent, and is
sometimes referred to as an over-complete basis or dictionary.) This is called basis
pursuit since we are selecting a much smaller basis, from the given over-complete
basis, to model the data.



334 6 Approximation and fitting

Thus we seek a function f ∈ F that fits the data well,
f(ui) ≈ yi, i = 1, . . . ,m,

with a sparse coefficient vector x, i.e., card(x) small. In this case we refer to

f = x1f1 + · · ·+ xnfn =
∑
i∈B

xifi,

where B = {i | xi 6= 0} is the set of indices of the chosen basis elements, as a sparse
description of the data. Mathematically, basis pursuit is the same as the regressor
selection problem (see §6.4), but the interpretation (and scale) of the optimization
problem are different.

Sparse descriptions and basis pursuit have many uses. They can be used for
de-noising or smoothing, or data compression for efficient transmission or storage
of a signal. In data compression, the sender and receiver both know the dictionary,
or basis elements. To send a signal to the receiver, the sender first finds a sparse
representation of the signal, and then sends to the receiver only the nonzero coef-
ficients (to some precision). Using these coefficients, the receiver can reconstruct
(an approximation of) the original signal.

One common approach to basis pursuit is the same as the method for regressor
selection described in §6.4, and based on ℓ1-norm regularization as a heuristic for
finding sparse descriptions. We first solve the convex problem

minimize
∑m

i=1(f(ui)− yi)2 + γ‖x‖1, (6.18)
where γ > 0 is a parameter used to trade off the quality of the fit to the data,
and the sparsity of the coefficient vector. The solution of this problem can be used
directly, or followed by a refinement step, in which the best fit is found, using the
sparsity pattern of the solution of (6.18). In other words, we first solve (6.18), to
obtain xˆ. We then set B = {i | xˆi 6= 0}, i.e., the set of indices corresponding to
nonzero coefficients. Then we solve the least-squares problem

minimize
∑m

i=1(f(ui)− yi)2

with variables xi, i ∈ B, and xi = 0 for i 6∈ B.
In basis pursuit and sparse description applications it is not uncommon to have

a very large dictionary, with n on the order of 104 or much more. To be effective,
algorithms for solving (6.18) must exploit problem structure, which derives from
the structure of the dictionary signals.

Time-frequency analysis via basis pursuit

In this section we illustrate basis pursuit and sparse representation with a simple
example. We consider functions (or signals) on R, with the range of interest [0, 1].
We think of the independent variable as time, so we use t (instead of u) to denote
it.

We first describe the basis functions in the dictionary. Each basis function is a
Gaussian sinusoidal pulse, or Gabor function, with form

e−(t−τ)
2/σ2 cos(ωt+ φ),



6.5 Function fitting and interpolation 335

t

f 0
.5
,0
,c

f 0
.5
,7
5
,c

f 0
.5
,1
5
0
,c

0

0

0

0.2

0.2

0.2

0.4

0.4

0.4

0.6

0.6

0.6

0.8

0.8

0.8

1

1

1
−1

0

1

−1

0

1

−1

0

1

Figure 6.21 Three of the basis elements in the dictionary, all with center time
τ = 0.5 and cosine phase. The top signal has frequency ω = 0, the middle
one has frequency ω = 75, and the bottom one has frequency ω = 150.

where σ > 0 gives the width of the pulse, τ is the time of (the center of) the pulse,
ω ≥ 0 is the frequency, and φ is the phase angle. All of the basis functions have
width σ = 0.05. The pulse times and frequencies are

τ = 0.002k, k = 0, . . . , 500, ω = 5k, k = 0, . . . , 30.

For each time τ , there is one basis element with frequency zero (and phase φ = 0),
and 2 basis elements (cosine and sine, i.e., phase φ = 0 and φ = π/2) for each of 30
remaining frequencies, so all together there are 501 × 61 = 30561 basis elements.
The basis elements are naturally indexed by time, frequency, and phase (cosine or
sine), so we denote them as

fτ,ω,c, τ = 0, 0.002, . . . , 1, ω = 0, 5, . . . , 150,
fτ,ω,s, τ = 0, 0.002, . . . , 1, ω = 5, . . . , 150.

Three of these basis functions (all with time τ = 0.5) are shown in figure 6.21.
Basis pursuit with this dictionary can be thought of as a time-frequency analysis

of the data. If a basis element fτ,ω,c or fτ,ω,s appears in the sparse representation
of a signal (i.e., with a nonzero coefficient), we can interpret this as meaning that
the data contains the frequency ω at time τ .

We will use basis pursuit to find a sparse approximation of the signal

y(t) = a(t) sin θ(t)



336 6 Approximation and fitting

t

t

yˆ
(t
),
y
(t
)

y
(t
)
−
yˆ
(t
)

0

0

0.2

0.2

0.4

0.4

0.6

0.6

0.8

0.8

1

1
−1.5

−0.5

0.5

1.5

−0.05

0

0.05

Figure 6.22 Top. The original signal (solid line) and approximation yˆ ob-
tained by basis pursuit (dashed line) are almost indistinguishable. Bottom.
The approximation error y(t)− yˆ(t), with different vertical scale.

where

a(t) = 1 + 0.5 sin(11t), θ(t) = 30 sin(5t).

(This signal is chosen only because it is simple to describe, and exhibits noticeable
changes in its spectral content over time.) We can interpret a(t) as the signal
amplitude, and θ(t) as its total phase. We can also interpret

ω(t) =

∣∣∣∣dθdt
∣∣∣∣ = 150| cos(5t)|

as the instantaneous frequency of the signal at time t. The data are given as 501
uniformly spaced samples over the interval [0, 1], i.e., we are given 501 pairs (tk, yk)
with

tk = 0.005k, yk = y(tk), k = 0, . . . , 500.

We first solve the ℓ1-norm regularized least-squares problem (6.18), with γ =
1. The resulting optimal coefficient vector is very sparse, with only 42 nonzero
coefficients out of 30561. We then find the least-squares fit of the original signal
using these 42 basis vectors. The result yˆ is compared with the original signal
y in figure 6.22. The top figure shows the approximated signal (in dashed line)
and, almost indistinguishable, the original signal y(t) (in solid line). The bottom
figure shows the error y(t)− yˆ(t). As is clear from the figure, we have obtained an



6.5 Function fitting and interpolation 337

y
(t
)

t

ω
(t
)

τ
0

0

0.2

0.2

0.4

0.4

0.6

0.6

0.8

0.8

1

1
−1.5

−0.5

0.5

1.5

0

50

100

150

Figure 6.23 Top: Original signal. Bottom: Time-frequency plot. The dashed
curve shows the instantaneous frequency ω(t) = 150| cos(5t)| of the original
signal. Each circle corresponds to a chosen basis element in the approxima-
tion obtained by basis pursuit. The horizontal axis shows the time index τ ,
and the vertical axis shows the frequency index ω of the basis element.

approximation yˆ with a very good relative fit. The relative error is

(1/501)
∑501

i=1(y(ti)− yˆ(ti))2
(1/501)

∑501
i=1 y(ti)

2
= 2.6 · 10−4.

By plotting the pattern of nonzero coefficients versus time and frequency, we
obtain a time-frequency analysis of the original data. Such a plot is shown in fig-
ure 6.23, along with the instantaneous frequency. The plot shows that the nonzero
components closely track the instantaneous frequency.

6.5.5 Interpolation with convex functions

In some special cases we can solve interpolation problems involving an infinite-
dimensional set of functions, using finite-dimensional convex optimization. In this
section we describe an example.

We start with the following question: When does there exist a convex function
f : Rk → R, with dom f = Rk, that satisfies the interpolation conditions

f(ui) = yi, i = 1, . . . ,m,



338 6 Approximation and fitting

at given points ui ∈ Rk? (Here we do not restrict f to lie in any finite-dimensional
subspace of functions.) The answer is: if and only if there exist g1, . . . , gm such
that

yj ≥ yi + gTi (uj − ui), i, j = 1, . . . ,m. (6.19)
To see this, first suppose that f is convex, dom f = Rk, and f(ui) = yi,

i = 1, . . . ,m. At each ui we can find a vector gi such that

f(z) ≥ f(ui) + gTi (z − ui) (6.20)
for all z. If f is differentiable, we can take gi = ∇f(ui); in the more general case,
we can construct gi by finding a supporting hyperplane to epi f at (ui, yi). (The
vectors gi are called subgradients.) By applying (6.20) to z = uj , we obtain (6.19).

Conversely, suppose g1, . . . , gm satisfy (6.19). Define f as

f(z) = max
i=1,...,m

(yi + g
T
i (z − ui))

for all z ∈ Rk. Clearly, f is a (piecewise-linear) convex function. The inequali-
ties (6.19) imply that f(ui) = yi, for i = 1, . . . ,m.

We can use this result to solve several problems involving interpolation, approx-
imation, or bounding, with convex functions.

Fitting a convex function to given data

Perhaps the simplest application is to compute the least-squares fit of a convex
function to given data (ui, yi), i = 1, . . . ,m:

minimize
∑m

i=1(yi − f(ui))2
subject to f : Rk → R is convex, dom f = Rk.

This is an infinite-dimensional problem, since the variable is f , which is in the
space of continuous real-valued functions on Rk. Using the result above, we can
formulate this problem as

minimize
∑m

i=1(yi − yˆi)2
subject to yˆj ≥ yˆi + gTi (uj − ui), i, j = 1, . . . ,m,

which is a QP with variables yˆ ∈ Rm and g1, . . . , gm ∈ Rk. The optimal value of
this problem is zero if and only if the given data can be interpolated by a convex
function, i.e., if there is a convex function that satisfies f(ui) = yi. An example is
shown in figure 6.24.

Bounding values of an interpolating convex function

As another simple example, suppose that we are given data (ui, yi), i = 1, . . . ,m,
which can be interpolated by a convex function. We would like to determine the
range of possible values of f(u0), where u0 is another point in R

k, and f is any
convex function that interpolates the given data. To find the smallest possible
value of f(u0) we solve the LP

minimize y0
subject to yj ≥ yi + gTi (uj − ui), i, j = 0, . . . ,m,



6.5 Function fitting and interpolation 339

Figure 6.24 Least-squares fit of a convex function to data, shown as circles.
The (piecewise-linear) function shown minimizes the sum of squared fitting
error, over all convex functions.

which is an LP with variables y0 ∈ R, g0, . . . , gm ∈ Rk. By maximizing y0 (which
is also an LP) we find the largest possible value of f(u0) for a convex function that
interpolates the given data.

Interpolation with monotone convex functions

As an extension of convex interpolation, we can consider interpolation with a convex
and monotone nondecreasing function. It can be shown that there exists a convex
function f : Rk → R, with dom f = Rk, that satisfies the interpolation conditions

f(ui) = yi, i = 1, . . . ,m,

and is monotone nondecreasing (i.e., f(u) ≥ f(v) whenever u � v), if and only if
there exist g1, . . . , gm ∈ Rk, such that

gi � 0, i = 1, . . . ,m, yj ≥ yi + gTi (uj − ui), i, j = 1, . . . ,m. (6.21)
In other words, we add to the convex interpolation conditions (6.19), the condition
that the subgradients gi are all nonnegative. (See exercise 6.12.)

Bounding consumer preference

As an application, we consider a problem of predicting consumer preferences. We
consider different baskets of goods, consisting of different amounts of n consumer
goods. A goods basket is specified by a vector x ∈ [0, 1]n where xi denotes the
amount of consumer good i. We assume the amounts are normalized so that
0 ≤ xi ≤ 1, i.e., xi = 0 is the minimum and xi = 1 is the maximum possible
amount of good i. Given two baskets of goods x and x˜, a consumer can either
prefer x to x˜, or prefer x˜ to x, or consider x and x˜ equally attractive. We consider
one model consumer, whose choices are repeatable.



340 6 Approximation and fitting

We model consumer preference in the following way. We assume there is an
underlying utility function u : Rn → R, with domain [0, 1]n; u(x) gives a measure
of the utility derived by the consumer from the goods basket x. Given a choice
between two baskets of goods, the consumer chooses the one that has larger utility,
and will be ambivalent when the two baskets have equal utility. It is reasonable to
assume that u is monotone nondecreasing. This means that the consumer always
prefers to have more of any good, with the amounts of all other goods the same. It
is also reasonable to assume that u is concave. This models satiation, or decreasing
marginal utility as we increase the amount of goods.

Now suppose we are given some consumer preference data, but we do not know
the underlying utility function u. Specifically, we have a set of goods baskets
a1, . . . , am ∈ [0, 1]n, and some information about preferences among them:

u(ai) > u(aj) for (i, j) ∈ P, u(ai) ≥ u(aj) for (i, j) ∈ Pweak, (6.22)
where P, Pweak ⊆ {1, . . . ,m}×{1, . . . ,m} are given. Here P gives the set of known
preferences: (i, j) ∈ P means that basket ai is known to be preferred to basket aj .
The set Pweak gives the set of known weak preferences: (i, j) ∈ Pweak means that
basket ai is preferred to basket aj , or that the two baskets are equally attractive.

We first consider the following question: How can we determine if the given data
are consistent, i.e., whether or not there exists a concave nondecreasing utility
function u for which (6.22) holds? This is equivalent to solving the feasibility
problem

find u
subject to u : Rn → R concave and nondecreasing

u(ai) > u(aj), (i, j) ∈ P
u(ai) ≥ u(aj), (i, j) ∈ Pweak,

(6.23)

with the function u as the (infinite-dimensional) optimization variable. Since the
constraints in (6.23) are all homogeneous, we can express the problem in the equiv-
alent form

find u
subject to u : Rn → R concave and nondecreasing

u(ai) ≥ u(aj) + 1, (i, j) ∈ P
u(ai) ≥ u(aj), (i, j) ∈ Pweak,

(6.24)

which uses only nonstrict inequalities. (It is clear that if u satisfies (6.24), then
it must satisfy (6.23); conversely, if u satisfies (6.23), then it can be scaled to
satisfy (6.24).) This problem, in turn, can be cast as a (finite-dimensional) linear
programming feasibility problem, using the interpolation result on page 339:

find u1, . . . , um, g1, . . . , gm
subject to gi � 0, i = 1, . . . ,m

uj ≤ ui + gTi (aj − ai), i, j = 1, . . . ,m
ui ≥ uj + 1, (i, j) ∈ P
ui ≥ uj , (i, j) ∈ Pweak.

(6.25)

By solving this linear programming feasibility problem, we can determine whether
there exists a concave, nondecreasing utility function that is consistent with the



6.5 Function fitting and interpolation 341

given sets of strict and nonstrict preferences. If (6.25) is feasible, there is at least
one such utility function (and indeed, we can construct one that is piecewise-linear,
from a feasible u1, . . . , um, g1, . . . , gm). If (6.25) is not feasible, we can conclude
that there is no concave increasing utility function that is consistent with the given
sets of strict and nonstrict preferences.

As an example, suppose that P and Pweak are consumer preferences that are
known to be consistent with at least one concave increasing utility function. Con-
sider a pair (k, l) that is not in P or Pweak, i.e., consumer preference between
baskets k and l is not known. In some cases we can conclude that a preference
holds between basket k and l, even without knowing the underlying preference
function. To do this we augment the known preferences (6.22) with the inequality
u(ak) ≤ u(al), which means that basket l is preferred to basket k, or they are
equally attractive. We then solve the feasibility linear program (6.25), including
the extra weak preference u(ak) ≤ u(al). If the augmented set of preferences is in-
feasible, it means that any concave nondecreasing utility function that is consistent
with the original given consumer preference data must also satisfy u(ak) > u(al).
In other words, we can conclude that basket k is preferred to basket l, without
knowing the underlying utility function.

Example 6.9 Here we give a simple numerical example that illustrates the discussion
above. We consider baskets of two goods (so we can easily plot the goods baskets).
To generate the consumer preference data P, we compute 40 random points in [0, 1]2,
and then compare them using the utility function

u(x1, x2) = (1.1x
1/2
1 + 0.8x

1/2
2 )/1.9.

These goods baskets, and a few level curves of the utility function u, are shown in
figure 6.25.

We now use the consumer preference data (but not, of course, the true utility function
u) to compare each of these 40 goods baskets to the basket a0 = (0.5, 0.5). For each
original basket ai, we solve the linear programming feasibility problem described
above, to see if we can conclude that basket a0 is preferred to basket ai. Similarly,
we check whether we can conclude that basket ai is preferred to basket a0. For each
basket ai, there are three possible outcomes: we can conclude that a0 is definitely
preferred to ai, that ai is definitely preferred to a0, or (if both LP feasibility problems
are feasible) that no conclusion is possible. (Here, definitely preferred means that the
preference holds for any concave nondecreasing utility function that is consistent with
the original given data.)

We find that 21 of the baskets are definitely rejected in favor of (0.5, 0.5), and 14
of the baskets are definitely preferred. We cannot make any conclusion, from the
consumer preference data, about the remaining 5 baskets. These results are shown in
figure 6.26. Note that goods baskets below and to the left of (0.5, 0.5) will definitely
be rejected in favor of (0.5, 0.5), using only the monotonicity property of the utility
function, and similarly, those points that are above and to the right of (0.5, 0.5) must
be preferred. So for these 17 points, there is no need to solve the feasibility LP (6.25).
Classifying the 23 points in the other two quadrants, however, requires the concavity
assumption, and solving the feasibility LP (6.25).



342 6 Approximation and fitting

x1

x
2

0 0.5 1
0

0.5

1

Figure 6.25 Forty goods baskets a1, . . . , a40, shown as circles. The
0.1, 0.2, . . . , 0.9 level curves of the true utility function u are shown as dashed
lines. This utility function is used to find the consumer preference data P
among the 40 baskets.

x1

x
2

0 0.5 1
0

0.5

1

Figure 6.26 Results of consumer preference analysis using the LP (6.25), for a
new goods basket a0 = (0.5, 0.5). The original baskets are displayed as open
circles if they are definitely rejected (u(ak) < u(a0)), as solid black circles
if they are definitely preferred (u(ak) > u(a0)), and as squares when no
conclusion can be made. The level curve of the underlying utility function,
that passes through (0.5, 0.5), is shown as a dashed curve. The vertical and
horizontal lines passing through (0.5, 0.5) divide [0, 1]2 into four quadrants.
Points in the upper right quadrant must be preferred to (0.5, 0.5), by the
monotonicity assumption on u. Similarly, (0.5, 0.5) must be preferred to the
points in the lower left quadrant. For the points in the other two quadrants,
the results are not obvious.



Bibliography 343

Bibliography

The robustness properties of approximations with different penalty functions were an-
alyzed by Huber [Hub64, Hub81], who also proposed the penalty function (6.4). The
log-barrier penalty function arises in control theory, where it is applied to the system
closed-loop frequency response, and has several names, e.g., central H∞, or risk-averse
control; see Boyd and Barratt [BB91] and the references therein.

Regularized approximation is covered in many books, including Tikhonov and Arsenin
[TA77] and Hansen [Han98]. Tikhonov regularization is sometimes called ridge regression
(Golub and Van Loan [GL89, page 564]). Least-squares approximation with ℓ1-norm
regularization is also known under the name lasso (Tibshirani [Tib96]). Other least-
squares regularization and regressor selection techniques are discussed and compared in
Hastie, Tibshirani, and Friedman [HTF01, §3.4].
Total variation denoising was introduced for image reconstruction by Rudin, Osher, and
Fatemi [ROF92].

The robust least-squares problem with norm bounded uncertainty (page 321) was in-
troduced by El Ghaoui and Lebret [EL97], and Chandrasekaran, Golub, Gu, and Sayed
[CGGS98]. El Ghaoui and Lebret also give the SDP formulation of the robust least-squares
problem with structured uncertainty (page 323).

Chen, Donoho, and Saunders [CDS01] discuss basis pursuit via linear programming. They
refer to the ℓ1-norm regularized problem (6.18) as basis pursuit denoising. Meyer and
Pratt [MP68] is an early paper on the problem of bounding utility functions.



344 6 Approximation and fitting

Exercises

Norm approximation and least-norm problems

6.1 Quadratic bounds for log barrier penalty. Let φ : R → R be the log barrier penalty
function with limit a > 0:

φ(u) =

{
−a2 log(1− (u/a)2) |u| < a
∞ otherwise.

Show that if u ∈ Rm satisfies ‖u‖∞ < a, then

‖u‖22 ≤
m∑
i=1

φ(ui) ≤ φ(‖u‖∞)‖u‖2∞ ‖u‖
2
2.

This means that
∑m

i=1
φ(ui) is well approximated by ‖u‖22 if ‖u‖∞ is small compared to

a. For example, if ‖u‖∞/a = 0.25, then

‖u‖22 ≤
m∑
i=1

φ(ui) ≤ 1.033 · ‖u‖22.

6.2 ℓ1-, ℓ2-, and ℓ∞-norm approximation by a constant vector. What is the solution of the
norm approximation problem with one scalar variable x ∈ R,

minimize ‖x1− b‖,
for the ℓ1-, ℓ2-, and ℓ∞-norms?

6.3 Formulate the following approximation problems as LPs, QPs, SOCPs, or SDPs. The
problem data are A ∈ Rm×n and b ∈ Rm. The rows of A are denoted aTi .
(a) Deadzone-linear penalty approximation: minimize

∑m
i=1

φ(aTi x− bi), where

φ(u) =

{
0 |u| ≤ a
|u| − a |u| > a,

where a > 0.

(b) Log-barrier penalty approximation: minimize
∑m

i=1
φ(aTi x− bi), where

φ(u) =

{
−a2 log(1− (u/a)2) |u| < a
∞ |u| ≥ a,

with a > 0.

(c) Huber penalty approximation: minimize
∑m

i=1
φ(aTi x− bi), where

φ(u) =

{
u2 |u| ≤M
M(2|u| −M) |u| > M,

with M > 0.

(d) Log-Chebyshev approximation: minimize maxi=1,...,m | log(aTi x)− log bi|. We assume
b ≻ 0. An equivalent convex form is

minimize t
subject to 1/t ≤ aTi x/bi ≤ t, i = 1, . . . ,m,

with variables x ∈ Rn and t ∈ R, and domain Rn ×R++.



Exercises 345

(e) Minimizing the sum of the largest k residuals:

minimize
∑k

i=1
|r|[i]

subject to r = Ax− b,
where |r|[1] ≥ |r|[2] ≥ · · · ≥ |r|[m] are the numbers |r1|, |r2|, . . . , |rm| sorted in
decreasing order. (For k = 1, this reduces to ℓ∞-norm approximation; for k = m, it
reduces to ℓ1-norm approximation.) Hint. See exercise 5.19.

6.4 A differentiable approximation of ℓ1-norm approximation. The function φ(u) = (u
2+ǫ)1/2,

with parameter ǫ > 0, is sometimes used as a differentiable approximation of the absolute
value function |u|. To approximately solve the ℓ1-norm approximation problem

minimize ‖Ax− b‖1, (6.26)
where A ∈ Rm×n, we solve instead the problem

minimize
∑m

i=1
φ(aTi x− bi), (6.27)

where aTi is the ith row of A. We assume rankA = n.

Let p⋆ denote the optimal value of the ℓ1-norm approximation problem (6.26). Let xˆ
denote the optimal solution of the approximate problem (6.27), and let rˆ denote the
associated residual, rˆ = Axˆ− b.
(a) Show that p⋆ ≥∑m

i=1
rˆ2i /(rˆ

2
i + ǫ)

1/2.

(b) Show that

‖Axˆ− b‖1 ≤ p⋆ +
m∑
i=1

|rˆi|
(
1− |rˆi|

(rˆ2i + ǫ)
1/2

)
.

(By evaluating the righthand side after computing xˆ, we obtain a bound on how subop-
timal xˆ is for the ℓ1-norm approximation problem.)

6.5 Minimum length approximation. Consider the problem

minimize length(x)
subject to ‖Ax− b‖ ≤ ǫ,

where length(x) = min{k | xi = 0 for i > k}. The problem variable is x ∈ Rn; the
problem parameters are A ∈ Rm×n, b ∈ Rm, and ǫ > 0. In a regression context, we are
asked to find the minimum number of columns of A, taken in order, that can approximate
the vector b within ǫ.

Show that this is a quasiconvex optimization problem.

6.6 Duals of some penalty function approximation problems. Derive a Lagrange dual for the
problem

minimize
∑m

i=1
φ(ri)

subject to r = Ax− b,
for the following penalty functions φ : R→ R. The variables are x ∈ Rn, r ∈ Rm.
(a) Deadzone-linear penalty (with deadzone width a = 1),

φ(u) =

{
0 |u| ≤ 1
|u| − 1 |u| > 1.

(b) Huber penalty (with M = 1),

φ(u) =

{
u2 |u| ≤ 1
2|u| − 1 |u| > 1.



346 6 Approximation and fitting

(c) Log-barrier (with limit a = 1),

φ(u) = − log(1− u2), domφ = (−1, 1).
(d) Relative deviation from one,

φ(u) = max{u, 1/u} =
{

u u ≥ 1
1/u u ≤ 1,

with domφ = R++.

Regularization and robust approximation

6.7 Bi-criterion optimization with Euclidean norms. We consider the bi-criterion optimization
problem

minimize (w.r.t. R2+) (‖Ax− b‖22, ‖x‖22),
where A ∈ Rm×n has rank r, and b ∈ Rm. Show how to find the solution of each of the
following problems from the singular value decomposition of A,

A = U diag(σ)V T =

r∑
i=1

σiuiv
T
i

(see §A.5.4).
(a) Tikhonov regularization: minimize ‖Ax− b‖22 + δ‖x‖22.
(b) Minimize ‖Ax− b‖22 subject to ‖x‖22 = γ.
(c) Maximize ‖Ax− b‖22 subject to ‖x‖22 = γ.

Here δ and γ are positive parameters.

Your results provide efficient methods for computing the optimal trade-off curve and the
set of achievable values of the bi-criterion problem.

6.8 Formulate the following robust approximation problems as LPs, QPs, SOCPs, or SDPs.
For each subproblem, consider the ℓ1-, ℓ2-, and the ℓ∞-norms.

(a) Stochastic robust approximation with a finite set of parameter values, i.e., the sum-
of-norms problem

minimize
∑k

i=1
pi‖Aix− b‖

where p � 0 and 1T p = 1. (See §6.4.1.)
(b) Worst-case robust approximation with coefficient bounds:

minimize supA∈A ‖Ax− b‖
where

A = {A ∈ Rm×n | lij ≤ aij ≤ uij , i = 1, . . . ,m, j = 1, . . . , n}.
Here the uncertainty set is described by giving upper and lower bounds for the
components of A. We assume lij < uij .

(c) Worst-case robust approximation with polyhedral uncertainty:

minimize supA∈A ‖Ax− b‖
where

A = {[a1 · · · am]T | Ciai � di, i = 1, . . . ,m}.
The uncertainty is described by giving a polyhedron Pi = {ai | Ciai � di} of possible
values for each row. The parameters Ci ∈ Rpi×n, di ∈ Rpi , i = 1, . . . ,m, are given.
We assume that the polyhedra Pi are nonempty and bounded.



Exercises 347

Function fitting and interpolation

6.9 Minimax rational function fitting. Show that the following problem is quasiconvex:

minimize max
i=1,...,k

∣∣∣∣p(ti)q(ti) − yi
∣∣∣∣

where

p(t) = a0 + a1t+ a2t
2 + · · ·+ amtm, q(t) = 1 + b1t+ · · ·+ bntn,

and the domain of the objective function is defined as

D = {(a, b) ∈ Rm+1 ×Rn | q(t) > 0, α ≤ t ≤ β}.
In this problem we fit a rational function p(t)/q(t) to given data, while constraining the
denominator polynomial to be positive on the interval [α, β]. The optimization variables
are the numerator and denominator coefficients ai, bi. The interpolation points ti ∈ [α, β],
and desired function values yi, i = 1, . . . , k, are given.

6.10 Fitting data with a concave nonnegative nondecreasing quadratic function. We are given
the data

x1, . . . , xN ∈ Rn, y1, . . . , yN ∈ R,
and wish to fit a quadratic function of the form

f(x) = (1/2)xTPx+ qTx+ r,

where P ∈ Sn, q ∈ Rn, and r ∈ R are the parameters in the model (and, therefore, the
variables in the fitting problem).

Our model will be used only on the box B = {x ∈ Rn | l � x � u}. You can assume that
l ≺ u, and that the given data points xi are in this box.
We will use the simple sum of squared errors objective,

N∑
i=1

(f(xi)− yi)2,

as the criterion for the fit. We also impose several constraints on the function f . First,
it must be concave. Second, it must be nonnegative on B, i.e., f(z) ≥ 0 for all z ∈ B.
Third, f must be nondecreasing on B, i.e., whenever z, z˜ ∈ B satisfy z � z˜, we have
f(z) ≤ f(z˜).
Show how to formulate this fitting problem as a convex problem. Simplify your formula-
tion as much as you can.

6.11 Least-squares direction interpolation. Suppose F1, . . . , Fn : R
k → Rp, and we form the

linear combination F : Rk → Rp,
F (u) = x1F1(u) + · · ·+ xnFn(u),

where x is the variable in the interpolation problem.

In this problem we require that 6 (F (vj), qj) = 0, j = 1, . . . ,m, where qj are given vectors
in Rp, which we assume satisfy ‖qj‖2 = 1. In other words, we require the direction of
F to take on specified values at the points vj . To ensure that F (vj) is not zero (which
makes the angle undefined), we impose the minimum length constraints ‖F (vj)‖2 ≥ ǫ,
j = 1, . . . ,m, where ǫ > 0 is given.

Show how to find x that minimizes ‖x‖2, and satisfies the direction (and minimum length)
conditions above, using convex optimization.

6.12 Interpolation with monotone functions. A function f : Rk → R is monotone nondecreas-
ing (with respect to Rk+) if f(u) ≥ f(v) whenever u � v.



348 6 Approximation and fitting

(a) Show that there exists a monotone nondecreasing function f : Rk → R, that satisfies
f(ui) = yi for i = 1, . . . ,m, if and only if

yi ≥ yj whenever ui � uj , i, j = 1, . . . ,m.

(b) Show that there exists a convex monotone nondecreasing function f : Rk → R, with
dom f = Rk, that satisfies f(ui) = yi for i = 1, . . . ,m, if and only if there exist
gi ∈ Rk, i = 1, . . . ,m, such that

gi � 0, i = 1, . . . ,m, yj ≥ yi + gTi (uj − ui), i, j = 1, . . . ,m.
6.13 Interpolation with quasiconvex functions. Show that there exists a quasiconvex function

f : Rk → R, that satisfies f(ui) = yi for i = 1, . . . ,m, if and only if there exist gi ∈ Rk,
i = 1, . . . ,m, such that

gTi (uj − ui) ≤ −1 whenever yj < yi, i, j = 1, . . . ,m.
6.14 [Nes00] Interpolation with positive-real functions. Suppose z1, . . . , zn ∈ C are n distinct

points with |zi| > 1. We define Knp as the set of vectors y ∈ Cn for which there exists a
function f : C→ C that satisfies the following conditions.
• f is positive-real, which means it is analytic outside the unit circle (i.e., for |z| > 1),
and its real part is nonnegative outside the unit circle (ℜf(z) ≥ 0 for |z| > 1).

• f satisfies the interpolation conditions
f(z1) = y1, f(z2) = y2, . . . , f(zn) = yn.

If we denote the set of positive-real functions as F , then we can express Knp as
Knp = {y ∈ Cn | ∃f ∈ F , yk = f(zk), k = 1, . . . , n}.

(a) It can be shown that f is positive-real if and only if there exists a nondecreasing
function ρ such that for all z with |z| > 1,

f(z) = iℑf(∞) +
∫ 2π
0

eiθ + z−1

eiθ − z−1 dρ(θ),

where i =
√−1 (see [KN77, page 389]). Use this representation to show that Knp

is a closed convex cone.

(b) We will use the inner product ℜ(xHy) between vectors x, y ∈ Cn, where xH denotes
the complex conjugate transpose of x. Show that the dual cone of Knp is given by

K∗np =

{
x ∈ Cn

∣∣∣∣∣ ℑ(1Tx) = 0, ℜ
(

n∑
l=1

xl
e−iθ + z¯−1l
e−iθ − z¯−1l

)
≥ 0 ∀θ ∈ [0, 2π]

}
.

(c) Show that

K∗np =

{
x ∈ Cn

∣∣∣∣∣ ∃Q ∈ Hn+, xl =
n∑

k=1

Qkl

1− z−1k z¯−1l
, l = 1, . . . , n

}
where Hn+ denotes the set of positive semidefinite Hermitian matrices of size n× n.
Use the following result (known as Riesz-Feje´r theorem; see [KN77, page 60]). A
function of the form

n∑
k=0

(yke
−ikθ + y¯ke

ikθ)



Exercises 349

is nonnegative for all θ if and only if there exist a0, . . . , an ∈ C such that
n∑

k=0

(yke
−ikθ + y¯ke

ikθ) =

∣∣∣∣∣
n∑

k=0

ake
ikθ

∣∣∣∣∣
2

.

(d) Show that Knp = {y ∈ Cn | P (y) � 0} where P (y) ∈ Hn is defined as

P (y)kl =
yk + yl

1− z−1k z¯−1l
, l, k = 1, . . . , n.

The matrix P (y) is called the Nevanlinna-Pick matrix associated with the points
zk, yk.

Hint. As we noted in part (a), Knp is a closed convex cone, so Knp = K
∗∗
np.

(e) As an application, pose the following problem as a convex optimization problem:

minimize
∑n

k=1
|f(zk)− wk|2

subject to f ∈ F .

The problem data are n points zk with |zk| > 1 and n complex numbers w1, . . . ,
wn. We optimize over all positive-real functions f .





Chapter 7

Statistical estimation

7.1 Parametric distribution estimation

7.1.1 Maximum likelihood estimation

We consider a family of probability distributions on Rm, indexed by a vector
x ∈ Rn, with densities px(·). When considered as a function of x, for fixed y ∈ Rm,
the function px(y) is called the likelihood function. It is more convenient to work
with its logarithm, which is called the log-likelihood function, and denoted l:

l(x) = log px(y).

There are often constraints on the values of the parameter x, which can repre-
sent prior knowledge about x, or the domain of the likelihood function. These
constraints can be explicitly given, or incorporated into the likelihood function by
assigning px(y) = 0 (for all y) whenever x does not satisfy the prior information
constraints. (Thus, the log-likelihood function can be assigned the value −∞ for
parameters x that violate the prior information constraints.)

Now consider the problem of estimating the value of the parameter x, based
on observing one sample y from the distribution. A widely used method, called
maximum likelihood (ML) estimation, is to estimate x as

xˆml = argmaxxpx(y) = argmaxxl(x),

i.e., to choose as our estimate a value of the parameter that maximizes the like-
lihood (or log-likelihood) function for the observed value of y. If we have prior
information about x, such as x ∈ C ⊆ Rn, we can add the constraint x ∈ C
explicitly, or impose it implicitly, by redefining px(y) to be zero for x 6∈ C.

The problem of finding a maximum likelihood estimate of the parameter vector
x can be expressed as

maximize l(x) = log px(y)
subject to x ∈ C, (7.1)

where x ∈ C gives the prior information or other constraints on the parameter
vector x. In this optimization problem, the vector x ∈ Rn (which is the parameter



352 7 Statistical estimation

in the probability density) is the variable, and the vector y ∈ Rm (which is the
observed sample) is a problem parameter.

The maximum likelihood estimation problem (7.1) is a convex optimization
problem if the log-likelihood function l is concave for each value of y, and the set
C can be described by a set of linear equality and convex inequality constraints, a
situation which occurs in many estimation problems. For these problems we can
compute an ML estimate using convex optimization.

Linear measurements with IID noise

We consider a linear measurement model,

yi = a
T
i x+ vi, i = 1, . . . ,m,

where x ∈ Rn is a vector of parameters to be estimated, yi ∈ R are the measured
or observed quantities, and vi are the measurement errors or noise. We assume
that vi are independent, identically distributed (IID), with density p on R. The
likelihood function is then

px(y) =
m∏
i=1

p(yi − aTi x),

so the log-likelihood function is

l(x) = log px(y) =

m∑
i=1

log p(yi − aTi x).

The ML estimate is any optimal point for the problem

maximize
∑m

i=1 log p(yi − aTi x), (7.2)
with variable x. If the density p is log-concave, this problem is convex, and has the
form of a penalty approximation problem ((6.2), page 294), with penalty function
− log p.

Example 7.1 ML estimation for some common noise densities.

• Gaussian noise. When vi are Gaussian with zero mean and variance σ2, the
density is p(z) = (2πσ2)−1/2e−z

2/2σ2 , and the log-likelihood function is

l(x) = −(m/2) log(2πσ2)− 1
2σ2

‖Ax− y‖22,

where A is the matrix with rows aT1 , . . . , a
T
m. Therefore the ML estimate of

x is xml = argminx ‖Ax − y‖22, the solution of a least-squares approximation
problem.

• Laplacian noise. When vi are Laplacian, i.e., have density p(z) = (1/2a)e−|z|/a
(where a > 0), the ML estimate is xˆ = argminx ‖Ax − y‖1, the solution of the
ℓ1-norm approximation problem.

• Uniform noise. When vi are uniformly distributed on [−a, a], we have p(z) =
1/(2a) on [−a, a], and an ML estimate is any x satisfying ‖Ax− y‖∞ ≤ a.



7.1 Parametric distribution estimation 353

ML interpretation of penalty function approximation

Conversely, we can interpret any penalty function approximation problem

minimize
∑m

i=1 φ(bi − aTi x)

as a maximum likelihood estimation problem, with noise density

p(z) =
e−φ(z)∫
e−φ(u) du

,

and measurements b. This observation gives a statistical interpretation of the
penalty function approximation problem. Suppose, for example, that the penalty
function φ grows very rapidly for large values, which means that we attach a very
large cost or penalty to large residuals. The corresponding noise density function
p will have very small tails, and the ML estimator will avoid (if possible) estimates
with any large residuals because these correspond to very unlikely events.

We can also understand the robustness of ℓ1-norm approximation to large errors
in terms of maximum likelihood estimation. We interpret ℓ1-norm approximation
as maximum likelihood estimation with a noise density that is Laplacian; ℓ2-norm
approximation is maximum likelihood estimation with a Gaussian noise density.
The Laplacian density has larger tails than the Gaussian, i.e., the probability of a
very large vi is far larger with a Laplacian than a Gaussian density. As a result,
the associated maximum likelihood method expects to see greater numbers of large
residuals.

Counting problems with Poisson distribution

In a wide variety of problems the random variable y is nonnegative integer valued,
with a Poisson distribution with mean µ > 0:

prob(y = k) =
e−µµk

k!
.

Often y represents the count or number of events (such as photon arrivals, traffic
accidents, etc.) of a Poisson process over some period of time.

In a simple statistical model, the mean µ is modeled as an affine function of a
vector u ∈ Rn:

µ = aTu+ b.

Here u is called the vector of explanatory variables, and the vector a ∈ Rn and
number b ∈ R are called the model parameters. For example, if y is the number
of traffic accidents in some region over some period, u1 might be the total traffic
flow through the region during the period, u2 the rainfall in the region during the
period, and so on.

We are given a number of observations which consist of pairs (ui, yi), i =
1, . . . ,m, where yi is the observed value of y for which the value of the explanatory
variable is ui ∈ Rn. Our job is to find a maximum likelihood estimate of the model
parameters a ∈ Rn and b ∈ R from these data.



354 7 Statistical estimation

The likelihood function has the form

m∏
i=1

(aTui + b)
yi exp(−(aTui + b))

yi!
,

so the log-likelihood function is

l(a, b) =
m∑
i=1

(yi log(a
Tui + b)− (aTui + b)− log(yi!)).

We can find an ML estimate of a and b by solving the convex optimization problem

maximize
∑m

i=1(yi log(a
Tui + b)− (aTui + b)),

where the variables are a and b.

Logistic regression

We consider a random variable y ∈ {0, 1}, with
prob(y = 1) = p, prob(y = 0) = 1− p,

where p ∈ [0, 1], and is assumed to depend on a vector of explanatory variables
u ∈ Rn. For example, y = 1 might mean that an individual in a population acquires
a certain disease. The probability of acquiring the disease is p, which is modeled
as a function of some explanatory variables u, which might represent weight, age,
height, blood pressure, and other medically relevant variables.

The logistic model has the form

p =
exp(aTu+ b)

1 + exp(aTu+ b)
, (7.3)

where a ∈ Rn and b ∈ R are the model parameters that determine how the
probability p varies as a function of the explanatory variable u.

Now suppose we are given some data consisting of a set of values of the explana-
tory variables u1, . . . , um ∈ Rn along with the corresponding outcomes y1, . . . , ym ∈
{0, 1}. Our job is to find a maximum likelihood estimate of the model parameters
a ∈ Rn and b ∈ R. Finding an ML estimate of a and b is sometimes called logistic
regression.

We can re-order the data so for u1, . . . , uq, the outcome is y = 1, and for
uq+1, . . . , um the outcome is y = 0. The likelihood function then has the form

q∏
i=1

pi

m∏
i=q+1

(1− pi),

where pi is given by the logistic model with explanatory variable ui. The log-
likelihood function has the form

l(a, b) =

q∑
i=1

log pi +

m∑
i=q+1

log(1− pi)



7.1 Parametric distribution estimation 355

u

p
r
o
b
(y

=
1)

0 2 4 6 8 10

0

0.2

0.4

0.6

0.8

1

Figure 7.1 Logistic regression. The circles show 50 points (ui, yi), where
ui ∈ R is the explanatory variable, and yi ∈ {0, 1} is the outcome. The
data suggest that for u < 5 or so, the outcome is more likely to be y = 0,
while for u > 5 or so, the outcome is more likely to be y = 1. The data
also suggest that for u < 2 or so, the outcome is very likely to be y = 0,
and for u > 8 or so, the outcome is very likely to be y = 1. The solid
curve shows prob(y = 1) = exp(au+ b)/(1+ exp(au+ b)) for the maximum
likelihood parameters a, b. This maximum likelihood model is consistent
with our informal observations about the data set.

=

q∑
i=1

log
exp(aTui + b)

1 + exp(aTui + b)
+

m∑
i=q+1

log
1

1 + exp(aTui + b)

=

q∑
i=1

(aTui + b)−
m∑
i=1

log(1 + exp(aTui + b)).

Since l is a concave function of a and b, the logistic regression problem can be solved
as a convex optimization problem. Figure 7.1 shows an example with u ∈ R.

Covariance estimation for Gaussian variables

Suppose y ∈ Rn is a Gaussian random variable with zero mean and covariance
matrix R = E yyT , so its density is

pR(y) = (2π)
−n/2 det(R)−1/2 exp(−yTR−1y/2),

where R ∈ Sn++. We want to estimate the covariance matrix R based on N in-
dependent samples y1, . . . , yN ∈ Rn drawn from the distribution, and using prior
knowledge about R.

The log-likelihood function has the form

l(R) = log pR(y1, . . . , yN )



356 7 Statistical estimation

= −(Nn/2) log(2π)− (N/2) log detR− (1/2)
N∑
k=1

yTk R
−1yk

= −(Nn/2) log(2π)− (N/2) log detR− (N/2) tr(R−1Y ),

where

Y =
1

N

N∑
k=1

yky
T
k

is the sample covariance of y1, . . . , yN . This log-likelihood function is not a concave
function ofR (although it is concave on a subset of its domain Sn++; see exercise 7.4),
but a change of variable yields a concave log-likelihood function. Let S denote the
inverse of the covariance matrix, S = R−1 (which is called the information matrix ).
Using S in place of R as a new parameter, the log-likelihood function has the form

l(S) = −(Nn/2) log(2π) + (N/2) log detS − (N/2) tr(SY ),

which is a concave function of S.
Therefore the ML estimate of S (hence, R) is found by solving the problem

maximize log detS − tr(SY )
subject to S ∈ S (7.4)

where S is our prior knowledge of S = R−1. (We also have the implicit constraint
that S ∈ Sn++.) Since the objective function is concave, this is a convex problem
if the set S can be described by a set of linear equality and convex inequality
constraints.

First we examine the case in which no prior assumptions are made on R (hence,
S), other than R ≻ 0. In this case the problem (7.4) can be solved analytically. The
gradient of the objective is S−1−Y , so the optimal S satisfies S−1 = Y if Y ∈ Sn++.
(If Y 6∈ Sn++, the log-likelihood function is unbounded above.) Therefore, when
we have no prior assumptions about R, the maximum likelihood estimate of the
covariance is, simply, the sample covariance: Rˆml = Y .

Now we consider some examples of constraints on R that can be expressed as
convex constraints on the information matrix S. We can handle lower and upper
(matrix) bounds on R, of the form

L � R � U,

where L and U are symmetric and positive definite, as

U−1 � R−1 � L−1.

A condition number constraint on R,

λmax(R) ≤ κmaxλmin(R),

can be expressed as

λmax(S) ≤ κmaxλmin(S).



7.1 Parametric distribution estimation 357

This is equivalent to the existence of u > 0 such that uI � S � κmaxuI. We can
therefore solve the ML problem, with the condition number constraint on R, by
solving the convex problem

maximize log detS − tr(SY )
subject to uI � S � κmaxuI (7.5)

where the variables are S ∈ Sn and u ∈ R.
As another example, suppose we are given bounds on the variance of some linear

functions of the underlying random vector y,

E(cTi y)
2 ≤ αi, i = 1, . . . ,K.

These prior assumptions can be expressed as

E(cTi y)
2 = cTi Rci = c

T
i S

−1ci ≤ αi, i = 1, . . . ,K.
Since cTi S

−1ci is a convex function of S (provided S ≻ 0, which holds here), these
bounds can be imposed in the ML problem.

7.1.2 Maximum a posteriori probability estimation

Maximum a posteriori probability (MAP) estimation can be considered a Bayesian
version of maximum likelihood estimation, with a prior probability density on the
underlying parameter x. We assume that x (the vector to be estimated) and y (the
observation) are random variables with a joint probability density p(x, y). This
is in contrast to the statistical estimation setup, where x is a parameter, not a
random variable.

The prior density of x is given by

px(x) =

∫
p(x, y) dy.

This density represents our prior information about what the values of the vector x
might be, before we observe the vector y. Similarly, the prior density of y is given
by

py(y) =

∫
p(x, y) dx.

This density represents the prior information about what the measurement or ob-
servation vector y will be.

The conditional density of y, given x, is given by

py|x(x, y) =
p(x, y)

px(x)
.

In the MAP estimation method, py|x plays the role of the parameter dependent
density px in the maximum likelihood estimation setup. The conditional density
of x, given y, is given by

px|y(x, y) =
p(x, y)

py(y)
= py|x(x, y)

px(x)

py(y)
.



358 7 Statistical estimation

When we substitute the observed value y into px|y, we obtain the posterior density
of x. It represents our knowledge of x after the observation.

In the MAP estimation method, our estimate of x, given the observation y, is
given by

xˆmap = argmaxxpx|y(x, y)

= argmaxxpy|x(x, y)px(x)

= argmaxxp(x, y).

In other words, we take as estimate of x the value that maximizes the conditional
density of x, given the observed value of y. The only difference between this
estimate and the maximum likelihood estimate is the second term, px(x), appearing
here. This term can be interpreted as taking our prior knowledge of x into account.
Note that if the prior density of x is uniform over a set C, then finding the MAP
estimate is the same as maximizing the likelihood function subject to x ∈ C, which
is the ML estimation problem (7.1).

Taking logarithms, we can express the MAP estimate as

xˆmap = argmaxx(log py|x(x, y) + log px(x)). (7.6)

The first term is essentially the same as the log-likelihood function; the second
term penalizes choices of x that are unlikely, according to the prior density (i.e., x
with px(x) small).

Brushing aside the philosophical differences in setup, the only difference between
finding the MAP estimate (via (7.6)) and the ML estimate (via (7.1)) is the presence
of an extra term in the optimization problem, associated with the prior density of
x. Therefore, for any maximum likelihood estimation problem with concave log-
likelihood function, we can add a prior density for x that is log-concave, and the
resulting MAP estimation problem will be convex.

Linear measurements with IID noise

Suppose that x ∈ Rn and y ∈ Rm are related by

yi = a
T
i x+ vi, i = 1, . . . ,m,

where vi are IID with density pv on R, and x has prior density px on R
n. The

joint density of x and y is then

p(x, y) = px(x)
m∏
i=1

pv(yi − aTi x),

and the MAP estimate can be found by solving the optimization problem

maximize log px(x) +
∑m

i=1 log pv(yi − aTi x). (7.7)

If px and pv are log-concave, this problem is convex. The only difference between
the MAP estimation problem (7.7) and the associated ML estimation problem (7.2)
is the extra term log px(x).



7.2 Nonparametric distribution estimation 359

For example, if vi are uniform on [−a, a], and the prior distribution of x is
Gaussian with mean x¯ and covariance Σ, the MAP estimate is found by solving
the QP

minimize (x− x¯)TΣ−1(x− x¯)
subject to ‖Ax− y‖∞ ≤ a,

with variable x.

MAP with perfect linear measurements

Suppose x ∈ Rn is a vector of parameters to be estimated, with prior density
px. We have m perfect (noise free, deterministic) linear measurements, given by
y = Ax. In other words, the conditional distribution of y, given x, is a point mass
with value one at the point Ax. The MAP estimate can be found by solving the
problem

maximize log px(x)
subject to Ax = y.

If px is log-concave, this is a convex problem.
If under the prior distribution, the parameters xi are IID with density p on R,

then the MAP estimation problem has the form

maximize
∑n

i=1 log p(xi)
subject to Ax = y,

which is a least-penalty problem ((6.6), page 304), with penalty function φ(u) =
− log p(u).

Conversely, we can interpret any least-penalty problem,

minimize φ(x1) + · · ·+ φ(xn)
subject to Ax = b

as a MAP estimation problem, with m perfect linear measurements (i.e., Ax = b)
and xi IID with density

p(z) =
e−φ(z)∫
e−φ(u) du

.

7.2 Nonparametric distribution estimation

We consider a random variable X with values in the finite set {α1, . . . , αn} ⊆ R.
(We take the values to be in R for simplicity; the same ideas can be applied when
the values are in Rk, for example.) The distribution of X is characterized by
p ∈ Rn, with prob(X = αk) = pk. Clearly, p satisfies p � 0, 1T p = 1. Conversely,
if p ∈ Rn satisfies p � 0, 1T p = 1, then it defines a probability distribution for a
random variable X, defined as prob(X = αk) = pk. Thus, the probability simplex

{p ∈ Rn | p � 0, 1T p = 1}



360 7 Statistical estimation

is in one-to-one correspondence with all possible probability distributions for a
random variable X taking values in {α1, . . . , αn}.

In this section we discuss methods used to estimate the distribution p based on
a combination of prior information and, possibly, observations and measurements.

Prior information

Many types of prior information about p can be expressed in terms of linear equality
constraints or inequalities. If f : R→ R is any function, then

E f(X) =

n∑
i=1

pif(αi)

is a linear function of p. As a special case, if C ⊆ R, then prob(X ∈ C) is a linear
function of p:

prob(X ∈ C) = cT p, ci =
{

1 αi ∈ C
0 αi 6∈ C.

It follows that known expected values of certain functions (e.g., moments) or known
probabilities of certain sets can be incorporated as linear equality constraints on
p ∈ Rn. Inequalities on expected values or probabilities can be expressed as linear
inequalities on p ∈ Rn.

For example, suppose we know that X has mean EX = α, second moment
EX2 = β, and prob(X ≥ 0) ≤ 0.3. This prior information can be expressed as

EX =
n∑
i=1

αipi = α, EX
2 =

n∑
i=1

α2i pi = β,
∑
αi≥0

pi ≤ 0.3,

which are two linear equalities and one linear inequality in p.
We can also include some prior constraints that involve nonlinear functions of

p. As an example, the variance of X is given by

var(X) = EX2 − (EX)2 =
n∑
i=1

α2i pi −
(

n∑
i=1

αipi

)2
.

The first term is a linear function of p and the second term is concave quadratic
in p, so the variance of X is a concave function of p. It follows that a lower bound
on the variance of X can be expressed as a convex quadratic inequality on p.

As another example, suppose A and B are subsets of R, and consider the
conditional probability of A given B:

prob(X ∈ A|X ∈ B) = prob(X ∈ A ∩B)
prob(X ∈ B) .

This function is linear-fractional in p ∈ Rn: it can be expressed as
prob(X ∈ A|X ∈ B) = cT p/dT p,

where

ci =

{
1 αi ∈ A ∩B
0 αi 6∈ A ∩B , di =

{
1 αi ∈ B
0 αi 6∈ B.



7.2 Nonparametric distribution estimation 361

Therefore we can express the prior constraints

l ≤ prob(X ∈ A|X ∈ B) ≤ u

as the linear inequality constraints on p

ldT p ≤ cT p ≤ udT p.

Several other types of prior information can be expressed in terms of nonlinear
convex inequalities. For example, the entropy of X, given by

−
n∑
i=1

pi log pi,

is a concave function of p, so we can impose a minimum value of entropy as a convex
inequality on p. If q represents another distribution, i.e., q � 0, 1T q = 1, then
the Kullback-Leibler divergence between the distribution q and the distribution p
is given by

n∑
i=1

pi log(pi/qi),

which is convex in p (and q as well; see example 3.19, page 90). It follows that
we can impose a maximum Kullback-Leibler divergence between p and a given
distribution q, as a convex inequality on p.

In the next few paragraphs we express the prior information about the distribu-
tion p as p ∈ P. We assume that P can be described by a set of linear equalities and
convex inequalities. We include in the prior information P the basic constraints
p � 0, 1T p = 1.

Bounding probabilities and expected values

Given prior information about the distribution, say p ∈ P, we can compute upper
or lower bounds on the expected value of a function, or probability of a set. For
example to determine a lower bound on E f(X) over all distributions that satisfy
the prior information p ∈ P, we solve the convex problem

minimize
∑n

i=1 f(αi)pi
subject to p ∈ P.

Maximum likelihood estimation

We can use maximum likelihood estimation to estimate p based on observations
from the distribution. Suppose we observe N independent samples x1, . . . , xN from
the distribution. Let ki denote the number of these samples with value αi, so that
k1 + · · · + kn = N , the total number of observed samples. The log-likelihood
function is then

l(p) =

n∑
i=1

ki log pi,



362 7 Statistical estimation

which is a concave function of p. The maximum likelihood estimate of p can be
found by solving the convex problem

maximize l(p) =
∑n

i=1 ki log pi
subject to p ∈ P,

with variable p.

Maximum entropy

The maximum entropy distribution consistent with the prior assumptions can be
found by solving the convex problem

minimize
∑n

i=1 pi log pi
subject to p ∈ P.

Enthusiasts describe the maximum entropy distribution as the most equivocal or
most random, among those consistent with the prior information.

Minimum Kullback-Leibler divergence

We can find the distribution p that has minimum Kullback-Leibler divergence from
a given prior distribution q, among those consistent with prior information, by
solving the convex problem

minimize
∑n

i=1 pi log(pi/qi)
subject to p ∈ P,

Note that when the prior distribution is the uniform distribution, i.e., q = (1/n)1,
this problem reduces to the maximum entropy problem.

Example 7.2 We consider a probability distribution on 100 equidistant points αi in
the interval [−1, 1]. We impose the following prior assumptions:

EX ∈ [−0.1, 0.1]
EX2 ∈ [0.5, 0.6]

E(3X3 − 2X) ∈ [−0.3,−0.2]
prob(X < 0) ∈ [0.3, 0.4].

(7.8)

Along with the constraints 1T p = 1, p � 0, these constraints describe a polyhedron
of probability distributions.

Figure 7.2 shows the maximum entropy distribution that satisfies these constraints.
The maximum entropy distribution satisfies

EX = 0.056

EX2 = 0.5

E(3X3 − 2X) = −0.2
prob(X < 0) = 0.4.

To illustrate bounding probabilities, we compute upper and lower bounds on the
cumulative distribution prob(X ≤ αi), for i = 1, . . . , 100. For each value of i,



7.2 Nonparametric distribution estimation 363

αi

p
i
=
p
r
o
b
(X

=
α
i)

−1 −0.5 0 0.5 10

0.01

0.02

0.03

0.04

Figure 7.2Maximum entropy distribution that satisfies the constraints (7.8).

we solve two LPs: one that maximizes prob(X ≤ αi), and one that minimizes
prob(X ≤ αi), over all distributions consistent with the prior assumptions (7.8).
The results are shown in figure 7.3. The upper and lower curves show the upper and
lower bounds, respectively; the middle curve shows the cumulative distribution of the
maximum entropy distribution.

Example 7.3 Bounding risk probability with known marginal distributions. SupposeX
and Y are two random variables that give the return on two investments. We assume
that X takes values in {α1, . . . , αn} ⊆ R and Y takes values in {β1, . . . , βm} ⊆ R,
with pij = prob(X = αi, Y = βj). The marginal distributions of the two returns X
and Y are known, i.e.,

m∑
j=1

pij = ri, i = 1, . . . , n,

n∑
i=1

pij = qj , j = 1, . . . ,m, (7.9)

but otherwise nothing is known about the joint distribution p. This defines a poly-
hedron of joint distributions consistent with the given marginals.

Now suppose we make both investments, so our total return is the random variable
X + Y . We are interested in computing an upper bound on the probability of some
level of loss, or low return, i.e., prob(X + Y < γ). We can compute a tight upper
bound on this probability by solving the LP

maximize
∑ {pij | αi + βj < γ}

subject to (7.9), pij ≥ 0, i = 1, . . . n, j = 1, . . . ,m.
The optimal value of this LP is the maximum probability of loss. The optimal
solution p⋆ is the joint distribution, consistent with the given marginal distributions,
that maximizes the probability of the loss.

The same method can be applied to a derivative of the two investments. Let R(X,Y )
be the return of the derivative, where R : R2 → R. We can compute sharp lower



364 7 Statistical estimation

αi

p
r
o
b
(X

≤
α
i)

−1 −0.5 0 0.5 1
0

0.2

0.4

0.6

0.8

1

Figure 7.3 The top and bottom curves show the maximum and minimum
possible values of the cumulative distribution function, prob(X ≤ αi), over
all distributions that satisfy (7.8). The middle curve is the cumulative dis-
tribution of the maximum entropy distribution that satisfies (7.8).

and upper bounds on prob(R < γ) by solving a similar LP, with objective function∑
{pij | R(αi, βj) < γ} ,

which we can minimize and maximize.

7.3 Optimal detector design and hypothesis testing

Suppose X is a random variable with values in {1, . . . , n}, with a distribution that
depends on a parameter θ ∈ {1, . . . ,m}. The distributions of X, for the m possible
values of θ, can be represented by a matrix P ∈ Rn×m, with elements

pkj = prob(X = k | θ = j).

The jth column of P gives the probability distribution associated with the param-
eter value θ = j.

We consider the problem of estimating θ, based on an observed sample of X. In
other words, the sample X is generated from one of the m possible distributions,
and we are to guess which one. Them values of θ are called hypotheses, and guessing
which hypothesis is correct (i.e., which distribution generated the observed sample
X) is called hypothesis testing. In many cases one of the hypotheses corresponds
to some normal situation, and each of the other hypotheses corresponds to some
abnormal event. In this case hypothesis testing can be interpreted as observing a



7.3 Optimal detector design and hypothesis testing 365

value of X, and then guessing whether or not an abnormal event has occurred, and
if so, which one. For this reason hypothesis testing is also called detection.

In most cases there is no significance to the ordering of the hypotheses; they are
simply m different hypotheses, arbitrarily labeled θ = 1, . . . ,m. If θˆ = θ, where θˆ
denotes the estimate of θ, then we have correctly guessed the parameter value θ. If
θˆ 6= θ, then we have (incorrectly) guessed the parameter value θ; we have mistaken
θˆ for θ. In other cases, there is significance in the ordering of the hypotheses. In this
case, an event such as θˆ > θ, i.e., the event that we overestimate θ, is meaningful.

It is also possible to parametrize θ by values other than {1, . . . ,m}, say as θ ∈
{θ1, . . . , θm}, where θi are (distinct) values. These values could be real numbers, or
vectors, for example, specifying the mean and variance of the kth distribution. In
this case, a quantity such as ‖θˆ−θ‖, which is the norm of the parameter estimation
error, is meaningful.

7.3.1 Deterministic and randomized detectors

A (deterministic) estimator or detector is a function ψ from {1, . . . , n} (the set of
possible observed values) into {1, . . . ,m} (the set of hypotheses). If X is observed
to have value k, then our guess for the value of θ is θˆ = ψ(k). One obvious
deterministic detector is the maximum likelihood detector, given by

θˆ = ψml(k) = argmax
j

pkj . (7.10)

When we observe the value X = k, the maximum likelihood estimate of θ is a
value that maximizes the probability of observing X = k, over the set of possible
distributions.

We will consider a generalization of the deterministic detector, in which the
estimate of θ, given an observed value of X, is random. A randomized detector
of θ is a random variable θˆ ∈ {1, . . . ,m}, with a distribution that depends on the
observed value of X. A randomized detector can be defined in terms of a matrix
T ∈ Rm×n with elements

tik = prob(θˆ = i | X = k).
The interpretation is as follows: if we observe X = k, then the detector gives θˆ = i
with probability tik. The kth column of T , which we will denote tk, gives the
probability distribution of θˆ, when we observe X = k. If each column of T is a
unit vector, then the randomized detector is a deterministic detector, i.e., θˆ is a
(deterministic) function of the observed value of X.

At first glance, it seems that intentionally introducing additional randomiza-
tion into the estimation or detection process can only make the estimator worse.
But we will see below examples in which a randomized detector outperforms all
deterministic estimators.

We are interested in designing the matrix T that defines the randomized detec-
tor. Obviously the columns tk of T must satisfy the (linear equality and inequality)
constraints

tk � 0, 1T tk = 1. (7.11)



366 7 Statistical estimation

7.3.2 Detection probability matrix

For the randomized detector defined by the matrix T , we define the detection
probability matrix as D = TP . We have

Dij = (TP )ij = prob(θˆ = i | θ = j),

so Dij is the probability of guessing θˆ = i, when in fact θ = j. The m × m
detection probability matrix D characterizes the performance of the randomized
detector defined by T . The diagonal entry Dii is the probability of guessing θˆ = i
when θ = i, i.e., the probability of correctly detecting that θ = i. The off-diagonal
entry Dij (with i 6= j) is the probability of mistaking θ = i for θ = j, i.e., the
probability that our guess is θˆ = i, when in fact θ = j. If D = I, the detector is
perfect: no matter what the parameter θ is, we correctly guess θˆ = θ.

The diagonal entries of D, arranged in a vector, are called the detection proba-
bilities, and denoted P d:

P di = Dii = prob(θˆ = i | θ = i).
The error probabilities are the complements, and are denoted P e:

P ei = 1−Dii = prob(θˆ 6= i | θ = i).
Since the columns of the detection probability matrix D add up to one, we can
express the error probabilities as

P ei =
∑
j 6=i

Dji.

7.3.3 Optimal detector design

In this section we show that a wide variety of objectives for detector design are
linear, affine, or convex piecewise-linear functions of D, and therefore also of T
(which is the optimization variable). Similarly, a variety of constraints for detector
design can be expressed in terms of linear inequalities in D. It follows that a wide
variety of optimal detector design problems can be expressed as LPs. We will see
in §7.3.4 that some of these LPs have simple solutions; in this section we simply
formulate the problem.

Limits on errors and detection probabilities

We can impose a lower bound on the probability of correctly detecting the jth
hypothesis,

P dj = Djj ≥ Lj ,
which is a linear inequality in D (hence, T ). Similarly, we can impose a maximum
allowable probability for mistaking θ = i for θ = j:

Dij ≤ Uij ,



7.3 Optimal detector design and hypothesis testing 367

which are also linear constraints on T . We can take any of the detection prob-
abilities as an objective to be maximized, or any of the error probabilities as an
objective to be minimized.

Minimax detector design

We can take as objective (to be minimized) the minimax error probability, maxj P
e
j ,

which is a piecewise-linear convex function of D (hence, also of T ). With this as
the only objective, we have the problem of minimizing the maximum probability
of detection error,

minimize maxj P
e
j

subject to tk � 0, 1T tk = 1, k = 1, . . . , n,
where the variables are t1, . . . , tn ∈ Rm. This can be reformulated as an LP. The
minimax detector minimizes the worst-case (largest) probability of error over all m
hypotheses.

We can, of course, add further constraints to the minimax detector design prob-
lem.

Bayes detector design

In Bayes detector design, we have a prior distribution for the hypotheses, given by
q ∈ Rm, where

qi = prob(θ = i).

In this case, the probabilities pij are interpreted as conditional probabilities of X,
given θ. The probability of error for the detector is then given by qTP e, which is
an affine function of T . The Bayes optimal detector is the solution of the LP

minimize qTP e

subject to tk � 0, 1T tk = 1, k = 1, . . . , n.
We will see in §7.3.4 that this problem has a simple analytical solution.

One special case is when q = (1/m)1. In this case the Bayes optimal detector
minimizes the average probability of error, where the (unweighted) average is over
the hypotheses. In §7.3.4 we will see that the maximum likelihood detector (7.10)
is optimal for this problem.

Bias, mean-square error, and other quantities

In this section we assume that the ordering of the values of θ have some significance,
i.e., that the value θ = i can be interpreted as a larger value of the parameter than
θ = j, when i > j. This might be the case, for example, when θ = i corresponds to
the hypothesis that i events have occurred. Here we may be interested in quantities
such as

prob(θˆ > θ | θ = i),
which is the probability that we overestimate θ when θ = i. This is an affine
function of D:

prob(θˆ > θ | θ = i) =
∑
j>i

Dji,



368 7 Statistical estimation

so a maximum allowable value for this probability can be expressed as a linear
inequality on D (hence, T ). As another example, the probability of misclassifying
θ by more than one, when θ = i,

prob(|θˆ − θ| > 1 | θ = i) =
∑

|j−i|>1

Dji,

is also a linear function of D.
We now suppose that the parameters have values {θ1, . . . , θm} ⊆ R. The es-

timation or detection (parameter) error is then given by θˆ − θ, and a number of
quantities of interest are given by linear functions of D. Examples include:

• Bias. The bias of the detector, when θ = θi, is given by the linear function

E
i
(θˆ − θ) =

m∑
j=1

(θj − θi)Dji,

where the subscript on E means the expectation is with respect to the dis-
tribution of the hypothesis θ = θi.

• Mean square error. The mean square error of the detector, when θ = θi, is
given by the linear function

E
i
(θˆ − θ)2 =

m∑
j=1

(θj − θi)2Dji.

• Average absolute error. The average absolute error of the detector, when
θ = θi, is given by the linear function

E
i
|θˆ − θ| =

m∑
j=1

|θj − θi|Dji.

7.3.4 Multicriterion formulation and scalarization

The optimal detector design problem can be considered a multicriterion problem,
with the constraints (7.11), and the m(m− 1) objectives given by the off-diagonal
entries of D, which are the probabilities of the different types of detection error:

minimize (w.r.t. R
m(m−1)
+ ) Dij , i, j = 1, . . . ,m, i 6= j

subject to tk � 0, 1T tk = 1, k = 1, . . . , n, (7.12)

with variables t1, . . . , tn ∈ Rm. Since each objective Dij is a linear function of the
variables, this is a multicriterion linear program.

We can scalarize this multicriterion problem by forming the weighted sum ob-
jective

m∑
i,j=1

WijDij = tr(W
TD)



7.3 Optimal detector design and hypothesis testing 369

where the weight matrix W ∈ Rm×m satisfies

Wii = 0, i = 1, . . . ,m, Wij > 0, i, j = 1, . . . ,m, i 6= j.

This objective is a weighted sum of the m(m− 1) error probabilities, with weight
Wij associated with the error of guessing θˆ = i when in fact θ = j. The weight
matrix is sometimes called the loss matrix.

To find a Pareto optimal point for the multicriterion problem (7.12), we form
the scalar optimization problem

minimize tr(WTD)
subject to tk � 0, 1T tk = 1, k = 1, . . . , n, (7.13)

which is an LP. This LP is separable in the variables t1, . . . , tn. The objective can
be expressed as a sum of (linear) functions of tk:

tr(WTD) = tr(WTTP ) = tr(PWTT ) =
n∑

k=1

cTk tk,

where ck is the kth column of WP
T . The constraints are separable (i.e., we have

separate constraints on each ti). Therefore we can solve the LP (7.13) by separately
solving

minimize cTk tk
subject to tk � 0, 1T tk = 1,

for k = 1, . . . , n. Each of these LPs has a simple analytical solution (see exer-
cise 4.8). We first find an index q such that ckq = minj ckj . Then we take t

⋆
k = eq.

This optimal point corresponds to a deterministic detector: when X = k is ob-
served, our estimate is

θˆ = argmin
j

(WPT )jk. (7.14)

Thus, for every weight matrix W with positive off-diagonal elements we can find
a deterministic detector that minimizes the weighted sum objective. This seems
to suggest that randomized detectors are not needed, but we will see this is not
the case. The Pareto optimal trade-off surface for the multicriterion LP (7.12) is
piecewise-linear; the deterministic detectors of the form (7.14) correspond to the
vertices on the Pareto optimal surface.

MAP and ML detectors

Consider a Bayes detector design with prior distribution q. The mean probability
of error is

qTP e =
m∑
j=1

qj
∑
i6=j

Dij =
m∑

i,j=1

WijDij ,

if we define the weight matrix W as

Wij = qj , i, j = 1, . . . ,m, i 6= j, Wii = 0, i = 1, . . . ,m.



370 7 Statistical estimation

Thus, a Bayes optimal detector is given by the deterministic detector (7.14), with

(WPT )jk =
∑
i6=j

qipki =

m∑
i=1

qipki − qjpkj .

The first term is independent of j, so the optimal detector is simply

θˆ = argmax
j

(pkjqj),

when X = k is observed. The solution has a simple interpretation: Since pkjqj
gives the probability that θ = j and X = k, this detector is a maximum a posteriori
probability (MAP) detector.

For the special case q = (1/m)1, i.e., a uniform prior distribution on θ, this
MAP detector reduces to a maximum likelihood (ML) detector:

θˆ = argmax
j

pkj .

Thus, a maximum likelihood detector minimizes the (unweighted) average or mean
probability of error.

7.3.5 Binary hypothesis testing

As an illustration, we consider the special case m = 2, which is called binary
hypothesis testing. The random variable X is generated from one of two distribu-
tions, which we denote p ∈ Rn and q ∈ Rn, to simplify the notation. Often the
hypothesis θ = 1 corresponds to some normal situation, and the hypothesis θ = 2
corresponds to some abnormal event that we are trying to detect. If θˆ = 1, we say
the test is negative (i.e., we guess that the event did not occur); if θˆ = 2, we say
the test is positive (i.e., we guess that the event did occur).

The detection probability matrix D ∈ R2×2 is traditionally expressed as

D =

[
1− Pfp Pfn
Pfp 1− Pfn

]
.

Here Pfn is the probability of a false negative (i.e., the test is negative when in fact
the event has occurred) and Pfp is the probability of a false positive (i.e., the test
is positive when in fact the event has not occurred), which is also called the false
alarm probability. The optimal detector design problem is a bi-criterion problem,
with objectives Pfn and Pfp.

The optimal trade-off curve between Pfn and Pfp is called the receiver operating
characteristic (ROC), and is determined by the distributions p and q. The ROC
can be found by scalarizing the bi-criterion problem, as described in §7.3.4. For
the weight matrix W , an optimal detector (7.14) is

θˆ =

{
1 W21pk > W12qk
2 W21pk ≤W12qk



7.3 Optimal detector design and hypothesis testing 371

Pfp

P
fn

1

2

3
4

0 0.2 0.4 0.6 0.8 1
0

0.2

0.4

0.6

0.8

1

Figure 7.4 Optimal trade-off curve between probability of a false negative,
and probability of a false positive test result, for the matrix P given in (7.15).
The vertices of the trade-off curve, labeled 1–3, correspond to deterministic
detectors; the point labeled 4, which is a randomized detector, is the mini-
max detector. The dashed line shows Pfn = Pfp, the points where the error
probabilities are equal.

when X = k is observed. This is called a likelihood ratio threshold test : if the
ratio pk/qk is more than the threshold W12/W21, the test is negative (i.e., θˆ =
1); otherwise the test is positive. By choosing different values of the threshold,
we obtain (deterministic) Pareto optimal detectors that give different levels of
false positive versus false negative error probabilities. This result is known as
the Neyman-Pearson lemma.

The likelihood ratio detectors do not give all the Pareto optimal detectors; they
are the vertices of the optimal trade-off curve, which is piecewise-linear.

Example 7.4 We consider a binary hypothesis testing example with n = 4, and

P =

 0.70 0.100.20 0.100.05 0.70
0.05 0.10

 . (7.15)
The optimal trade-off curve between Pfn and Pfp, i.e., the receiver operating curve,
is shown in figure 7.4. The left endpoint corresponds to the detector which is always
negative, independent of the observed value of X; the right endpoint corresponds to
the detector that is always positive. The vertices labeled 1, 2, and 3 correspond to
the deterministic detectors

T (1) =

[
1 1 0 1
0 0 1 0

]
,

T (2) =

[
1 1 0 0
0 0 1 1

]
,



372 7 Statistical estimation

T (3) =

[
1 0 0 0
0 1 1 1

]
,

respectively. The point labeled 4 corresponds to the nondeterministic detector

T (4) =

[
1 2/3 0 0
0 1/3 1 1

]
,

which is the minimax detector. This minimax detector yields equal probability of
a false positive and false negative, which in this case is 1/6. Every deterministic
detector has either a false positive or false negative probability that exceeds 1/6,
so this is an example where a randomized detector outperforms every deterministic
detector.

7.3.6 Robust detectors

So far we have assumed that P , which gives the distribution of the observed variable
X, for each value of the parameter θ, is known. In this section we consider the case
where these distributions are not known, but certain prior information about them
is given. We assume that P ∈ P, where P is the set of possible distributions. With
a randomized detector characterized by T , the detection probability matrix D now
depends on the particular value of P . We will judge the error probabilities by
their worst-case values, over P ∈ P. We define the worst-case detection probability
matrix Dwc as

Dwcij = sup
P∈P

Dij , i, j = 1, . . . ,m, i 6= j

and
Dwcii = inf

P∈P
Dii, i = 1, . . . ,m.

The off-diagonal entries give the largest possible probability of errors, and the
diagonal entries give the smallest possible probability of detection, over P ∈ P.
Note that

∑n
i=1D

wc
ij 6= 1 in general, i.e., the columns of a worst-case detection

probability matrix do not necessarily add up to one.
We define the worst-case probability of error as

Pwcei = 1−Dwcii .
Thus, Pwcei is the largest probability of error, when θ = i, over all possible distri-
butions in P.

Using the worst-case detection probability matrix, or the worst-case probability
of error vector, we can develop various robust versions of detector design problems.
In the rest of this section we concentrate on the robust minimax detector design
problem, as a generic example that illustrates the ideas.

We define the robust minimax detector as the detector that minimizes the worst-
case probability of error, over all hypotheses, i.e., minimizes the objective

max
i

Pwcei = max
i=1,...,m

sup
P∈P

(1− (TP )ii) = 1− min
i=1,...,m

inf
P∈P

(TP )ii.

The robust minimax detector minimizes the worst possible probability of error,
over all m hypotheses, and over all P ∈ P.



7.3 Optimal detector design and hypothesis testing 373

Robust minimax detector for finite P
When the set of possible distributions is finite, the robust minimax detector design
problem is readily formulated as an LP. With P = {P1, . . . , Pk}, we can find the
robust minimax detector by solving

maximize mini=1,...,m infP∈P(TP )ii = mini=1,...,mminj=1,...,k(TPj)ii
subject to ti � 0, 1T ti = 1, i = 1, . . . , n,

The objective is piecewise-linear and concave, so this problem can be expressed as
an LP. Note that we can just as well consider P to be the polyhedron convP;
the associated worst-case detection matrix, and robust minimax detector, are the
same.

Robust minimax detector for polyhedral P
It is also possible to efficiently formulate the robust minimax detector problem as an
LP when P is a polyhedron described by linear equality and inequality constraints.
This formulation is less obvious, and relies on a dual representation of P.

To simplify the discussion, we assume that P has the form
P = {P = [p1 · · · pm] ∣∣ Akpk = bk, 1T pk = 1, pk � 0} . (7.16)

In other words, for each distribution pk, we are given some expected values Akpk =
bk. (These might represent known moments, probabilities, etc.) The extension to
the case where we are given inequalities on expected values is straightforward.

The robust minimax design problem is

maximize γ
subject to inf{t˜Ti p | Aip = bi, 1T p = 1, p � 0} ≥ γ, i = 1, . . . ,m

ti � 0, 1T ti = 1, i = 1, . . . , n,
where t˜Ti denotes the ith row of T (so that (TP )ii = t˜

T
i pi). By LP duality,

inf{t˜Ti p | Aip = bi, 1T p = 1, p � 0} = sup{νT bi + µ | ATi ν + µ1 � t˜i}.
Using this, the robust minimax detector design problem can be expressed as the
LP

maximize γ
subject to νTi bi + µi ≥ γ, i = 1, . . . ,m

ATi νi + µi1 � t˜i, i = 1, . . . ,m
ti � 0, 1T ti = 1, i = 1, . . . , n,

with variables ν1, . . . , νm, µ1, . . . , µn, and T (which has columns ti and rows t˜
T
i ).

Example 7.5 Robust binary hypothesis testing. Supposem = 2 and the set P in (7.16)
is defined by

A1 = A2 = A =

[
a1 a2 · · · an
a21 a

2
2 · · · a2n

]
, b1 =

[
α1
α2

]
, b2 =

[
β1
β2

]
.

Designing a robust minimax detector for this set P can be interpreted as a binary
hypothesis testing problem: based on an observation of a random variable X ∈
{a1, . . . , an}, choose between the following two hypotheses:



374 7 Statistical estimation

1. EX = α1, EX
2 = α2

2. EX = β1, EX
2 = β2.

Let t˜T denote the first row of T (and so, (1− t˜)T is the second row). For given t˜, the
worst-case probabilities of correct detection are

Dwc11 = inf

{
t˜T p

∣∣∣∣∣
n∑
i=1

aipi = α1,

n∑
i=1

a2i pi = α2, 1
T p = 1, p � 0

}

Dwc22 = inf

{
(1− t˜)T p

∣∣∣∣∣
n∑
i=1

aipi = β1,

n∑
i=1

a2i pi = β2, 1
T p = 1, p � 0

}
.

Using LP duality we can express Dwc11 as the optimal value of the LP

maximize z0 + z1α1 + z2α2
subject to z0 + aiz1 + a

2
i z2 ≤ t˜i, i = 1, . . . , n,

with variables z0, z1, z2 ∈ R. Similarly Dwc22 is the optimal value of the LP
maximize w0 + w1β1 + w2β2
subject to w0 + aiw1 + a

2
iw2 ≤ 1− t˜i, i = 1, . . . , n,

with variables w0, w1, w2 ∈ R. To obtain the minimax detector, we have to maximize
the minimum of Dwc11 and D

wc
22 , i.e., solve the LP

maximize γ
subject to z0 + z1α2 + z2α2 ≥ γ

w0 + β1w1 + β2w2 ≥ γ
z0 + z1ai + z2a

2
i ≤ t˜i, i = 1, . . . , n

w0 + w1ai + w2a
2
i ≤ 1− t˜i, i = 1, . . . , n

0 � t˜ � 1.

The variables are z0, z1, z2, w0, w1, w2 and t˜.

7.4 Chebyshev and Chernoff bounds

In this section we consider two types of classical bounds on the probability of a set,
and show that generalizations of each can be cast as convex optimization problems.
The original classical bounds correspond to simple convex optimization problems
with analytical solutions; the convex optimization formulation of the general cases
allow us to compute better bounds, or bounds for more complex situations.

7.4.1 Chebyshev bounds

Chebyshev bounds give an upper bound on the probability of a set based on known
expected values of certain functions (e.g., mean and variance). The simplest ex-
ample is Markov’s inequality: If X is a random variable on R+ with EX = µ,



7.4 Chebyshev and Chernoff bounds 375

then we have prob(X ≥ 1) ≤ µ, no matter what the distribution of X is. An-
other simple example is Chebyshev’s bound: If X is a random variable on R with
EX = µ and E(X − µ)2 = σ2, then we have prob(|X − µ| ≥ 1) ≤ σ2, again no
matter what the distribution of X is. The idea behind these simple bounds can be
generalized to a setting in which convex optimization is used to compute a bound
on the probability.

Let X be a random variable on S ⊆ Rm, and C ⊆ S be the set for which we
want to bound prob(X ∈ C). Let 1C denote the 0-1 indicator function of the set
C, i.e., 1C(z) = 1 if z ∈ C and 1C(z) = 0 if z 6∈ C.

Our prior knowledge of the distribution consists of known expected values of
some functions:

E fi(X) = ai, i = 1, . . . , n,

where fi : R
m → R. We take f0 to be the constant function with value one, for

which we always have E f0(X) = a0 = 1. Consider a linear combination of the
functions fi, given by

f(z) =

n∑
i=0

xifi(z),

where xi ∈ R, i = 0, . . . , n. From our knowledge of E fi(X), we have E f(X) =
aTx.

Now suppose that f satisfies the condition f(z) ≥ 1C(z) for all z ∈ S, i.e., f
is pointwise greater than or equal to the indicator function of C (on S). Then we
have

E f(X) = aTx ≥ E 1C(X) = prob(X ∈ C).
In other words, aTx is an upper bound on prob(X ∈ C), valid for all distributions
supported on S, with E fi(X) = ai.

We can search for the best such upper bound on prob(X ∈ C), by solving the
problem

minimize x0 + a1x1 + · · ·+ anxn
subject to f(z) =

∑n
i=0 xifi(z) ≥ 1 for z ∈ C

f(z) =
∑n

i=0 xifi(z) ≥ 0 for z ∈ S, z /∈ C,
(7.17)

with variable x ∈ Rn+1. This problem is always convex, since the constraints can
be expressed as

g1(x) = 1− inf
z∈C

f(z) ≤ 0, g2(x) = − inf
z∈S\C

f(z) ≤ 0

(g1 and g2 are convex). The problem (7.17) can also be thought of as a semi-infinite
linear program, i.e., an optimization problem with a linear objective and an infinite
number of linear inequalities, one for each z ∈ S.

In simple cases we can solve the problem (7.17) analytically. As an example, we
take S = R+, C = [1,∞), f0(z) = 1, and f1(z) = z, with E f1(X) = EX = µ ≤ 1
as our prior information. The constraint f(z) ≥ 0 for z ∈ S reduces to x0 ≥ 0,
x1 ≥ 0. The constraint f(z) ≥ 1 for z ∈ C, i.e., x0 + x1z ≥ 1 for all z ≥ 1, reduces
to x0 + x1 ≥ 1. The problem (7.17) is then

minimize x0 + µx1
subject to x0 ≥ 0, x1 ≥ 0

x0 + x1 ≥ 1.



376 7 Statistical estimation

Since 0 ≤ µ ≤ 1, the optimal point for this simple LP is x0 = 0, x1 = 1. This gives
the classical Markov bound prob(X ≥ 1) ≤ µ.

In other cases we can solve the problem (7.17) using convex optimization.

Remark 7.1 Duality and the Chebyshev bound problem. The Chebyshev bound prob-
lem (7.17) determines a bound on prob(X ∈ C) for all probability measures that
satisfy the given expected value constraints. Thus we can think of the Chebyshev
bound problem (7.17) as producing a bound on the optimal value of the infinite-
dimensional problem

maximize
∫
C
π(dz)

subject to
∫
S
fi(z)π(dz) = ai, i = 1, . . . , n∫

S
π(dz) = 1

π ≥ 0,
(7.18)

where the variable is the measure π, and π ≥ 0 means that the measure is nonnegative.
Since the Chebyshev problem (7.17) produces a bound on the problem (7.18), it
should not be a surprise that they are related by duality. While semi-infinite and
infinite-dimensional problems are beyond the scope of this book, we can still formally
construct a dual of the problem (7.17), introducing a Lagrange multiplier function
p : S → R, with p(z) the Lagrange multiplier associated with the inequality f(z) ≥ 1
(for z ∈ C) or f(z) ≥ 0 (for z ∈ S\C). Using an integral over z where we would have
a sum in the finite-dimensional case, we arrive at the formal dual

maximize
∫
C
p(z) dz

subject to
∫
S
fi(z)p(z) dz = ai, i = 1, . . . , n∫

S
p(z) dz = 1

p(z) ≥ 0 for all z ∈ S,
where the optimization variable is the function p. This is, essentially, the same
as (7.18).

Probability bounds with known first and second moments

As an example, suppose that S = Rm, and that we are given the first and second
moments of the random variable X:

EX = a ∈ Rm, EXXT = Σ ∈ Sm.
In other words, we are given the expected value of the m functions zi, i = 1, . . . ,m,
and the m(m+1)/2 functions zizj , i, j = 1, . . . ,m, but no other information about
the distribution.

In this case we can express f as the general quadratic function

f(z) = zTPz + 2qT z + r,

where the variables (i.e., the vector x in the discussion above) are P ∈ Sm, q ∈ Rm,
and r ∈ R. From our knowledge of the first and second moments, we find that

E f(X) = E(XTPX + 2qTX + r)

= Etr(PXXT ) + 2E qTX + r

= tr(ΣP ) + 2qT a+ r.



7.4 Chebyshev and Chernoff bounds 377

The constraint that f(z) ≥ 0 for all z can be expressed as the linear matrix in-
equality [

P q
qT r

]
� 0.

In particular, we have P � 0.
Now suppose that the set C is the complement of an open polyhedron,

C = Rm \ P, P = {z | aTi z < bi, i = 1, . . . , k}.

The condition that f(z) ≥ 1 for all z ∈ C is the same as requiring that

aTi z ≥ bi =⇒ zTPz + 2qT z + r ≥ 1

for i = 1, . . . , k. This, in turn, can be expressed as: there exist τ1, . . . , τk ≥ 0 such
that [

P q
qT r − 1

]
� τi

[
0 ai/2

aTi /2 −bi
]
, i = 1, . . . , k.

(See §B.2.)
Putting it all together, the Chebyshev bound problem (7.17) can be expressed

as

minimize tr(ΣP ) + 2qTa+ r

subject to

[
P q
qT r − 1

]
� τi

[
0 ai/2

aTi /2 −bi
]
, i = 1, . . . , k

τi ≥ 0, i = 1, . . . , k[
P q
qT r

]
� 0,

(7.19)

which is a semidefinite program in the variables P , q, r, and τ1, . . . , τk. The
optimal value, say α, is an upper bound on prob(X ∈ C) over all distributions
with mean a and second moment Σ. Or, turning it around, 1−α is a lower bound
on prob(X ∈ P).

Remark 7.2 Duality and the Chebyshev bound problem. The dual SDP associated
with (7.19) can be expressed as

maximize
∑k

i=1
λi

subject to aTi zi ≥ bλi, i = 1, . . . , k∑k
i=1

[
Zi zi
zTi λi

]
�
[

Σ a
aT 1

]
[
Zi zi
zTi λi

]
� 0, i = 1, . . . , k.

The variables are Zi ∈ Sm, zi ∈ Rm, and λi ∈ R, for i = 1, . . . , k. Since the
SDP (7.19) is strictly feasible, strong duality holds and the dual optimum is attained.

We can give an interesting probability interpretation to the dual problem. Suppose
Zi, zi, λi are dual feasible and that the first r components of λ are positive, and the



378 7 Statistical estimation

rest are zero. For simplicity we also assume that
∑k

i=1
λi < 1. We define

xi = (1/λi)zi, i = 1, . . . , r,

w0 =
1

µ

(
a−

r∑
i=1

λixi

)
,

W =
1

µ

(
Σ−

r∑
i=1

λixix
T
i

)
,

where µ = 1−∑k
i=1

λi. With these definitions the dual feasibility constraints can be
expressed as

aTi xi ≥ bi, i = 1, . . . , r
and

r∑
i=1

λi

[
xix

T
i xi

xTi 1

]
+ µ

[
W w0
wT0 1

]
=

[
Σ a
aT 1

]
.

Moreover, from dual feasibility,

µ

[
W w0
wT0 1

]
=

[
Σ a
aT 1

]
−

r∑
i=1

λi

[
xix

T
i xi

xTi 1

]

=

[
Σ a
aT 1

]
−

r∑
i=1

[
(1/λi)ziz

T
i zi

zTi λi

]

�
[

Σ a
aT 1

]
−

r∑
i=1

[
Zi zi
zTi λi

]
� 0.

Therefore, W � w0wT0 , so it can be factored as W − w0wT0 =
∑s

i=1
wiw

T
i . Now

consider a discrete random variable X with the following distribution. If s ≥ 1, we
take

X = xi with probability λi, i = 1, . . . , r
X = w0 +

√
swi with probability µ/(2s), i = 1, . . . , s

X = w0 −√swi with probability µ/(2s), i = 1, . . . , s.
If s = 0, we take

X = xi with probability λi, i = 1, . . . , r
X = w0 with probability µ.

It is easily verified that EX = a and EXXT = Σ, i.e., the distribution matches the
given moments. Furthermore, since xi ∈ C,

prob(X ∈ C) ≥
r∑
i=1

λi.

In particular, by applying this interpretation to the dual optimal solution, we can
construct a distribution that satisfies the Chebyshev bound from (7.19) with equality,
which shows that the Chebyshev bound is sharp for this case.



7.4 Chebyshev and Chernoff bounds 379

7.4.2 Chernoff bounds

Let X be a random variable on R. The Chernoff bound states that

prob(X ≥ u) ≤ inf
λ≥0

E eλ(X−u),

which can be expressed as

logprob(X ≥ u) ≤ inf
λ≥0

{−λu+ logE eλX}. (7.20)

Recall (from example 3.41, page 106) that the righthand term, logE eλX , is called
the cumulant generating function of the distribution, and is always convex, so the
function to be minimized is convex. The bound (7.20) is most useful in cases when
the cumulant generating function has an analytical expression, and the minimiza-
tion over λ can be carried out analytically.

For example, if X is Gaussian with zero mean and unit variance, the cumulant
generating function is

logE eλX = λ2/2,

and the infimum over λ ≥ 0 of −λu + λ2/2 occurs with λ = u (if u ≥ 0), so the
Chernoff bound is (for u ≥ 0)

prob(X ≥ u) ≤ e−u2/2.

The idea behind the Chernoff bound can be extended to a more general setting,
in which convex optimization is used to compute a bound on the probability of a
set in Rm. Let C ⊆ Rm, and as in the description of Chebyshev bounds above,
let 1C denote the 0-1 indicator function of C. We will derive an upper bound on
prob(X ∈ C). (In principle we can compute prob(X ∈ C), for example by Monte
Carlo simulation, or numerical integration, but either of these can be a daunting
computational task, and neither method produces guaranteed bounds.)

Let λ ∈ Rm and µ ∈ R, and consider the function f : Rm → R given by

f(z) = eλ
T z+µ.

As in the development of Chebyshev bounds, if f satisfies f(z) ≥ 1C(z) for all z,
then we can conclude that

prob(X ∈ C) = E 1C(X) ≤ E f(X).

Clearly we have f(z) ≥ 0 for all z; to have f(z) ≥ 1 for z ∈ C is the same as
λT z + µ ≥ 0 for all z ∈ C, i.e., −λT z ≤ µ for all z ∈ C. Thus, if −λT z ≤ µ for all
z ∈ C, we have the bound

prob(X ∈ C) ≤ E exp(λTX + µ),

or, taking logarithms,

logprob(X ∈ C) ≤ µ+ logE exp(λTX).



380 7 Statistical estimation

From this we obtain a general form of Chernoff’s bound:

logprob(X ∈ C) ≤ inf{µ+ logE exp(λTX) | − λT z ≤ µ for all z ∈ C}
= inf

λ

(
sup
z∈C

(−λT z) + logE exp(λTX)
)

= inf
(
SC(−λ) + logE exp(λTX)

)
,

where SC is the support function of C. Note that the second term, logE exp(λ
TX),

is the cumulant generating function of the distribution, and is always convex (see
example 3.41, page 106). Evaluating this bound is, in general, a convex optimiza-
tion problem.

Chernoff bound for a Gaussian variable on a polyhedron

As a specific example, suppose that X is a Gaussian random vector on Rm with
zero mean and covariance I, so its cumulant generating function is

logE exp(λTX) = λTλ/2.

We take C to be a polyhedron described by inequalities:

C = {x | Ax � b},

which we assume is nonempty.
For use in the Chernoff bound, we use a dual characterization of the support

function SC :

SC(y) = sup{yTx | Ax � b}
= − inf{−yTx | Ax � b}
= − sup{−bTu | ATu = y, u � 0}
= inf{bTu | ATu = y, u � 0}

where in the third line we use LP duality:

inf{cTx | Ax � b} = sup{−bTu | ATu+ c = 0, u � 0}

with c = −y. Using this expression for SC in the Chernoff bound we obtain

logprob(X ∈ C) ≤ inf
λ

(
SC(−λ) + logE exp(λTX)

)
= inf

λ
inf
u
{bTu+ λTλ/2 ∣∣ u � 0, ATu+ λ = 0}.

Thus, the Chernoff bound on prob(X ∈ C) is the exponential of the optimal value
of the QP

minimize bTu+ λTλ/2
subject to u � 0, ATu+ λ = 0, (7.21)

where the variables are u and λ.



7.4 Chebyshev and Chernoff bounds 381

This problem has an interesting geometric interpretation. It is equivalent to

minimize bTu+ (1/2)‖ATu‖22
subject to u � 0,

which is the dual of
maximize −(1/2)‖x‖22
subject to Ax � b.

In other words, the Chernoff bound is

prob(X ∈ C) ≤ exp(−dist(0, C)2/2), (7.22)
where dist(0, C) is the Euclidean distance of the origin to C.

Remark 7.3 The bound (7.22) can also be derived without using Chernoff’s inequality.
If the distance between 0 and C is d, then there is a halfspace H = {z | aT z ≥ d},
with ‖a‖2 = 1, that contains C. The random variable aTX is N (0, 1), so

prob(X ∈ C) ≤ prob(X ∈ H) = Φ(−d),
where Φ is the cumulative distribution function of a zero mean, unit variance Gaus-

sian. Since Φ(−d) ≤ e−d2/2 for d ≥ 0, this bound is at least as sharp as the Chernoff
bound (7.22).

7.4.3 Example

In this section we illustrate the Chebyshev and Chernoff probability bounding
methods with a detection example. We have a set of m possible symbols or signals
s ∈ {s1, s2, . . . , sm} ⊆ Rn, which is called the signal constellation. One of these
signals is transmitted over a noisy channel. The received signal is x = s + v,
where v is a noise, modeled as a random variable. We assume that E v = 0 and
E vvT = σ2I, i.e., the noise components v1, . . . , vn are zero mean, uncorrelated,
and have variance σ2. The receiver must estimate which signal was sent on the
basis of the received signal x = s+ v. The minimum distance detector chooses as
estimate the symbol sk closest (in Euclidean norm) to x. (If the noise v is Gaussian,
then minimum distance decoding is the same as maximum likelihood decoding.)

If the signal sk is transmitted, correct detection occurs if sk is the estimate,
given x. This occurs when the signal sk is closer to x than the other signals, i.e.,

‖x− sk‖2 < ‖x− sj‖2, j 6= k.
Thus, correct detection of symbol sk occurs if the random variable v satisfies the
linear inequalities

2(sj − sk)T (sk + v) < ‖sj‖22 − ‖sk‖22, j 6= k.
These inequalities define the Voronoi region Vk of sk in the signal constellation,
i.e., the set of points closer to sk than any other signal in the constellation. The
probability of correct detection of sk is prob(sk + v ∈ Vk).

Figure 7.5 shows a simple example with m = 7 signals, with dimension n = 2.



382 7 Statistical estimation

s1

s2
s3

s4

s5
s6

s7

Figure 7.5 A constellation of 7 signals s1, . . . , s7 ∈ R2, shown as small circles.
The line segments show the boundaries of the corresponding Voronoi regions.
The minimum distance detector selects symbol sk when the received signal
lies closer to sk than to any of the other points, i.e., if the received signal is
in the interior of the Voronoi region around symbol sk. The circles around
each point have radius one, to show the scale.

Chebyshev bounds

The SDP bound (7.19) provides a lower bound on the probability of correct detec-
tion, and is plotted in figure 7.6, as a function of the noise standard deviation σ,
for the three symbols s1, s2, and s3. These bounds hold for any noise distribution
with zero mean and covariance σ2I. They are tight in the sense that there exists
a noise distribution with zero mean and covariance Σ = σ2I, for which the proba-
bility of error is equal to the lower bound. This is illustrated in figure 7.7, for the
first Voronoi set, and σ = 1.

Chernoff bounds

We use the same example to illustrate the Chernoff bound. Here we assume that the
noise is Gaussian, i.e., v ∼ N (0, σ2I). If symbol sk is transmitted, the probability
of correct detection is the probability that sk + v ∈ Vk. To find a lower bound for
this probability, we use the QP (7.21) to compute upper bounds on the probability
that the ML detector selects symbol i, i = 1, . . . ,m, i 6= k. (Each of these upper
bounds is related to the distance of sk to the Voronoi set Vi.) Adding these upper
bounds on the probabilities of mistaking sk for si, we obtain an upper bound on
the probability of error, and therefore, a lower bound on the probability of correct
detection of symbol sk. The resulting lower bound, for s1, is shown in figure 7.8,
along with an estimate of the probability of correct detection obtained using Monte
Carlo analysis.



7.4 Chebyshev and Chernoff bounds 383

1

2

3

σ

p
ro
b
ab
il
it
y
of

co
rr
ec
t
d
et
ec
ti
on

0 0.5 1 1.5 2 2.5
0

0.2

0.4

0.6

0.8

1

Figure 7.6 Chebyshev lower bounds on the probability of correct detection
for symbols s1, s2, and s3. These bounds are valid for any noise distribution
that has zero mean and covariance σ2I.

s1

s2
s3

s4

s5
s6

s7

Figure 7.7 The Chebyshev lower bound on the probability of correct detec-
tion of symbol 1 is equal to 0.2048 when σ = 1. This bound is achieved by
the discrete distribution illustrated in the figure. The solid circles are the
possible values of the received signal s1 + v. The point in the center of the
ellipse has probability 0.2048. The five points on the boundary have a total
probability 0.7952. The ellipse is defined by xTPx + 2qTx + r = 1, where
P , q, and r are the optimal solution of the SDP (7.19).



384 7 Statistical estimation

σ

p
ro
b
ab
il
it
y
of

co
rr
ec
t
d
et
ec
ti
on

0.2 0.3 0.4 0.5
0.9

0.95

1

Figure 7.8 The Chernoff lower bound (solid line) and a Monte Carlo esti-
mate (dashed line) of the probability of correct detection of symbol s1, as
a function of σ. In this example the noise is Gaussian with zero mean and
covariance σ2I.

7.5 Experiment design

We consider the problem of estimating a vector x ∈ Rn from measurements or
experiments

yi = a
T
i x+ wi, i = 1, . . . ,m,

where wi is measurement noise. We assume that wi are independent Gaussian
random variables with zero mean and unit variance, and that the measurement
vectors a1, . . . , am span R

n. The maximum likelihood estimate of x, which is the
same as the minimum variance estimate, is given by the least-squares solution

xˆ =

(
m∑
i=1

aia
T
i

)−1 m∑
i=1

yiai.

The associated estimation error e = xˆ− x has zero mean and covariance matrix

E = E eeT =

(
m∑
i=1

aia
T
i

)−1
.

The matrix E characterizes the accuracy of the estimation, or the informativeness
of the experiments. For example the α-confidence level ellipsoid for x is given by

E = {z | (z − xˆ)TE−1(z − xˆ) ≤ β},
where β is a constant that depends on n and α.

We suppose that the vectors a1, . . . , am, which characterize the measurements,
can be chosen among p possible test vectors v1, . . . , vp ∈ Rn, i.e., each ai is one of



7.5 Experiment design 385

the vj . The goal of experiment design is to choose the vectors ai, from among the
possible choices, so that the error covariance E is small (in some sense). In other
words, each of m experiments or measurements can be chosen from a fixed menu
of p possible experiments; our job is to find a set of measurements that (together)
are maximally informative.

Let mj denote the number of experiments for which ai is chosen to have the
value vj , so we have

m1 + · · ·+mp = m.
We can express the error covariance matrix as

E =

(
m∑
i=1

aia
T
i

)−1
=

 p∑
j=1

mjvjv
T
j

−1 .
This shows that the error covariance depends only on the numbers of each type of
experiment chosen (i.e., m1, . . . ,mp).

The basic experiment design problem is as follows. Given the menu of possible
choices for experiments, i.e., v1, . . . , vp, and the total number m of experiments to
be carried out, choose the numbers of each type of experiment, i.e., m1, . . . ,mp,
to make the error covariance E small (in some sense). The variables m1, . . . ,mp
must, of course, be integers and sum to m, the given total number of experiments.
This leads to the optimization problem

minimize (w.r.t. Sn+) E =
(∑p

j=1mjvjv
T
j

)−1
subject to mi ≥ 0, m1 + · · ·+mp = m

mi ∈ Z,
(7.23)

where the variables are the integers m1, . . . ,mp.
The basic experiment design problem (7.23) is a vector optimization problem

over the positive semidefinite cone. If one experiment design results in E, and
another in E˜, with E � E˜, then certainly the first experiment design is as good
as or better than the second. For example, the confidence ellipsoid for the first
experiment design (translated to the origin for comparison) is contained in the
confidence ellipsoid of the second. We can also say that the first experiment design
allows us to estimate qTx better (i.e., with lower variance) than the second experi-
ment design, for any vector q, since the variance of our estimate of qTx is given by
qTEq for the first experiment design and qT E˜q for the second. We will see below
several common scalarizations for the problem.

7.5.1 The relaxed experiment design problem

The basic experiment design problem (7.23) can be a hard combinatorial problem
when m, the total number of experiments, is comparable to n, since in this case
the mi are all small integers. In the case when m is large compared to n, however,
a good approximate solution of (7.23) can be found by ignoring, or relaxing, the
constraint that the mi are integers. Let λi = mi/m, which is the fraction of



386 7 Statistical estimation

the total number of experiments for which aj = vi, or the relative frequency of
experiment i. We can express the error covariance in terms of λi as

E =
1

m

(
p∑
i=1

λiviv
T
i

)−1
. (7.24)

The vector λ ∈ Rp satisfies λ � 0, 1Tλ = 1, and also, each λi is an integer multiple
of 1/m. By ignoring this last constraint, we arrive at the problem

minimize (w.r.t. Sn+) E = (1/m)
(∑p

i=1 λiviv
T
i

)−1
subject to λ � 0, 1Tλ = 1, (7.25)

with variable λ ∈ Rp. To distinguish this from the original combinatorial experi-
ment design problem (7.23), we refer to it as the relaxed experiment design problem.
The relaxed experiment design problem (7.25) is a convex optimization problem,
since the objective E is an Sn+-convex function of λ.

Several statements can be made about the relation between the (combinato-
rial) experiment design problem (7.23) and the relaxed problem (7.25). Clearly
the optimal value of the relaxed problem provides a lower bound on the optimal
value of the combinatorial one, since the combinatorial problem has an additional
constraint. From a solution of the relaxed problem (7.25) we can construct a sub-
optimal solution of the combinatorial problem (7.23) as follows. First, we apply
simple rounding to get

mi = round(mλi), i = 1, . . . , p.

Corresponding to this choice of m1, . . . ,mp is the vector λ˜,

λ˜i = (1/m)round(mλi), i = 1, . . . , p.

The vector λ˜ satisfies the constraint that each entry is an integer multiple of 1/m.
Clearly we have |λi − λ˜i| ≤ 1/(2m), so for m large, we have λ ≈ λ˜. This implies
that the constraint 1T λ˜ = 1 is nearly satisfied, for large m, and also that the error
covariance matrices associated with λ˜ and λ are close.

We can also give an alternative interpretation of the relaxed experiment design
problem (7.25). We can interpret the vector λ ∈ Rp as defining a probability
distribution on the experiments v1, . . . , vp. Our choice of λ corresponds to a random
experiment : each experiment ai takes the form vj with probability λj .

In the rest of this section, we consider only the relaxed experiment design
problem, so we drop the qualifier ‘relaxed’ in our discussion.

7.5.2 Scalarizations

Several scalarizations have been proposed for the experiment design problem (7.25),
which is a vector optimization problem over the positive semidefinite cone.



7.5 Experiment design 387

D-optimal design

The most widely used scalarization is calledD-optimal design, in which we minimize
the determinant of the error covariance matrix E. This corresponds to designing
the experiment to minimize the volume of the resulting confidence ellipsoid (for
a fixed confidence level). Ignoring the constant factor 1/m in E, and taking the
logarithm of the objective, we can pose this problem as

minimize log det
(∑p

i=1 λiviv
T
i

)−1
subject to λ � 0, 1Tλ = 1, (7.26)

which is a convex optimization problem.

E-optimal design

In E-optimal design, we minimize the norm of the error covariance matrix, i.e.,
the maximum eigenvalue of E. Since the diameter (twice the longest semi-axis)

of the confidence ellipsoid E is proportional to ‖E‖1/22 , minimizing ‖E‖2 can be
interpreted geometrically as minimizing the diameter of the confidence ellipsoid.
E-optimal design can also be interpreted as minimizing the maximum variance of
qT e, over all q with ‖q‖2 = 1.

The E-optimal experiment design problem is

minimize
∥∥∥(∑pi=1 λivivTi )−1∥∥∥

2
subject to λ � 0, 1Tλ = 1.

The objective is a convex function of λ, so this is a convex problem.
The E-optimal experiment design problem can be cast as an SDP

maximize t
subject to

∑p
i=1 λiviv

T
i � tI

λ � 0, 1Tλ = 1,
(7.27)

with variables λ ∈ Rp and t ∈ R.

A-optimal design

In A-optimal experiment design, we minimize trE, the trace of the covariance
matrix. This objective is simply the mean of the norm of the error squared:

E ‖e‖22 = Etr(eeT ) = trE.
The A-optimal experiment design problem is

minimize tr
(∑p

i=1 λiviv
T
i

)−1
subject to λ � 0, 1Tλ = 1. (7.28)

This, too, is a convex problem. Like the E-optimal experiment design problem, it
can be cast as an SDP:

minimize 1Tu

subject to

[ ∑p
i=1 λiviv

T
i ek

eTk uk

]
� 0, k = 1, . . . , n

λ � 0, 1Tλ = 1,



388 7 Statistical estimation

where the variables are u ∈ Rn and λ ∈ Rp, and here, ek is the kth unit vector.

Optimal experiment design and duality

The Lagrange duals of the three scalarizations have an interesting geometric mean-
ing.

The dual of the D-optimal experiment design problem (7.26) can be expressed
as

maximize log detW + n log n
subject to vTi Wvi ≤ 1, i = 1, . . . , p,

with variable W ∈ Sn and domain Sn++ (see exercise 5.10). This dual problem
has a simple interpretation: The optimal solution W ⋆ determines the minimum
volume ellipsoid, centered at the origin, given by {x | xTW ⋆x ≤ 1}, that contains
the points v1, . . . , vp. (See also the discussion of problem (5.14) on page 222.) By
complementary slackness,

λ⋆i (1− vTi W ⋆vi) = 0, i = 1, . . . , p, (7.29)

i.e., the optimal experiment design only uses the experiments vi which lie on the
surface of the minimum volume ellipsoid.

The duals of the E-optimal and A-optimal design problems can be given a
similar interpretation. The duals of problems (7.27) and (7.28) can be expressed
as

maximize trW
subject to vTi Wvi ≤ 1, i = 1, . . . , p

W � 0,
(7.30)

and
maximize (trW 1/2)2

subject to vTi Wvi ≤ 1, i = 1, . . . , p,
(7.31)

respectively. The variable in both problems is W ∈ Sn. In the second problem
there is an implicit constraint W ∈ Sn+. (See exercises 5.40 and 5.10.)

As for the D-optimal design, the optimal solution W ⋆ determines a minimal
ellipsoid {x | xTW ⋆x ≤ 1} that contains the points v1, . . . , vp. Moreover W ⋆ and
λ⋆ satisfy the complementary slackness conditions (7.29), i.e., the optimal design
only uses experiments vi that lie on the surface of the ellipsoid defined by W

⋆.

Experiment design example

We consider a problem with x ∈ R2, and p = 20. The 20 candidate measurement
vectors ai are shown as circles in figure 7.9. The origin is indicated with a cross.
The D-optimal experiment has only two nonzero λi, indicated as solid circles in
figure 7.9. The E-optimal experiment has two nonzero λi, indicated as solid circles
in figure 7.10. The A-optimal experiment has three nonzero λi, indicated as solid
circles in figure 7.11. We also show the three ellipsoids {x | xTW ⋆x ≤ 1} associated
with the dual optimal solutions W ⋆. The resulting 90% confidence ellipsoids are
shown in figure 7.12, along with the confidence ellipsoid for the ‘uniform’ design,
with equal weight λi = 1/p on all experiments.



7.5 Experiment design 389

λ1 = 0.5

λ2 = 0.5

Figure 7.9 Experiment design example. The 20 candidate measurement vec-
tors are indicated with circles. The D-optimal design uses the two measure-
ment vectors indicated with solid circles, and puts an equal weight λi = 0.5
on each of them. The ellipsoid is the minimum volume ellipsoid centered at
the origin, that contains the points vi.

λ2 = 0.2

λ3 = 0.8

Figure 7.10 The E-optimal design uses two measurement vectors. The
dashed lines are (part of) the boundary of the ellipsoid {x | xTW ⋆x ≤ 1}
where W ⋆ is the solution of the dual problem (7.30).

λ1 = 0.30

λ2 = 0.38

λ3 = 0.32

Figure 7.11 The A-optimal design uses three measurement vectors. The
dashed line shows the ellipsoid {x | xTW ⋆x ≤ 1} associated with the solution
of the dual problem (7.31).



390 7 Statistical estimation

A uniform

D

E

Figure 7.12 Shape of the 90% confidence ellipsoids forD-optimal, A-optimal,
E-optimal, and uniform designs.

7.5.3 Extensions

Resource limits

Suppose that associated with each experiment is a cost ci, which could represent
the economic cost, or time required, to carry out an experiment with vi. The total
cost, or time required (if the experiments are carried out sequentially) is then

m1c1 + · · ·+mpcp = mcTλ.
We can add a limit on total cost by adding the linear inequality mcTλ ≤ B, where
B is a budget, to the basic experiment design problem. We can add multiple linear
inequalities, representing limits on multiple resources.

Multiple measurements per experiment

We can also consider a generalization in which each experiment yields multiple
measurements. In other words, when we carry out an experiment using one of the
possible choices, we obtain several measurements. To model this situation we can
use the same notation as before, with vi as matrices in R

n×ki :

vi =
[
ui1 · · · uiki

]
,

where ki is the number of (scalar) measurements obtained when the experiment vi
is carried out. The error covariance matrix, in this more complicated setup, has
the exact same form.

In conjunction with additional linear inequalities representing limits on cost or
time, we can model discounts or time savings associated with performing groups
of measurements simultaneously. Suppose, for example, that the cost of simulta-
neously making (scalar) measurements v1 and v2 is less than the sum of the costs



7.5 Experiment design 391

of making them separately. We can take v3 to be the matrix

v3 =
[
v1 v2

]
and assign costs c1, c2, and c3 associated with making the first measurement alone,
the second measurement alone, and the two simultaneously, respectively.

When we solve the experiment design problem, λ1 will give us the fraction of
times we should carry out the first experiment alone, λ2 will give us the fraction
of times we should carry out the second experiment alone, and λ3 will give us
the fraction of times we should carry out the two experiments simultaneously.
(Normally we would expect a choice to be made here; we would not expect to have
λ1 > 0, λ2 > 0, and λ3 > 0.)



392 7 Statistical estimation

Bibliography

ML and MAP estimation, hypothesis testing, and detection are covered in books on
statistics, pattern recognition, statistical signal processing, or communications; see, for
example, Bickel and Doksum [BD77], Duda, Hart, and Stork [DHS99], Scharf [Sch91], or
Proakis [Pro01].

Logistic regression is discussed in Hastie, Tibshirani, and Friedman [HTF01, §4.4]. For
the covariance estimation problem of page 355, see Anderson [And70].

Generalizations of Chebyshev’s inequality were studied extensively in the sixties, by Isii
[Isi64], Marshall and Olkin [MO60], Karlin and Studden [KS66, chapter 12], and others.
The connection with semidefinite programming was made more recently by Bertsimas and
Sethuraman [BS00] and Lasserre [Las02].

The terminology in §7.5 (A-, D-, and E-optimality) is standard in the literature on optimal
experiment design (see, for example, Pukelsheim [Puk93]). The geometric interpretation
of the dual D-optimal design problem is discussed by Titterington [Tit75].



Exercises 393

Exercises

Estimation

7.1 Linear measurements with exponentially distributed noise. Show how to solve the ML
estimation problem (7.2) when the noise is exponentially distributed, with density

p(z) =

{
(1/a)e−z/a z ≥ 0
0 z < 0,

where a > 0.

7.2 ML estimation and ℓ∞-norm approximation. We consider the linear measurement model
y = Ax+ v of page 352, with a uniform noise distribution of the form

p(z) =

{
1/(2α) |z| ≤ α
0 |z| > α.

As mentioned in example 7.1, page 352, any x that satisfies ‖Ax − y‖∞ ≤ α is a ML
estimate.

Now assume that the parameter α is not known, and we wish to estimate α, along with
the parameters x. Show that the ML estimates of x and α are found by solving the
ℓ∞-norm approximation problem

minimize ‖Ax− y‖∞,

where aTi are the rows of A.

7.3 Probit model. Suppose y ∈ {0, 1} is random variable given by

y =

{
1 aTu+ b+ v ≤ 0
0 aTu+ b+ v > 0,

where the vector u ∈ Rn is a vector of explanatory variables (as in the logistic model
described on page 354), and v is a zero mean unit variance Gaussian variable.

Formulate the ML estimation problem of estimating a and b, given data consisting of
pairs (ui, yi), i = 1, . . . , N , as a convex optimization problem.

7.4 Estimation of covariance and mean of a multivariate normal distribution. We consider the
problem of estimating the covariance matrix R and the mean a of a Gaussian probability
density function

pR,a(y) = (2π)
−n/2 det(R)−1/2 exp(−(y − a)TR−1(y − a)/2),

based on N independent samples y1, y2, . . . , yN ∈ Rn.
(a) We first consider the estimation problem when there are no additional constraints

on R and a. Let µ and Y be the sample mean and covariance, defined as

µ =
1

N

N∑
k=1

yk, Y =
1

N

N∑
k=1

(yk − µ)(yk − µ)T .

Show that the log-likelihood function

l(R, a) = −(Nn/2) log(2π)− (N/2) log detR− (1/2)
N∑
k=1

(yk − a)TR−1(yk − a)



394 7 Statistical estimation

can be expressed as

l(R, a) =
N

2

(
−n log(2π)− log detR− tr(R−1Y )− (a− µ)TR−1(a− µ)

)
.

Use this expression to show that if Y ≻ 0, the ML estimates of R and a are unique,
and given by

aml = µ, Rml = Y.

(b) The log-likelihood function includes a convex term (− log detR), so it is not obvi-
ously concave. Show that l is concave, jointly in R and a, in the region defined
by

R � 2Y.
This means we can use convex optimization to compute simultaneous ML estimates
of R and a, subject to convex constraints, as long as the constraints include R � 2Y ,
i.e., the estimate R must not exceed twice the unconstrained ML estimate.

7.5 Markov chain estimation. Consider a Markov chain with n states, and transition proba-
bility matrix P ∈ Rn×n defined as

Pij = prob(y(t+ 1) = i | y(t) = j).
The transition probabilities must satisfy Pij ≥ 0 and

∑n
i=1

Pij = 1, j = 1, . . . , n. We
consider the problem of estimating the transition probabilities, given an observed sample
sequence y(1) = k1, y(2) = k2, . . . , y(N) = kn.

(a) Show that if there are no other prior constraints on Pij , then the ML estimates are

the empirical transition frequencies: Pˆij is the ratio of the number of times the state
transitioned from j into i, divided by the number of times it was j, in the observed
sample.

(b) Suppose that an equilibrium distribution p of the Markov chain is known, i.e., a
vector q ∈ Rn+ satisfying 1T q = 1 and Pq = q. Show that the problem of computing
the ML estimate of P , given the observed sequence and knowledge of q, can be
expressed as a convex optimization problem.

7.6 Estimation of mean and variance. Consider a random variable x ∈ R with density p,
which is normalized, i.e., has zero mean and unit variance. Consider a random variable
y = (x+b)/a obtained by an affine transformation of x, where a > 0. The random variable
y has mean b and variance 1/a2. As a and b vary overR+ andR, respectively, we generate
a family of densities obtained from p by scaling and shifting, uniquely parametrized by
mean and variance.

Show that if p is log-concave, then finding the ML estimate of a and b, given samples
y1, . . . , yn of y, is a convex problem.

As an example, work out an analytical solution for the ML estimates of a and b, assuming
p is a normalized Laplacian density, p(x) = e−2|x|.

7.7 ML estimation of Poisson distributions. Suppose xi, i = 1, . . . , n, are independent random
variables with Poisson distributions

prob(xi = k) =
e−µiµki
k!

,

with unknown means µi. The variables xi represent the number of times that one of n
possible independent events occurs during a certain period. In emission tomography, for
example, they might represent the number of photons emitted by n sources.

We consider an experiment designed to determine the means µi. The experiment involves
m detectors. If event i occurs, it is detected by detector j with probability pji. We assume



Exercises 395

the probabilities pji are given (with pji ≥ 0,
∑m

j=1
pji ≤ 1). The total number of events

recorded by detector j is denoted yj ,

yj =

n∑
i=1

yji, j = 1, . . . ,m.

Formulate the ML estimation problem of estimating the means µi, based on observed
values of yj , j = 1, . . . ,m, as a convex optimization problem.

Hint. The variables yji have Poisson distributions with means pjiµi, i.e.,

prob(yji = k) =
e−pjiµi(pjiµi)

k

k!
.

The sum of n independent Poisson variables with means λ1, . . . , λn has a Poisson distri-
bution with mean λ1 + · · ·+ λn.

7.8 Estimation using sign measurements. We consider the measurement setup

yi = sign(a
T
i x+ bi + vi), i = 1, . . . ,m,

where x ∈ Rn is the vector to be estimated, and yi ∈ {−1, 1} are the measurements. The
vectors ai ∈ Rn and scalars bi ∈ R are known, and vi are IID noises with a log-concave
probability density. (You can assume that aTi x+ bi + vi = 0 does not occur.) Show that
maximum likelihood estimation of x is a convex optimization problem.

7.9 Estimation with unknown sensor nonlinearity. We consider the measurement setup

yi = f(a
T
i x+ bi + vi), i = 1, . . . ,m,

where x ∈ Rn is the vector to be estimated, yi ∈ R are the measurements, ai ∈ Rn,
bi ∈ R are known, and vi are IID noises with log-concave probability density. The function
f : R → R, which represents a measurement nonlinearity, is not known. However, it is
known that f ′(t) ∈ [l, u] for all t, where 0 < l < u are given.
Explain how to use convex optimization to find a maximum likelihood estimate of x, as
well as the function f . (This is an infinite-dimensional ML estimation problem, but you
can be informal in your approach and explanation.)

7.10 Nonparametric distributions on Rk. We consider a random variable x ∈ Rk with values
in a finite set {α1, . . . , αn}, and with distribution

pi = prob(x = αi), i = 1, . . . , n.

Show that a lower bound on the covariance of X,

S � E(X −EX)(X −EX)T ,
is a convex constraint in p.

Optimal detector design

7.11 Randomized detectors. Show that every randomized detector can be expressed as a convex
combination of a set of deterministic detectors: If

T =
[
t1 t2 · · · tn

]
∈ Rm×n

satisfies tk � 0 and 1T tk = 1, then T can be expressed as
T = θ1T1 + · · ·+ θNTN ,



396 7 Statistical estimation

where Ti is a zero-one matrix with exactly one element equal to one per column, and

θi ≥ 0,
∑N

i=1
θi = 1. What is the maximum number of deterministic detectors N we may

need?

We can interpret this convex decomposition as follows. The randomized detector can be
realized as a bank of N deterministic detectors. When we observe X = k, the estimator
chooses a random index from the set {1, . . . , N}, with probability prob(j = i) = θi, and
then uses deterministic detector Tj .

7.12 Optimal action. In detector design, we are given a matrix P ∈ Rn×m (whose columns
are probability distributions), and then design a matrix T ∈ Rm×n (whose columns are
probability distributions), so that D = TP has large diagonal elements (and small off-
diagonal elements). In this problem we study the dual problem: Given P , find a matrix

S ∈ Rm×n (whose columns are probability distributions), so that D˜ = PS ∈ Rn×n has
large diagonal elements (and small off-diagonal elements). To make the problem specific,

we take the objective to be maximizing the minimum element of D˜ on the diagonal.

We can interpret this problem as follows. There are n outcomes, which depend (stochas-
tically) on which of m inputs or actions we take: Pij is the probability that outcome i
occurs, given action j. Our goal is find a (randomized) strategy that, to the extent pos-
sible, causes any specified outcome to occur. The strategy is given by the matrix S: Sji
is the probability that we take action j, when we want outcome i to occur. The matrix
D˜ gives the action error probability matrix: D˜ij is the probability that outcome i occurs,

when we want outcome j to occur. In particular, D˜ii is the probability that outcome i
occurs, when we want it to occur.

Show that this problem has a simple analytical solution. Show that (unlike the corre-
sponding detector problem) there is always an optimal solution that is deterministic.

Hint. Show that the problem is separable in the columns of S.

Chebyshev and Chernoff bounds

7.13 Chebyshev-type inequalities on a finite set. Assume X is a random variable taking values
in the set {α1, α2, . . . , αm}, and let S be a subset of {α1, . . . , αm}. The distribution of X
is unknown, but we are given the expected values of n functions fi:

E fi(X) = bi, i = 1, . . . , n. (7.32)

Show that the optimal value of the LP

minimize x0 +
∑n

i=1
bixi

subject to x0 +
∑n

i=1
fi(α)xi ≥ 1, α ∈ S

x0 +
∑n

i=1
fi(α)xi ≥ 0, α 6∈ S,

with variables x0, . . . , xn, is an upper bound on prob(X ∈ S), valid for all distributions
that satisfy (7.32). Show that there always exists a distribution that achieves the upper
bound.



Chapter 8

Geometric problems

8.1 Projection on a set

The distance of a point x0 ∈ Rn to a closed set C ⊆ Rn, in the norm ‖ · ‖, is
defined as

dist(x0, C) = inf{‖x0 − x‖ | x ∈ C}.
The infimum here is always achieved. We refer to any point z ∈ C which is closest
to x0, i.e., satisfies ‖z − x0‖ = dist(x0, C), as a projection of x0 on C. In general
there can be more than one projection of x0 on C, i.e., several points in C closest
to x0.

In some special cases we can establish that the projection of a point on a set
is unique. For example, if C is closed and convex, and the norm is strictly convex
(e.g., the Euclidean norm), then for any x0 there is always exactly one z ∈ C which
is closest to x0. As an interesting converse, we have the following result: If for every
x0 there is a unique Euclidean projection of x0 on C, then C is closed and convex
(see exercise 8.2).

We use the notation PC : R
n → Rn to denote any function for which PC(x0)

is a projection of x0 on C, i.e., for all x0,

PC(x0) ∈ C, ‖x0 − PC(x0)‖ = dist(x0, C).
In other words, we have

PC(x0) = argmin{‖x− x0‖ | x ∈ C}.
We refer to PC as projection on C.

Example 8.1 Projection on the unit square in R2. Consider the (boundary of the)
unit square in R2, i.e., C = {x ∈ R2 | ‖x‖∞ = 1}. We take x0 = 0.
In the ℓ1-norm, the four points (1, 0), (0,−1), (−1, 0), and (0, 1) are closest to x0 = 0,
with distance 1, so we have dist(x0, C) = 1 in the ℓ1-norm. The same statement holds
for the ℓ2-norm.

In the ℓ∞-norm, all points in C lie at a distance 1 from x0, and dist(x0, C) = 1.



398 8 Geometric problems

Example 8.2 Projection onto rank-k matrices. Consider the set of m × n matrices
with rank less than or equal to k,

C = {X ∈ Rm×n | rankX ≤ k},
with k ≤ min{m,n}, and let X0 ∈ Rm×n. We can find a projection of X0 on
C, in the (spectral or maximum singular value) norm ‖ · ‖2, via the singular value
decomposition. Let

X0 =

r∑
i=1

σiuiv
T
i

be the singular value decomposition of X0, where r = rankX0. Then the matrix

Y =
∑min{k,r}

i=1
σiuiv

T
i is a projection of X0 on C.

8.1.1 Projecting a point on a convex set

If C is convex, then we can compute the projection PC(x0) and the distance
dist(x0, C) by solving a convex optimization problem. We represent the set C
by a set of linear equalities and convex inequalities

Ax = b, fi(x) ≤ 0, i = 1, . . . ,m, (8.1)
and find the projection of x0 on C by solving the problem

minimize ‖x− x0‖
subject to fi(x) ≤ 0, i = 1, . . . ,m

Ax = b,
(8.2)

with variable x. This problem is feasible if and only if C is nonempty; when it is
feasible, its optimal value is dist(x0, C), and any optimal point is a projection of
x0 on C.

Euclidean projection on a polyhedron

The projection of x0 on a polyhedron described by linear inequalities Ax � b can
be computed by solving the QP

minimize ‖x− x0‖22
subject to Ax � b.

Some special cases have simple analytical solutions.

• The Euclidean projection of x0 on a hyperplane C = {x | aTx = b} is given
by

PC(x0) = x0 + (b− aTx0)a/‖a‖22.
• The Euclidean projection of x0 on a halfspace C = {x | aTx ≤ b} is given by

PC(x0) =

{
x0 + (b− aTx0)a/‖a‖22 aTx0 > b
x0 a

Tx0 ≤ b.



8.1 Projection on a set 399

• The Euclidean projection of x0 on a rectangle C = {x | l � x � u} (where
l ≺ u) is given by

PC(x0)k =


lk x0k ≤ lk
x0k lk ≤ x0k ≤ uk
uk x0k ≥ uk.

Euclidean projection on a proper cone

Let x = PK(x0) denote the Euclidean projection of a point x0 on a proper cone K.
The KKT conditions of

minimize ‖x− x0‖22
subject to x �K 0

are given by

x �K 0, x− x0 = z, z �K∗ 0, zTx = 0.

Introducing the notation x+ = x and x− = z, we can express these conditions as

x0 = x+ − x−, x+ �K 0, x− �K∗ 0, xT+x− = 0.

In other words, by projecting x0 on the cone K, we decompose it into the difference
of two orthogonal elements: one nonnegative with respect to K (and which is the
projection of x0 on K), and the other nonnegative with respect to K

∗.
Some specific examples:

• For K = Rn+, we have PK(x0)k = max{x0k, 0}. The Euclidean projection
of a vector onto the nonnegative orthant is found by replacing each negative
component with 0.

• ForK = Sn+, and the Euclidean (or Frobenius) norm ‖·‖F , we have PK(X0) =∑n
i=1max{0, λi}vivTi , where X0 =

∑n
i=1 λiviv

T
i is the eigenvalue decomposi-

tion ofX0. To project a symmetric matrix onto the positive semidefinite cone,
we form its eigenvalue expansion and drop terms associated with negative
eigenvalues. This matrix is also the projection onto the positive semidefinite
cone in the ℓ2-, or spectral norm.

8.1.2 Separating a point and a convex set

Suppose C is a closed convex set described by the equalities and inequalities (8.1).
If x0 ∈ C, then dist(x0, C) = 0, and the optimal point for the problem (8.2) is
x0. If x0 6∈ C then dist(x0, C) > 0, and the optimal value of the problem (8.2) is
positive. In this case we will see that any dual optimal point provides a separating
hyperplane between the point x0 and the set C.

The link between projecting a point on a convex set and finding a hyperplane
that separates them (when the point is not in the set) should not be surprising.
Indeed, our proof of the separating hyperplane theorem, given in §2.5.1, relies on



400 8 Geometric problems

C

x0

PC(x0)

Figure 8.1 A point x0 and its Euclidean projection PC(x0) on a convex set C.
The hyperplane midway between the two, with normal vector PC(x0)− x0,
strictly separates the point and the set. This property does not hold for
general norms; see exercise 8.4.

finding the Euclidean distance between the sets. If PC(x0) denotes the Euclidean
projection of x0 on C, where x0 6∈ C, then the hyperplane

(PC(x0)− x0)T (x− (1/2)(x0 + PC(x0))) = 0
(strictly) separates x0 from C, as illustrated in figure 8.1. In other norms, however,
the clearest link between the projection problem and the separating hyperplane
problem is via Lagrange duality.

We first express (8.2) as

minimize ‖y‖
subject to fi(x) ≤ 0, i = 1, . . . ,m

Ax = b
x0 − x = y

with variables x and y. The Lagrangian of this problem is

L(x, y, λ, µ, ν) = ‖y‖+
m∑
i=1

λifi(x) + ν
T (Ax− b) + µT (x0 − x− y)

and the dual function is

g(λ, µ, ν) =

{
infx

(∑m
i=1 λifi(x) + ν

T (Ax− b) + µT (x0 − x)
) ‖µ‖∗ ≤ 1

−∞ otherwise,
so we obtain the dual problem

maximize µTx0 + infx
(∑m

i=1 λifi(x) + ν
T (Ax− b)− µTx)

subject to λ � 0
‖µ‖∗ ≤ 1,

with variables λ, µ, ν. We can interpret the dual problem as follows. Suppose λ,
µ, ν are dual feasible with a positive dual objective value, i.e., λ � 0, ‖µ‖∗ ≤ 1,



8.1 Projection on a set 401

and

µTx0 − µTx+
m∑
i=1

λifi(x) + ν
T (Ax− b) > 0

for all x. This implies that µTx0 > µ
Tx for x ∈ C, and therefore µ defines a

strictly separating hyperplane. In particular, suppose (8.2) is strictly feasible, so
strong duality holds. If x0 6∈ C, the optimal value is positive, and any dual optimal
solution defines a strictly separating hyperplane.

Note that this construction of a separating hyperplane, via duality, works for
any norm. In contrast, the simple construction described above only works for the
Euclidean norm.

Separating a point from a polyhedron

The dual problem of
minimize ‖y‖
subject to Ax � b

x0 − x = y
is

maximize µTx0 − bTλ
subject to ATλ = µ

‖µ‖∗ ≤ 1
λ � 0

which can be further simplified as

maximize (Ax0 − b)Tλ
subject to ‖ATλ‖∗ ≤ 1

λ � 0.
It is easily verified that if the dual objective is positive, then ATλ is the normal
vector to a separating hyperplane: If Ax � b, then

(ATλ)Tx = λT (Ax) ≤ λT b < λTAx0,
so µ = ATλ defines a separating hyperplane.

8.1.3 Projection and separation via indicator and support functions

The ideas described above in §8.1.1 and §8.1.2 can be expressed in a compact form
in terms of the indicator function IC and the support function SC of the set C,
defined as

SC(x) = sup
y∈C

xT y, IC(x) =

{
0 x ∈ C
+∞ x 6∈ C.

The problem of projecting x0 on a closed convex set C can be expressed compactly
as

minimize ‖x− x0‖
subject to IC(x) ≤ 0,



402 8 Geometric problems

or, equivalently, as

minimize ‖y‖
subject to IC(x) ≤ 0

x0 − x = y
where the variables are x and y. The dual function of this problem is

g(z, λ) = inf
x,y

(‖y‖+ λIC(x) + zT (x0 − x− y))
=

{
zTx0 + infx

(−zTx+ IC(x)) ‖z‖∗ ≤ 1, λ ≥ 0
−∞ otherwise

=

{
zTx0 − SC(z) ‖z‖∗ ≤ 1, λ ≥ 0
−∞ otherwise

so we obtain the dual problem

maximize zTx0 − SC(z)
subject to ‖z‖∗ ≤ 1.

If z is dual optimal with a positive objective value, then zTx0 > z
Tx for all x ∈ C,

i.e., z defines a separating hyperplane.

8.2 Distance between sets

The distance between two sets C and D, in a norm ‖ · ‖, is defined as

dist(C,D) = inf{‖x− y‖ | x ∈ C, y ∈ D}.

The two sets C and D do not intersect if dist(C,D) > 0. They intersect if
dist(C,D) = 0 and the infimum in the definition is attained (which is the case, for
example, if the sets are closed and one of the sets is bounded).

The distance between sets can be expressed in terms of the distance between a
point and a set,

dist(C,D) = dist(0, D − C),
so the results of the previous section can be applied. In this section, however, we
derive results specifically for problems involving distance between sets. This allows
us to exploit the structure of the set C −D, and makes the interpretation easier.

8.2.1 Computing the distance between convex sets

Suppose C and D are described by two sets of convex inequalities

C = {x | fi(x) ≤ 0, i = 1, . . . ,m}, D = {x | gi(x) ≤ 0, i = 1, . . . , p}.



8.2 Distance between sets 403

C

D

Figure 8.2 Euclidean distance between polyhedra C and D. The dashed line
connects the two points in C and D, respectively, that are closest to each
other in Euclidean norm. These points can be found by solving a QP.

(We can include linear equalities, but exclude them here for simplicity.) We can
find dist(C,D) by solving the convex optimization problem

minimize ‖x− y‖
subject to fi(x) ≤ 0, i = 1, . . . ,m

gi(y) ≤ 0, i = 1, . . . , p.
(8.3)

Euclidean distance between polyhedra

Let C and D be two polyhedra described by the sets of linear inequalities A1x � b1
and A2x � b2, respectively. The distance between C and D is the distance between
the closest pair of points, one in C and the other in D, as illustrated in figure 8.2.
The distance between them is the optimal value of the problem

minimize ‖x− y‖2
subject to A1x � b1

A2y � b2.
(8.4)

We can square the objective to obtain an equivalent QP.

8.2.2 Separating convex sets

The dual of the problem (8.3) of finding the distance between two convex sets has
an interesting geometric interpretation in terms of separating hyperplanes between
the sets. We first express the problem in the following equivalent form:

minimize ‖w‖
subject to fi(x) ≤ 0, i = 1, . . . ,m

gi(y) ≤ 0, i = 1, . . . , p
x− y = w.

(8.5)

The dual function is

g(λ, z, µ) = inf
x,y,w

(
‖w‖+

m∑
i=1

λifi(x) +

p∑
i=1

µigi(y) + z
T (x− y − w)

)



404 8 Geometric problems

=

{
infx

(∑m
i=1 λifi(x) + z

Tx
)
+ infy

(∑p
i=1 µigi(y)− zT y

) ‖z‖∗ ≤ 1
−∞ otherwise,

which results in the dual problem

maximize infx
(∑m

i=1 λifi(x) + z
Tx
)
+ infy

(∑p
i=1 µigi(y)− zT y

)
subject to ‖z‖∗ ≤ 1

λ � 0, µ � 0.
(8.6)

We can interpret this geometrically as follows. If λ, µ are dual feasible with a
positive objective value, then

m∑
i=1

λifi(x) + z
Tx+

p∑
i=1

µigi(y)− zT y > 0

for all x and y. In particular, for x ∈ C and y ∈ D, we have zTx− zT y > 0, so we
see that z defines a hyperplane that strictly separates C and D.

Therefore, if strong duality holds between the two problems (8.5) and (8.6)
(which is the case when (8.5) is strictly feasible), we can make the following con-
clusion. If the distance between the two sets is positive, then they can be strictly
separated by a hyperplane.

Separating polyhedra

Applying these duality results to sets defined by linear inequalities A1x � b1 and
A2x � b2, we find the dual problem

maximize −bT1 λ− bT2 µ
subject to AT1 λ+ z = 0

AT2 µ− z = 0
‖z‖∗ ≤ 1
λ � 0, µ � 0.

If λ, µ, and z are dual feasible, then for all x ∈ C, y ∈ D,
zTx = −λTA1x ≥ −λT b1, zT y = µTA2x ≤ µT b2,

and, if the dual objective value is positive,

zTx− zT y ≥ −λT b1 − µT b2 > 0,
i.e., z defines a separating hyperplane.

8.2.3 Distance and separation via indicator and support functions

The ideas described above in §8.2.1 and §8.2.2 can be expressed in a compact form
using indicator and support functions. The problem of finding the distance between
two convex sets can be posed as the convex problem

minimize ‖x− y‖
subject to IC(x) ≤ 0

ID(y) ≤ 0,



8.3 Euclidean distance and angle problems 405

which is equivalent to
minimize ‖w‖
subject to IC(x) ≤ 0

ID(y) ≤ 0
x− y = w.

The dual of this problem is

maximize −SC(−z)− SD(z)
subject to ‖z‖∗ ≤ 1.

If z is dual feasible with a positive objective value, then SD(z) < −SC(−z), i.e.,
sup
x∈D

zTx < inf
x∈C

zTx.

In other words, z defines a hyperplane that strictly separates C and D.

8.3 Euclidean distance and angle problems

Suppose a1, . . . , an is a set of vectors in R
n, which we assume (for now) have known

Euclidean lengths
l1 = ‖a1‖2, . . . , ln = ‖an‖2.

We will refer to the set of vectors as a configuration, or, when they are indepen-
dent, a basis. In this section we consider optimization problems involving various
geometric properties of the configuration, such as the Euclidean distances between
pairs of the vectors, the angles between pairs of the vectors, and various geometric
measures of the conditioning of the basis.

8.3.1 Gram matrix and realizability

The lengths, distances, and angles can be expressed in terms of the Gram matrix
associated with the vectors a1, . . . , an, given by

G = ATA, A =
[
a1 · · · an

]
,

so that Gij = a
T
i aj . The diagonal entries of G are given by

Gii = l
2
i , i = 1, . . . , n,

which (for now) we assume are known and fixed. The distance dij between ai and
aj is

dij = ‖ai − aj‖2
= (l2i + l

2
j − 2aTi aj)1/2

= (l2i + l
2
j − 2Gij)1/2.



406 8 Geometric problems

Conversely, we can express Gij in terms of dij as

Gij =
l2i + l

2
j − d2ij
2

,

which we note, for future reference, is an affine function of d2ij .
The correlation coefficient ρij between (nonzero) ai and aj is given by

ρij =
aTi aj

‖ai‖2‖aj‖2 =
Gij
lilj

,

so that Gij = liljρij is a linear function of ρij . The angle θij between (nonzero) ai
and aj is given by

θij = cos
−1 ρij = cos

−1(Gij/(lilj)),

where we take cos−1 ρ ∈ [0, π]. Thus, we have Gij = lilj cos θij .
The lengths, distances, and angles are invariant under orthogonal transforma-

tions: If Q ∈ Rn×n is orthogonal, then the set of vectors Qai, . . . , Qan has the
same Gram matrix, and therefore the same lengths, distances, and angles.

Realizability

The Gram matrix G = ATA is, of course, symmetric and positive semidefinite. The
converse is a basic result of linear algebra: A matrix G ∈ Sn is the Gram matrix
of a set of vectors a1, . . . , an if and only if G � 0. When G � 0, we can construct
a configuration with Gram matrix G by finding a matrix A with ATA = G. One
solution of this equation is the symmetric squareroot A = G1/2. When G ≻ 0, we
can find a solution via the Cholesky factorization of G: If LLT = G, then we can
take A = LT . Moreover, we can construct all configurations with the given Gram
matrix G, given any one solution A, by orthogonal transformation: If A˜T A˜ = G is
any solution, then A˜ = QA for some orthogonal matrix Q.

Thus, a set of lengths, distances, and angles (or correlation coefficients) is real-
izable, i.e., those of some configuration, if and only if the associated Gram matrix
G is positive semidefinite, and has diagonal elements l21, . . . , l

2
n.

We can use this fact to express several geometric problems as convex optimiza-
tion problems, with G ∈ Sn as the optimization variable. Realizability imposes
the constraint G � 0 and Gii = l2i , i = 1, . . . , n; we list below several other convex
constraints and objectives.

Angle and distance constraints

We can fix an angle to have a certain value, θij = α, via the linear equality
constraint Gij = lilj cosα. More generally, we can impose a lower and upper
bound on an angle, α ≤ θij ≤ β, by the constraint

lilj cosα ≥ Gij ≥ lilj cosβ,

which is a pair of linear inequalities on G. (Here we use the fact that cos−1 is
monotone decreasing.) We can maximize or minimize a particular angle θij , by
minimizing or maximizing Gij (again using monotonicity of cos

−1).



8.3 Euclidean distance and angle problems 407

In a similar way we can impose constraints on the distances. To require that
dij lies in an interval, we use

dmin ≤ dij ≤ dmax ⇐⇒ d2min ≤ d2ij ≤ d2max
⇐⇒ d2min ≤ l2i + l2j − 2Gij ≤ d2max,

which is a pair of linear inequalities on G. We can minimize or maximize a distance,
by minimizing or maximizing its square, which is an affine function of G.

As a simple example, suppose we are given ranges (i.e., an interval of possible
values) for some of the angles and some of the distances. We can then find the
minimum and maximum possible value of some other angle, or some other distance,
over all configurations, by solving two SDPs. We can reconstruct the two extreme
configurations by factoring the resulting optimal Gram matrices.

Singular value and condition number constraints

The singular values of A, σ1 ≥ · · · ≥ σn, are the squareroots of the eigenvalues
λ1 ≥ · · · ≥ λn of G. Therefore σ21 is a convex function of G, and σ2n is a concave
function of G. Thus we can impose an upper bound on the maximum singular value
of A, or minimize it; we can impose a lower bound on the minimum singular value,
or maximize it. The condition number of A, σ1/σn, is a quasiconvex function of G,
so we can impose a maximum allowable value, or minimize it over all configurations
that satisfy the other geometric constraints, by quasiconvex optimization.

Roughly speaking, the constraints we can impose as convex constraints on G
are those that require a1, . . . , an to be a well conditioned basis.

Dual basis

When G ≻ 0, a1, . . . , an form a basis forRn. The associated dual basis is b1, . . . , bn,
where

bTi aj =

{
1 i = j
0 i 6= j.

The dual basis vectors b1, . . . , bn are simply the rows of the matrix A
−1. As a

result, the Gram matrix associated with the dual basis is G−1.
We can express several geometric conditions on the dual basis as convex con-

straints on G. The (squared) lengths of the dual basis vectors,

‖bi‖22 = eTi G−1ei,

are convex functions of G, and so can be minimized. The trace of G−1, another
convex function of G, gives the sum of the squares of the lengths of the dual basis
vectors (and is another measure of a well conditioned basis).

Ellipsoid and simplex volume

The volume of the ellipsoid {Au | ‖u‖2 ≤ 1}, which gives another measure of how
well conditioned the basis is, is given by

γ(det(ATA))1/2 = γ(detG)1/2,



408 8 Geometric problems

where γ is the volume of the unit ball in Rn. The log volume is therefore log γ +
(1/2) log detG, which is a concave function of G. We can therefore maximize the
volume of the image ellipsoid, over a convex set of configurations, by maximizing
log detG.

The same holds for any set in Rn. The volume of the image under A is its
volume, multiplied by the factor (detG)1/2. For example, consider the image under
A of the unit simplex conv{0, e1, . . . , en}, i.e., the simplex conv{0, a1, . . . , an}.
The volume of this simplex is given by γ(detG)1/2, where γ is the volume of the
unit simplex in Rn. We can maximize the volume of this simplex by maximizing
log detG.

8.3.2 Problems involving angles only

Suppose we only care about the angles (or correlation coefficients) between the
vectors, and do not specify the lengths or distances between them. In this case it is
intuitively clear that we can simply assume the vectors ai have length li = 1. This
is easily verified: The Gram matrix has the form G = diag(l)C diag(l), where l
is the vector of lengths, and C is the correlation matrix, i.e., Cij = cos θij . It
follows that if G � 0 for any set of positive lengths, then G � 0 for all sets of
positive lengths, and in particular, this occurs if and only if C � 0 (which is the
same as assuming that all lengths are one). Thus, a set of angles θij ∈ [0, π],
i, j = 1, . . . , n is realizable if and only if C � 0, which is a linear matrix inequality
in the correlation coefficients.

As an example, suppose we are given lower and upper bounds on some of the
angles (which is equivalent to imposing lower and upper bounds on the correlation
coefficients). We can then find the minimum and maximum possible value of some
other angle, over all configurations, by solving two SDPs.

Example 8.3 Bounding correlation coefficients. We consider an example inR4, where
we are given

0.6 ≤ ρ12 ≤ 0.9, 0.8 ≤ ρ13 ≤ 0.9,
0.5 ≤ ρ24 ≤ 0.7, −0.8 ≤ ρ34 ≤ −0.4. (8.7)

To find the minimum and maximum possible values of ρ14, we solve the two SDPs

minimize/maximize ρ14
subject to (8.7) 1 ρ12 ρ13 ρ14ρ12 1 ρ23 ρ24ρ13 ρ23 1 ρ34

ρ14 ρ24 ρ34 1

 � 0,
with variables ρ12, ρ13, ρ14, ρ23, ρ24, ρ34. The minimum and maximum values (to two
significant digits) are −0.39 and 0.23, with corresponding correlation matrices 1.00 0.60 0.87 −0.390.60 1.00 0.33 0.500.87 0.33 1.00 −0.55

−0.39 0.50 −0.55 1.00

 ,
 1.00 0.71 0.80 0.230.71 1.00 0.31 0.590.80 0.31 1.00 −0.40

0.23 0.59 −0.40 1.00

 .



8.3 Euclidean distance and angle problems 409

8.3.3 Euclidean distance problems

In a Euclidean distance problem, we are concerned only with the distances between
the vectors, dij , and do not care about the lengths of the vectors, or about the angles
between them. These distances, of course, are invariant not only under orthogonal
transformations, but also translation: The configuration a˜1 = a1+b, . . . , a˜n = an+b
has the same distances as the original configuration, for any b ∈ Rn. In particular,
for the choice

b = −(1/n)
n∑
i=1

ai = −(1/n)A1,

we see that a˜i have the same distances as the original configuration, and also satisfy∑n
i=1 a˜i = 0. It follows that in a Euclidean distance problem, we can assume,

without any loss of generality, that the average of the vectors a1, . . . , an is zero,
i.e., A1 = 0.

We can solve Euclidean distance problems by considering the lengths (which
cannot occur in the objective or constraints of a Euclidean distance problem) as
free variables in the optimization problem. Here we rely on the fact that there is
a configuration with distances dij ≥ 0 if and only if there are lengths l1, . . . , ln for
which G � 0, where Gij = (l2i + l2j − d2ij)/2.

We define z ∈ Rn as zi = l2i , and D ∈ Sn by Dij = d2ij (with, of course,
Dii = 0). The condition that G � 0 for some choice of lengths can be expressed as

G = (z1T + 1zT −D)/2 � 0 for some z � 0, (8.8)

which is an LMI in D and z. A matrix D ∈ Sn, with nonnegative elements,
zero diagonal, and which satisfies (8.8), is called a Euclidean distance matrix. A
matrix is a Euclidean distance matrix if and only if its entries are the squares
of the Euclidean distances between the vectors of some configuration. (Given a
Euclidean distance matrix D and the associated length squared vector z, we can
reconstruct one, or all, configurations with the given pairwise distances using the
method described above.)

The condition (8.8) turns out to be equivalent to the simpler condition that D
is negative semidefinite on 1⊥, i.e.,

(8.8) ⇐⇒ uTDu ≤ 0 for all u with 1Tu = 0
⇐⇒ (I − (1/n)11T )D(I − (1/n)11T ) � 0.

This simple matrix inequality, along with Dij ≥ 0, Dii = 0, is the classical char-
acterization of a Euclidean distance matrix. To see the equivalence, recall that we
can assume A1 = 0, which implies that 1TG1 = 1TATA1 = 0. It follows that
G � 0 if and only if G is positive semidefinite on 1⊥, i.e.,

0 � (I − (1/n)11T )G(I − (1/n)11T )
= (1/2)(I − (1/n)11T )(z1T + 1zT −D)(I − (1/n)11T )
= −(1/2)(I − (1/n)11T )D(I − (1/n)11T ),

which is the simplified condition.



410 8 Geometric problems

In summary, a matrix D ∈ Sn is a Euclidean distance matrix, i.e., gives the
squared distances between a set of n vectors in Rn, if and only if

Dii = 0, i = 1, . . . , n, Dij ≥ 0, i, j = 1, . . . , n,

(I − (1/n)11T )D(I − (1/n)11T ) � 0,
which is a set of linear equalities, linear inequalities, and a matrix inequality in
D. Therefore we can express any Euclidean distance problem that is convex in the
squared distances as a convex problem with variable D ∈ Sn.

8.4 Extremal volume ellipsoids

Suppose C ⊆ Rn is bounded and has nonempty interior. In this section we consider
the problems of finding the maximum volume ellipsoid that lies inside C, and the
minimum volume ellipsoid that covers C. Both problems can be formulated as
convex programming problems, but are tractable only in special cases.

8.4.1 The Lo¨wner-John ellipsoid

The minimum volume ellipsoid that contains a set C is called the Lo¨wner-John
ellipsoid of the set C, and is denoted Elj. To characterize Elj, it will be convenient
to parametrize a general ellipsoid as

E = {v | ‖Av + b‖2 ≤ 1} , (8.9)

i.e., the inverse image of the Euclidean unit ball under an affine mapping. We can
assume without loss of generality that A ∈ Sn++, in which case the volume of E is
proportional to detA−1. The problem of computing the minimum volume ellipsoid
containing C can be expressed as

minimize log detA−1

subject to supv∈C ‖Av + b‖2 ≤ 1, (8.10)

where the variables are A ∈ Sn and b ∈ Rn, and there is an implicit constraint
A ≻ 0. The objective and constraint functions are both convex in A and b, so the
problem (8.10) is convex. Evaluating the constraint function in (8.10), however,
involves solving a convex maximization problem, and is tractable only in certain
special cases.

Minimum volume ellipsoid covering a finite set

We consider the problem of finding the minimum volume ellipsoid that contains
the finite set C = {x1, . . . , xm} ⊆ Rn. An ellipsoid covers C if and only if it
covers its convex hull, so finding the minimum volume ellipsoid that covers C



8.4 Extremal volume ellipsoids 411

is the same as finding the minimum volume ellipsoid containing the polyhedron
conv{x1, . . . , xm}. Applying (8.10), we can write this problem as

minimize log detA−1

subject to ‖Axi + b‖2 ≤ 1, i = 1, . . . ,m (8.11)

where the variables are A ∈ Sn and b ∈ Rn, and we have the implicit constraint A ≻
0. The norm constraints ‖Axi+b‖2 ≤ 1, i = 1, . . . ,m, are convex inequalities in the
variables A and b. They can be replaced with the squared versions, ‖Axi+b‖22 ≤ 1,
which are convex quadratic inequalities in A and b.

Minimum volume ellipsoid covering union of ellipsoids

Minimum volume covering ellipsoids can also be computed efficiently for certain
sets C that are defined by quadratic inequalities. In particular, it is possible to
compute the Lo¨wner-John ellipsoid for a union or sum of ellipsoids.

As an example, consider the problem of finding the minimum volume ellip-
soid Elj, that contains the ellipsoids E1, . . . , Em (and therefore, the convex hull of
their union). The ellipsoids E1, . . . , Em will be described by (convex) quadratic
inequalities:

Ei = {x | xTAix+ 2bTi x+ ci ≤ 0}, i = 1, . . . ,m,
where Ai ∈ Sn++. We parametrize the ellipsoid Elj as

Elj = {x | ‖Ax+ b‖2 ≤ 1}
= {x | xTATAx+ 2(AT b)Tx+ bT b− 1 ≤ 0}

where A ∈ Sn and b ∈ Rn. Now we use a result from §B.2, that Ei ⊆ Elj if and
only if there exists a τ ≥ 0 such that[

A2 − τAi Ab− τbi
(Ab− τbi)T bT b− 1− τci

]
� 0.

The volume of Elj is proportional to detA−1, so we can find the minimum volume
ellipsoid that contains E1, . . . , Em by solving

minimize log detA−1

subject to τ1 ≥ 0, . . . , τm ≥ 0[
A2 − τiAi Ab− τibi
(Ab− τibi)T bT b− 1− τici

]
� 0, i = 1, . . . ,m,

or, replacing the variable b by b˜ = Ab,

minimize log detA−1

subject to τ1 ≥ 0, . . . , τm ≥ 0 A2 − τiAi b˜− τibi 0(b˜− τibi)T −1− τici b˜T
0 b˜ −A2

 � 0, i = 1, . . . ,m,
which is convex in the variables A2 ∈ Sn, b˜, τ1, . . . , τm.



412 8 Geometric problems

Figure 8.3 The outer ellipse is the boundary of the Lo¨wner-John ellipsoid,
i.e., the minimum volume ellipsoid that encloses the points x1, . . . , x6 (shown
as dots), and therefore the polyhedron P = conv{x1, . . . , x6}. The smaller
ellipse is the boundary of the Lo¨wner-John ellipsoid, shrunk by a factor of
n = 2 about its center. This ellipsoid is guaranteed to lie inside P.

Efficiency of Lo¨wner-John ellipsoidal approximation

Let Elj be the Lo¨wner-John ellipsoid of the convex set C ⊆ Rn, which is bounded
and has nonempty interior, and let x0 be its center. If we shrink the Lo¨wner-John
ellipsoid by a factor of n, about its center, we obtain an ellipsoid that lies inside
the set C:

x0 + (1/n)(Elj − x0) ⊆ C ⊆ Elj.
In other words, the Lo¨wner-John ellipsoid approximates an arbitrary convex set,
within a factor that depends only on the dimension n. Figure 8.3 shows a simple
example.

The factor 1/n cannot be improved without additional assumptions on C. Any
simplex in Rn, for example, has the property that its Lo¨wner-John ellipsoid must
be shrunk by a factor n to fit inside it (see exercise 8.13).

We will prove this efficiency result for the special case C = conv{x1, . . . , xm}.
We square the norm constraints in (8.11) and introduce variables A˜ = A2 and
b˜ = Ab, to obtain the problem

minimize log det A˜−1

subject to xi
T A˜xi − 2b˜Txi + b˜T A˜−1b˜ ≤ 1, i = 1, . . . ,m. (8.12)

The KKT conditions for this problem are∑m
i=1 λi(xixi

T − A˜−1b˜b˜T A˜−1) = A˜−1, ∑mi=1 λi(xi − A˜−1b˜) = 0,
λi ≥ 0, xiT A˜xi − 2b˜Txi + b˜T A˜−1b˜ ≤ 1, i = 1, . . . ,m,

λi(1− xiT A˜xi + 2b˜Txi − b˜T A˜−1b˜) = 0, i = 1, . . . ,m.
By a suitable affine change of coordinates, we can assume that A˜ = I and b˜ = 0,
i.e., the minimum volume ellipsoid is the unit ball centered at the origin. The KKT



8.4 Extremal volume ellipsoids 413

conditions then simplify to

m∑
i=1

λixixi
T = I,

m∑
i=1

λixi = 0, λi(1− xiTxi) = 0, i = 1, . . . ,m,

plus the feasibility conditions ‖xi‖2 ≤ 1 and λi ≥ 0. By taking the trace of
both sides of the first equation, and using complementary slackness, we also have∑m

i=1 λi = n.
In the new coordinates the shrunk ellipsoid is a ball with radius 1/n, centered

at the origin. We need to show that

‖x‖2 ≤ 1/n =⇒ x ∈ C = conv{x1, . . . , xm}.

Suppose ‖x‖2 ≤ 1/n. From the KKT conditions, we see that

x =

m∑
i=1

λi(x
Txi)xi =

m∑
i=1

λi(x
Txi + 1/n)xi =

m∑
i=1

µixi, (8.13)

where µi = λi(x
Txi + 1/n). From the Cauchy-Schwartz inequality, we note that

µi = λi(x
Txi + 1/n) ≥ λi(−‖x‖2‖xi‖2 + 1/n) ≥ λi(−1/n+ 1/n) = 0.

Furthermore
m∑
i=1

µi =
m∑
i=1

λi(x
Txi + 1/n) =

m∑
i=1

λi/n = 1.

This, along with (8.13), shows that x is a convex combination of x1, . . . , xm, hence
x ∈ C.

Efficiency of Lo¨wner-John ellipsoidal approximation for symmetric sets

If the set C is symmetric about a point x0, then the factor 1/n can be tightened
to 1/

√
n:

x0 + (1/
√
n)(Elj − x0) ⊆ C ⊆ Elj.

Again, the factor 1/
√
n is tight. The Lo¨wner-John ellipsoid of the cube

C = {x ∈ Rn | − 1 � x � 1}

is the ball with radius
√
n. Scaling down by 1/

√
n yields a ball enclosed in C, and

touching the boundary at x = ±ei.

Approximating a norm by a quadratic norm

Let ‖ · ‖ be any norm on Rn, and let C = {x | ‖x‖ ≤ 1} be its unit ball. Let
Elj = {x | xTAx ≤ 1}, with A ∈ Sn++, be the Lo¨wner-John ellipsoid of C. Since C
is symmetric about the origin, the result above tells us that (1/

√
n)Elj ⊆ C ⊆ Elj.

Let ‖ · ‖lj denote the quadratic norm

‖z‖lj = (zTAz)1/2,



414 8 Geometric problems

whose unit ball is Elj. The inclusions (1/
√
n)Elj ⊆ C ⊆ Elj are equivalent to the

inequalities

‖z‖lj ≤ ‖z‖ ≤
√
n‖z‖lj

for all z ∈ Rn. In other words, the quadratic norm ‖ · ‖lj approximates the norm
‖ · ‖ within a factor of √n. In particular, we see that any norm on Rn can be
approximated within a factor of

√
n by a quadratic norm.

8.4.2 Maximum volume inscribed ellipsoid

We now consider the problem of finding the ellipsoid of maximum volume that lies
inside a convex set C, which we assume is bounded and has nonempty interior. To
formulate this problem, we parametrize the ellipsoid as the image of the unit ball
under an affine transformation, i.e., as

E = {Bu+ d | ‖u‖2 ≤ 1} .

Again it can be assumed that B ∈ Sn++, so the volume is proportional to detB. We
can find the maximum volume ellipsoid inside C by solving the convex optimization
problem

maximize log detB
subject to sup‖u‖2≤1 IC(Bu+ d) ≤ 0

(8.14)

in the variables B ∈ Sn and d ∈ Rn, with implicit constraint B ≻ 0.

Maximum volume ellipsoid in a polyhedron

We consider the case where C is a polyhedron described by a set of linear inequal-
ities:

C = {x | aTi x ≤ bi, i = 1, . . . ,m}.
To apply (8.14) we first express the constraint in a more convenient form:

sup
‖u‖2≤1

IC(Bu+ d) ≤ 0 ⇐⇒ sup
‖u‖2≤1

aTi (Bu+ d) ≤ bi, i = 1, . . . ,m

⇐⇒ ‖Bai‖2 + aTi d ≤ bi, i = 1, . . . ,m.

We can therefore formulate (8.14) as a convex optimization problem in the variables
B and d:

minimize log detB−1

subject to ‖Bai‖2 + aTi d ≤ bi, i = 1, . . . ,m. (8.15)

Maximum volume ellipsoid in an intersection of ellipsoids

We can also find the maximum volume ellipsoid E that lies in the intersection of
m ellipsoids E1, . . . , Em. We will describe E as E = {Bu + d | ‖u‖2 ≤ 1} with
B ∈ Sn++, and the other ellipsoids via convex quadratic inequalities,

Ei = {x | xTAix+ 2bTi x+ ci ≤ 0}, i = 1, . . . ,m,



8.4 Extremal volume ellipsoids 415

where Ai ∈ Sn++. We first work out the condition under which E ⊆ Ei. This occurs
if and only if

sup
‖u‖2≤1

(
(d+Bu)TAi(d+Bu) + 2b

T
i (d+Bu) + ci

)
= dTAid+ 2b

T
i d+ ci + sup

‖u‖2≤1

(
uTBAiBu+ 2(Aid+ bi)

TBu
)

≤ 0.

From §B.1,

sup
‖u‖2≤1

(
uTBAiBu+ 2(Aid+ bi)

TBu
) ≤ −(dTAid+ 2bTi d+ ci)

if and only if there exists a λi ≥ 0 such that[ −λi − dTAid− 2bTi d− ci (Aid+ bi)TB
B(Aid+ bi) λiI −BAiB

]
� 0.

The maximum volume ellipsoid contained in E1, . . . , Em can therefore be found by
solving the problem

minimize log detB−1

subject to

[ −λi − dTAid− 2bTi d− ci (Aid+ bi)TB
B(Aid+ bi) λiI −BAiB

]
� 0, i = 1, . . . ,m,

with variables B ∈ Sn, d ∈ Rn, and λ ∈ Rm, or, equivalently,
minimize log detB−1

subject to

 −λi − ci + bTi A−1i bi 0 (d+A−1i bi)T0 λiI B
d+A−1i bi B A

−1
i

 � 0, i = 1, . . . ,m.
Efficiency of ellipsoidal inner approximations

Approximation efficiency results, similar to the ones for the Lo¨wner-John ellipsoid,
hold for the maximum volume inscribed ellipsoid. If C ⊆ Rn is convex, bounded,
with nonempty interior, then the maximum volume inscribed ellipsoid, expanded
by a factor of n about its center, covers the set C. The factor n can be tightened
to
√
n if the set C is symmetric about a point. An example is shown in figure 8.4.

8.4.3 Affine invariance of extremal volume ellipsoids

The Lo¨wner-John ellipsoid and the maximum volume inscribed ellipsoid are both
affinely invariant. If Elj is the Lo¨wner-John ellipsoid of C, and T ∈ Rn×n is
nonsingular, then the Lo¨wner-John ellipsoid of TC is TElj. A similar result holds
for the maximum volume inscribed ellipsoid.

To establish this result, let E be any ellipsoid that covers C. Then the ellipsoid
TE covers TC. The converse is also true: Every ellipsoid that covers TC has



416 8 Geometric problems

Figure 8.4 The maximum volume ellipsoid (shown shaded) inscribed in a
polyhedron P. The outer ellipse is the boundary of the inner ellipsoid,
expanded by a factor n = 2 about its center. The expanded ellipsoid is
guaranteed to cover P.

the form TE , where E is an ellipsoid that covers C. In other words, the relation
E˜ = TE gives a one-to-one correspondence between the ellipsoids covering TC and
the ellipsoids covering C. Moreover, the volumes of the corresponding ellipsoids are
all related by the ratio | detT |, so in particular, if E has minimum volume among
ellipsoids covering C, then TE has minimum volume among ellipsoids covering TC.

8.5 Centering

8.5.1 Chebyshev center

Let C ⊆ Rn be bounded and have nonempty interior, and x ∈ C. The depth of a
point x ∈ C is defined as

depth(x,C) = dist(x,Rn \ C),

i.e., the distance to the closest point in the exterior of C. The depth gives the
radius of the largest ball, centered at x, that lies in C. A Chebyshev center of the
set C is defined as any point of maximum depth in C:

xcheb(C) = argmaxdepth(x,C) = argmaxdist(x,R
n \ C).

A Chebyshev center is a point inside C that is farthest from the exterior of C; it is
also the center of the largest ball that lies inside C. Figure 8.5 shows an example,
in which C is a polyhedron, and the norm is Euclidean.



8.5 Centering 417

xchebxcheb

Figure 8.5 Chebyshev center of a polyhedron C, in the Euclidean norm. The
center xcheb is the deepest point inside C, in the sense that it is farthest from
the exterior, or complement, of C. The center xcheb is also the center of the
largest Euclidean ball (shown lightly shaded) that lies inside C.

Chebyshev center of a convex set

When the set C is convex, the depth is a concave function for x ∈ C, so computing
the Chebyshev center is a convex optimization problem (see exercise 8.5). More
specifically, suppose C ⊆ Rn is defined by a set of convex inequalities:

C = {x | f1(x) ≤ 0, . . . , fm(x) ≤ 0}.

We can find a Chebyshev center by solving the problem

maximize R
subject to gi(x,R) ≤ 0, i = 1, . . . ,m, (8.16)

where gi is defined as

gi(x,R) = sup
‖u‖≤1

fi(x+Ru).

Problem (8.16) is a convex optimization problem, since each function gi is the
pointwise maximum of a family of convex functions of x and R, hence convex.
However, evaluating gi involves solving a convex maximization problem (either
numerically or analytically), which may be very hard. In practice, we can find the
Chebyshev center only in cases where the functions gi are easy to evaluate.

Chebyshev center of a polyhedron

Suppose C is defined by a set of linear inequalities aTi x ≤ bi, i = 1, . . . ,m. We
have

gi(x,R) = sup
‖u‖≤1

aTi (x+Ru)− bi = aTi x+R‖ai‖∗ − bi



418 8 Geometric problems

if R ≥ 0, so the Chebyshev center can be found by solving the LP

maximize R
subject to aTi x+R‖ai‖∗ ≤ bi, i = 1, . . . ,m

R ≥ 0

with variables x and R.

Euclidean Chebyshev center of intersection of ellipsoids

Let C be an intersection of m ellipsoids, defined by quadratic inequalities,

C = {x | xTAix+ 2bTi x+ ci ≤ 0, i = 1, . . . ,m},

where Ai ∈ Sn++. We have

gi(x,R) = sup
‖u‖2≤1

(
(x+Ru)TAi(x+Ru) + 2b

T
i (x+Ru) + ci

)
= xTAix+ 2b

T
i x+ ci + sup

‖u‖2≤1

(
R2uTAiu+ 2R(Aix+ bi)

Tu
)
.

From §B.1, gi(x,R) ≤ 0 if and only if there exists a λi such that the matrix
inequality [ −xTAixi − 2bTi x− ci − λi R(Aix+ bi)T

R(Aix+ bi) λiI −R2Ai
]
� 0 (8.17)

holds. Using this result, we can express the Chebyshev centering problem as

maximize R

subject to

 −λi − ci + bTi A−1i bi 0 (x+A−1i bi)T0 λiI RI
x+A−1i bi RI A

−1
i

 � 0, i = 1, . . . ,m,
which is an SDP with variables R, λ, and x. Note that the Schur complement of
A−1i in the LMI constraint is equal to the lefthand side of (8.17).

8.5.2 Maximum volume ellipsoid center

The Chebyshev center xcheb of a set C ⊆ Rn is the center of the largest ball that
lies in C. As an extension of this idea, we define the maximum volume ellipsoid
center of C, denoted xmve, as the center of the maximum volume ellipsoid that lies
in C. Figure 8.6 shows an example, where C is a polyhedron.

The maximum volume ellipsoid center is readily computed when C is defined
by a set of linear inequalities, by solving the problem (8.15). (The optimal value
of the variable d ∈ Rn is xmve.) Since the maximum volume ellipsoid inside C is
affine invariant, so is the maximum volume ellipsoid center.



8.5 Centering 419

xmve

Figure 8.6 The lightly shaded ellipsoid shows the maximum volume ellipsoid
contained in the set C, which is the same polyhedron as in figure 8.5. Its
center xmve is the maximum volume ellipsoid center of C.

8.5.3 Analytic center of a set of inequalities

The analytic center xac of a set of convex inequalities and linear equalities,

fi(x) ≤ 0, i = 1, . . . ,m, Fx = g
is defined as an optimal point for the (convex) problem

minimize −∑mi=1 log(−fi(x))
subject to Fx = g,

(8.18)

with variable x ∈ Rn and implicit constraints fi(x) < 0, i = 1, . . . ,m. The objec-
tive in (8.18) is called the logarithmic barrier associated with the set of inequalities.
We assume here that the domain of the logarithmic barrier intersects the affine set
defined by the equalities, i.e., the strict inequality system

fi(x) < 0, i = 1, . . . ,m, Fx = g

is feasible. The logarithmic barrier is bounded below on the feasible set

C = {x | fi(x) < 0, i = 1, . . . ,m, Fx = g},
if C is bounded.

When x is strictly feasible, i.e., Fx = g and fi(x) < 0 for i = 1, . . . ,m, we can
interpret −fi(x) as the margin or slack in the ith inequality. The analytic center
xac is the point that maximizes the product (or geometric mean) of these slacks or
margins, subject to the equality constraints Fx = g, and the implicit constraints
fi(x) < 0.

The analytic center is not a function of the set C described by the inequalities
and equalities; two sets of inequalities and equalities can define the same set, but
have different analytic centers. Still, it is not uncommon to informally use the



420 8 Geometric problems

term ‘analytic center of a set C’ to mean the analytic center of a particular set of
equalities and inequalities that define it.

The analytic center is, however, independent of affine changes of coordinates.
It is also invariant under (positive) scalings of the inequality functions, and any
reparametrization of the equality constraints. In other words, if F˜ and g˜ are such
that F˜ x = g˜ if and only if Fx = g, and α1, . . . , αm > 0, then the analytic center of

αifi(x) ≤ 0, i = 1, . . . ,m, F˜x = g˜,
is the same as the analytic center of

fi(x) ≤ 0, i = 1, . . . ,m, Fx = g
(see exercise 8.17).

Analytic center of a set of linear inequalities

The analytic center of a set of linear inequalities

aTi x ≤ bi, i = 1, . . . ,m,
is the solution of the unconstrained minimization problem

minimize −∑mi=1 log(bi − aTi x), (8.19)
with implicit constraint bi − aTi x > 0, i = 1, . . . ,m. If the polyhedron defined by
the linear inequalities is bounded, then the logarithmic barrier is bounded below
and strictly convex, so the analytic center is unique. (See exercise 4.2.)

We can give a geometric interpretation of the analytic center of a set of linear
inequalities. Since the analytic center is independent of positive scaling of the
constraint functions, we can assume without loss of generality that ‖ai‖2 = 1. In
this case, the slack bi − aTi x is the distance to the hyperplane Hi = {x | aTi x =
bi}. Therefore the analytic center xac is the point that maximizes the product of
distances to the defining hyperplanes.

Inner and outer ellipsoids from analytic center of linear inequalities

The analytic center of a set of linear inequalities implicitly defines an inscribed and
a covering ellipsoid, defined by the Hessian of the logarithmic barrier function

−
m∑
i=1

log(bi − aTi x),

evaluated at the analytic center, i.e.,

H =

m∑
i=1

d2i aia
T
i , di =

1

bi − aTi xac
, i = 1, . . . ,m.

We have Einner ⊆ P ⊆ Eouter, where
P = {x | aTi x ≤ bi, i = 1, . . . ,m},

Einner = {x | (x− xac)TH(x− xac) ≤ 1},
Eouter = {x | x− xac)TH(x− xac) ≤ m(m− 1)}.



8.5 Centering 421

xac

Figure 8.7 The dashed lines show five level curves of the logarithmic barrier
function for the inequalities defining the polyhedron C in figure 8.5. The
minimizer of the logarithmic barrier function, labeled xac, is the analytic
center of the inequalities. The inner ellipsoid Einner = {x | (x − xac)H(x −
xac) ≤ 1}, where H is the Hessian of the logarithmic barrier function at xac,
is shaded.

This is a weaker result than the one for the maximum volume inscribed ellipsoid,
which when scaled up by a factor of n covers the polyhedron. The inner and outer
ellipsoids defined by the Hessian of the logarithmic barrier, in contrast, are related

by the scale factor (m(m− 1))1/2, which is always at least n.
To show that Einner ⊆ P, suppose x ∈ Einner, i.e.,

(x− xac)TH(x− xac) =
m∑
i=1

(dia
T
i (x− xac))2 ≤ 1.

This implies that

aTi (x− xac) ≤ 1/di = bi − aTi xac, i = 1, . . . ,m,
and therefore aTi x ≤ bi for i = 1, . . . ,m. (We have not used the fact that xac is
the analytic center, so this result is valid if we replace xac with any strictly feasible
point.)

To establish that P ⊆ Eouter, we will need the fact that xac is the analytic
center, and therefore the gradient of the logarithmic barrier vanishes:

m∑
i=1

diai = 0.

Now assume x ∈ P. Then
(x− xac)TH(x− xac)

=

m∑
i=1

(dia
T
i (x− xac))2



422 8 Geometric problems

=

m∑
i=1

d2i (1/di − aTi (x− xac))2 −m

=
m∑
i=1

d2i (bi − aTi x)2 −m

≤
(

m∑
i=1

di(bi − aTi x)
)2

−m

=

(
m∑
i=1

di(bi − aTi xac) +
m∑
i=1

dia
T
i (xac − x)

)2
−m

= m2 −m,

which shows that x ∈ Eouter. (The second equality follows from the fact that∑m
i=1 diai = 0. The inequality follows from

∑m
i=1 y

2
i ≤ (

∑m
i=1 yi)

2
for y � 0. The

last equality follows from
∑m

i=1 diai = 0, and the definition of di.)

Analytic center of a linear matrix inequality

The definition of analytic center can be extended to sets described by generalized
inequalities with respect to a cone K, if we define a logarithm on K. For example,
the analytic center of a linear matrix inequality

x1A1 + x2A2 + · · ·+ xnAn � B

is defined as the solution of

minimize − log det(B − x1A1 − · · · − xnAn).

8.6 Classification

In pattern recognition and classification problems we are given two sets of points
in Rn, {x1, . . . , xN} and {y1, . . . , yM}, and wish to find a function f : Rn → R
(within a given family of functions) that is positive on the first set and negative on
the second, i.e.,

f(xi) > 0, i = 1, . . . , N, f(yi) < 0, i = 1, . . . ,M.

If these inequalities hold, we say that f , or its 0-level set {x | f(x) = 0}, separates,
classifies, or discriminates the two sets of points. We sometimes also consider weak
separation, in which the weak versions of the inequalities hold.



8.6 Classification 423

Figure 8.8 The points x1, . . . , xN are shown as open circles, and the points
y1, . . . , yM are shown as filled circles. These two sets are classified by an
affine function f , whose 0-level set (a line) separates them.

8.6.1 Linear discrimination

In linear discrimination, we seek an affine function f(x) = aTx − b that classifies
the points, i.e.,

aTxi − b > 0, i = 1, . . . , N, aT yi − b < 0, i = 1, . . . ,M. (8.20)
Geometrically, we seek a hyperplane that separates the two sets of points. Since
the strict inequalities (8.20) are homogeneous in a and b, they are feasible if and
only if the set of nonstrict linear inequalities

aTxi − b ≥ 1, i = 1, . . . , N, aT yi − b ≤ −1, i = 1, . . . ,M (8.21)
(in the variables a, b) is feasible. Figure 8.8 shows a simple example of two sets of
points and a linear discriminating function.

Linear discrimination alternative

The strong alternative of the set of strict inequalities (8.20) is the existence of λ,
λ˜ such that

λ � 0, λ˜ � 0, (λ, λ˜) 6= 0,
N∑
i=1

λixi =

M∑
i=1

λ˜iyi, 1
Tλ = 1T λ˜ (8.22)

(see §5.8.3). Using the third and last conditions, we can express these alternative
conditions as

λ � 0, 1Tλ = 1, λ˜ � 0, 1T λ˜ = 1,
N∑
i=1

λixi =

M∑
i=1

λ˜iyi



424 8 Geometric problems

(by dividing by 1Tλ, which is positive, and using the same symbols for the normal-
ized λ and λ˜). These conditions have a simple geometric interpretation: They state
that there is a point in the convex hull of both {x1, . . . , xN} and {y1, . . . , yM}. In
other words: the two sets of points can be linearly discriminated (i.e., discrimi-
nated by an affine function) if and only if their convex hulls do not intersect. We
have seen this result several times before.

Robust linear discrimination

The existence of an affine classifying function f(x) = aTx − b is equivalent to a
set of linear inequalities in the variables a and b that define f . If the two sets
can be linearly discriminated, then there is a polyhedron of affine functions that
discriminate them, and we can choose one that optimizes some measure of robust-
ness. We might, for example, seek the function that gives the maximum possible
‘gap’ between the (positive) values at the points xi and the (negative) values at the
points yi. To do this we have to normalize a and b, since otherwise we can scale a
and b by a positive constant and make the gap in the values arbitrarily large. This
leads to the problem

maximize t
subject to aTxi − b ≥ t, i = 1, . . . , N

aT yi − b ≤ −t, i = 1, . . . ,M
‖a‖2 ≤ 1,

(8.23)

with variables a, b, and t. The optimal value t⋆ of this convex problem (with
linear objective, linear inequalities, and one quadratic inequality) is positive if
and only if the two sets of points can be linearly discriminated. In this case the
inequality ‖a‖2 ≤ 1 is always tight at the optimum, i.e., we have ‖a⋆‖2 = 1. (See
exercise 8.23.)

We can give a simple geometric interpretation of the robust linear discrimination
problem (8.23). If ‖a‖2 = 1 (as is the case at any optimal point), aTxi − b is the
Euclidean distance from the point xi to the separating hyperplane H = {z | aT z =
b}. Similarly, b−aT yi is the distance from the point yi to the hyperplane. Therefore
the problem (8.23) finds the hyperplane that separates the two sets of points, and
has maximal distance to the sets. In other words, it finds the thickest slab that
separates the two sets.

As suggested by the example shown in figure 8.9, the optimal value t⋆ (which is
half the slab thickness) turns out to be half the distance between the convex hulls
of the two sets of points. This can be seen clearly from the dual of the robust linear
discrimination problem (8.23). The Lagrangian (for the problem of minimizing −t)
is

−t+
N∑
i=1

ui(t+ b− aTxi) +
M∑
i=1

vi(t− b+ aT yi) + λ(‖a‖2 − 1).

Minimizing over b and t yields the conditions 1Tu = 1/2, 1T v = 1/2. When these
hold, we have

g(u, v, λ) = inf
a

(
aT (

M∑
i=1

viyi −
N∑
i=1

uixi) + λ‖a‖2 − λ
)



8.6 Classification 425

Figure 8.9 By solving the robust linear discrimination problem (8.23) we
find an affine function that gives the largest gap in values between the two
sets (with a normalization bound on the linear part of the function). Ge-
ometrically, we are finding the thickest slab that separates the two sets of
points.

=

{
−λ

∥∥∥∑Mi=1 viyi −∑Ni=1 uixi∥∥∥
2
≤ λ

−∞ otherwise.
The dual problem can then be written as

maximize −
∥∥∥∑Mi=1 viyi −∑Ni=1 uixi∥∥∥

2
subject to u � 0, 1Tu = 1/2

v � 0, 1T v = 1/2.
We can interpret 2

∑N
i=1 uixi as a point in the convex hull of {x1, . . . , xN} and

2
∑M

i=1 viyi as a point in the convex hull of {y1, . . . , yM}. The dual objective is to
minimize (half) the distance between these two points, i.e., find (half) the distance
between the convex hulls of the two sets.

Support vector classifier

When the two sets of points cannot be linearly separated, we might seek an affine
function that approximately classifies the points, for example, one that minimizes
the number of points misclassified. Unfortunately, this is in general a difficult
combinatorial optimization problem. One heuristic for approximate linear discrim-
ination is based on support vector classifiers, which we describe in this section.

We start with the feasibility problem (8.21). We first relax the constraints
by introducing nonnegative variables u1, . . . , uN and v1, . . . , uM , and forming the
inequalities

aTxi− b ≥ 1−ui, i = 1, . . . , N, aT yi− b ≤ −(1−vi), i = 1, . . . ,M. (8.24)



426 8 Geometric problems

Figure 8.10 Approximate linear discrimination via linear programming. The
points x1, . . . , x50, shown as open circles, cannot be linearly separated from
the points y1, . . . , y50, shown as filled circles. The classifier shown as a solid
line was obtained by solving the LP (8.25). This classifier misclassifies one
point. The dashed lines are the hyperplanes aT z − b = ±1. Four points are
correctly classified, but lie in the slab defined by the dashed lines.

When u = v = 0, we recover the original constraints; by making u and v large
enough, these inequalities can always be made feasible. We can think of ui as
a measure of how much the constraint aTxi − b ≥ 1 is violated, and similarly
for vi. Our goal is to find a, b, and sparse nonnegative u and v that satisfy the
inequalities (8.24). As a heuristic for this, we can minimize the sum of the variables
ui and vi, by solving the LP

minimize 1Tu+ 1T v
subject to aTxi − b ≥ 1− ui, i = 1, . . . , N

aT yi − b ≤ −(1− vi), i = 1, . . . ,M
u � 0, v � 0.

(8.25)

Figure 8.10 shows an example. In this example, the affine function aT z − b mis-
classifies 1 out of 100 points. Note however that when 0 < ui < 1, the point xi
is correctly classified by the affine function aT z − b, but violates the inequality
aTxi − b ≥ 1, and similarly for yi. The objective function in the LP (8.25) can be
interpreted as a relaxation of the number of points xi that violate a

Txi−b ≥ 1 plus
the number of points yi that violate a

T yi−b ≤ −1. In other words, it is a relaxation
of the number of points misclassified by the function aT z − b, plus the number of
points that are correctly classified but lie in the slab defined by −1 < aT z− b < 1.

More generally, we can consider the trade-off between the number of misclas-
sified points, and the width of the slab {z | − 1 ≤ aT z − b ≤ 1}, which is
given by 2/‖a‖2. The standard support vector classifier for the sets {x1, . . . , xN},



8.6 Classification 427

Figure 8.11 Approximate linear discrimination via support vector classifier,
with γ = 0.1. The support vector classifier, shown as the solid line, misclas-
sifies three points. Fifteen points are correctly classified but lie in the slab
defined by −1 < aT z − b < 1, bounded by the dashed lines.

{y1, . . . , yM} is defined as the solution of
minimize ‖a‖2 + γ(1Tu+ 1T v)
subject to aTxi − b ≥ 1− ui, i = 1, . . . , N

aT yi − b ≤ −(1− vi), i = 1, . . . ,M
u � 0, v � 0,

The first term is proportional to the inverse of the width of the slab defined by
−1 ≤ aT z − b ≤ 1. The second term has the same interpretation as above, i.e., it
is a convex relaxation for the number of misclassified points (including the points
in the slab). The parameter γ, which is positive, gives the relative weight of the
number of misclassified points (which we want to minimize), compared to the width
of the slab (which we want to maximize). Figure 8.11 shows an example.

Approximate linear discrimination via logistic modeling

Another approach to finding an affine function that approximately classifies two
sets of points that cannot be linearly separated is based on the logistic model
described in §7.1.1. We start by fitting the two sets of points with a logistic model.
Suppose z is a random variable with values 0 or 1, with a distribution that depends
on some (deterministic) explanatory variable u ∈ Rn, via a logistic model of the
form

prob(z = 1) = (exp(aTu− b))/(1 + exp(aTu− b))
prob(z = 0) = 1/(1 + exp(aTu− b)). (8.26)

Now we assume that the given sets of points, {x1, . . . , xN} and {y1, . . . , yM},
arise as samples from the logistic model. Specifically, {x1, . . . , xN} are the values



428 8 Geometric problems

of u for the N samples for which z = 1, and {y1, . . . , yM} are the values of u for
the M samples for which z = 0. (This allows us to have xi = yj , which would rule
out discrimination between the two sets. In a logistic model, it simply means that
we have two samples, with the same value of explanatory variable but different
outcomes.)

We can determine a and b by maximum likelihood estimation from the observed
samples, by solving the convex optimization problem

minimize −l(a, b) (8.27)
with variables a, b, where l is the log-likelihood function

l(a, b) =
∑N

i=1(a
Txi − b)

−∑Ni=1 log(1 + exp(aTxi − b))−∑Mi=1 log(1 + exp(aT yi − b))
(see §7.1.1). If the two sets of points can be linearly separated, i.e., if there exist a,
b with aTxi > b and a

T yi < b, then the optimization problem (8.27) is unbounded
below.

Once we find the maximum likelihood values of a and b, we can form a linear
classifier f(x) = aTx− b for the two sets of points. This classifier has the following
property: Assuming the data points are in fact generated from a logistic model
with parameters a and b, it has the smallest probability of misclassification, over
all linear classifiers. The hyperplane aTu = b corresponds to the points where
prob(z = 1) = 1/2, i.e., the two outcomes are equally likely. An example is shown
in figure 8.12.

Remark 8.1 Bayesian interpretation. Let x and z be two random variables, taking
values in Rn and in {0, 1}, respectively. We assume that

prob(z = 1) = prob(z = 0) = 1/2,

and we denote by p0(x) and p1(x) the conditional probability densities of x, given
z = 0 and given z = 1, respectively. We assume that p0 and p1 satisfy

p1(x)

p0(x)
= ea

T x−b

for some a and b. Many common distributions satisfy this property. For example,
p0 and p1 could be two normal densities on R

n with equal covariance matrices and
different means, or they could be two exponential densities on Rn+.

It follows from Bayes’ rule that

prob(z = 1 | x = u) = p1(u)
p1(u) + p0(u)

prob(z = 0 | x = u) = p0(u)
p1(u) + p0(u)

,

from which we obtain

prob(z = 1 | x = u) = exp(a
Tu− b)

1 + exp(aTu− b)
prob(z = 0 | x = u) = 1

1 + exp(aTu− b) .



8.6 Classification 429

Figure 8.12 Approximate linear discrimination via logistic modeling. The
points x1, . . . , x50, shown as open circles, cannot be linearly separated from
the points y1, . . . , y50, shown as filled circles. The maximum likelihood lo-
gistic model yields the hyperplane shown as a dark line, which misclassifies
only two points. The two dashed lines show aTu− b = ±1, where the proba-
bility of each outcome, according to the logistic model, is 73%. Three points
are correctly classified, but lie in between the dashed lines.

The logistic model (8.26) can therefore be interpreted as the posterior distribution of
z, given that x = u.

8.6.2 Nonlinear discrimination

We can just as well seek a nonlinear function f , from a given subspace of functions,
that is positive on one set and negative on another:

f(xi) > 0, i = 1, . . . , N, f(yi) < 0, i = 1, . . . ,M.

Provided f is linear (or affine) in the parameters that define it, these inequalities
can be solved in exactly the same way as in linear discrimination. In this section
we examine some interesting special cases.

Quadratic discrimination

Suppose we take f to be quadratic: f(x) = xTPx + qTx + r. The parameters
P ∈ Sn, q ∈ Rn, r ∈ R must satisfy the inequalities

xTi Pxi + q
Txi + r > 0, i = 1, . . . , N

yTi Pyi + q
T yi + r < 0, i = 1, . . . ,M,



430 8 Geometric problems

which is a set of strict linear inequalities in the variables P , q, r. As in linear
discrimination, we note that f is homogeneous in P , q, and r, so we can find a
solution to the strict inequalities by solving the nonstrict feasibility problem

xTi Pxi + q
Txi + r ≥ 1, i = 1, . . . , N

yTi Pyi + q
T yi + r ≤ −1, i = 1, . . . ,M.

The separating surface {z | zTPz + qT z + r = 0} is a quadratic surface, and
the two classification regions

{z | zTPz + qT z + r ≤ 0}, {z | zTPz + qT z + r ≥ 0},

are defined by quadratic inequalities. Solving the quadratic discrimination problem,
then, is the same as determining whether the two sets of points can be separated
by a quadratic surface.

We can impose conditions on the shape of the separating surface or classification
regions by adding constraints on P , q, and r. For example, we can require that
P ≺ 0, which means the separating surface is ellipsoidal. More specifically, it means
that we seek an ellipsoid that contains all the points x1, . . . , xN , but none of the
points y1, . . . , yM . This quadratic discrimination problem can be solved as an SDP
feasibility problem

find P, q, r
subject to xTi Pxi + q

Txi + r ≥ 1, i = 1, . . . , N
yTi Pyi + q

T yi + r ≤ −1, i = 1, . . . ,M
P � −I,

with variables P ∈ Sn, q ∈ Rn, and r ∈ R. (Here we use homogeneity in P , q, r
to express the constraint P ≺ 0 as P � −I.) Figure 8.13 shows an example.

Polynomial discrimination

We consider the set of polynomials on Rn with degree less than or equal to d:

f(x) =
∑

i1+···+in≤d

ai1···idx
i1
1 · · ·xinn .

We can determine whether or not two sets {x1, . . . , xN} and {y1, . . . , yM} can be
separated by such a polynomial by solving a set of linear inequalities in the variables
ai1···id . Geometrically, we are checking whether the two sets can be separated by
an algebraic surface (defined by a polynomial of degree less than or equal to d).

As an extension, the problem of determining the minimum degree polynomial on
Rn that separates two sets of points can be solved via quasiconvex programming,
since the degree of a polynomial is a quasiconvex function of the coefficients. This
can be carried out by bisection on d, solving a feasibility linear program at each
step. An example is shown in figure 8.14.



8.6 Classification 431

Figure 8.13 Quadratic discrimination, with the condition that P ≺ 0. This
means that we seek an ellipsoid containing all of xi (shown as open circles)
and none of the yi (shown as filled circles). This can be solved as an SDP
feasibility problem.

Figure 8.14 Minimum degree polynomial discrimination in R2. In this ex-
ample, there exists no cubic polynomial that separates the points x1, . . . , xN
(shown as open circles) from the points y1, . . . , yM (shown as filled circles),
but they can be separated by fourth-degree polynomial, the zero level set of
which is shown.



432 8 Geometric problems

8.7 Placement and location

In this section we discuss a few variations on the following problem. We have
N points in R2 or R3, and a list of pairs of points that must be connected by
links. The positions of some of the N points are fixed; our task is to determine the
positions of the remaining points, i.e., to place the remaining points. The objective
is to place the points so that some measure of the total interconnection length of
the links is minimized, subject to some additional constraints on the positions.
As an example application, we can think of the points as locations of plants or
warehouses of a company, and the links as the routes over which goods must be
shipped. The goal is to find locations that minimize the total transportation cost.
In another application, the points represent the position of modules or cells on an
integrated circuit, and the links represent wires that connect pairs of cells. Here
the goal might be to place the cells in such a way that the total length of wire used
to interconnect the cells is minimized.

The problem can be described in terms of an undirected graph with N nodes,
representing the N points. With each node we associate a variable xi ∈ Rk, where
k = 2 or k = 3, which represents its location or position. The problem is to
minimize ∑

(i,j)∈A

fij(xi, xj)

where A is the set of all links in the graph, and fij : Rk × Rk → R is a cost
function associated with arc (i, j). (Alternatively, we can sum over all i and j, or
over i < j, and simply set fij = 0 when links i and j are not connected.) Some of
the coordinate vectors xi are given. The optimization variables are the remaining
coordinates. Provided the functions fij are convex, this is a convex optimization
problem.

8.7.1 Linear facility location problems

In the simplest version of the problem the cost associated with arc (i, j) is the
distance between nodes i and j: fij(xi, xj) = ‖xi − xj‖, i.e., we minimize∑

(i,j)∈A

‖xi − xj‖.

We can use any norm, but the most common applications involve the Euclidean
norm or the ℓ1-norm. For example, in circuit design it is common to route the wires
between cells along piecewise-linear paths, with each segment either horizontal or
vertical. (This is called Manhattan routing, since paths along the streets in a city
with a rectangular grid are also piecewise-linear, with each street aligned with one
of two orthogonal axes.) In this case, the length of wire required to connect cell i
and cell j is given by ‖xi − xj‖1.

We can include nonnegative weights that reflect differences in the cost per unit



8.7 Placement and location 433

distance along different arcs: ∑
(i,j)∈A

wij‖xi − xj‖.

By assigning a weight wij = 0 to pairs of nodes that are not connected, we can
express this problem more simply using the objective∑

i<j

wij‖xi − xj‖. (8.28)

This placement problem is convex.

Example 8.4 One free point. Consider the case where only one point (u, v) ∈ R2 is
free, and we minimize the sum of the distances to fixed points (u1, v1), . . . , (uK , vK).

• ℓ1-norm. We can find a point that minimizes
K∑
i=1

(|u− ui|+ |v − vi|)

analytically. An optimal point is any median of the fixed points. In other words,
u can be taken to be any median of the points {u1, . . . , uK}, and v can be taken
to be any median of the points {v1, . . . , vK}. (If K is odd, the minimizer is
unique; if K is even, there can be a rectangle of optimal points.)

• Euclidean norm. The point (u, v) that minimizes the sum of the Euclidean
distances,

K∑
i=1

(
(u− ui)2 + (v − vi)2

)1/2
,

is called the Weber point of the given fixed points.

8.7.2 Placement constraints

We now list some interesting constraints that can be added to the basic placement
problem, preserving convexity. We can require some positions xi to lie in a specified
convex set, e.g., a particular line, interval, square, or ellipsoid. We can constrain
the relative position of one point with respect to one or more other points, for
example, by limiting the distance between a pair of points. We can impose relative
position constraints, e.g., that one point must lie to the left of another point.

The bounding box of a group of points is the smallest rectangle that contains
the points. We can impose a constraint that limits the points x1, . . . , xp (say) to lie
in a bounding box with perimeter not exceeding Pmax, by adding the constraints

u � xi � v, i = 1, . . . , p, 21T (v − u) ≤ Pmax,

where u, v are additional variables.



434 8 Geometric problems

8.7.3 Nonlinear facility location problems

More generally, we can associate a cost with each arc that is a nonlinear increasing
function of the length, i.e.,

minimize
∑

i<j wijh(‖xi − xj‖)

where h is an increasing (on R+) and convex function, and wij ≥ 0. We call this
a nonlinear placement or nonlinear facility location problem.

One common example uses the Euclidean norm, and the function h(z) = z2,
i.e., we minimize ∑

i<j

wij‖xi − xj‖22.

This is called a quadratic placement problem. The quadratic placement problem
can be solved analytically when the only constraints are linear equalities; it can be
solved as a QP if the constraints are linear equalities and inequalities.

Example 8.5 One free point. Consider the case where only one point x is free, and we
minimize the sum of the squares of the Euclidean distances to fixed points x1, . . . , xK ,

‖x− x1‖22 + ‖x− x2‖22 + · · ·+ ‖x− xK‖22.
Taking derivatives, we see that the optimal x is given by

1

K
(x1 + x2 + · · ·+ xK),

i.e., the average of the fixed points.

Some other interesting possibilities are the ‘deadzone’ function h with deadzone
width 2γ, defined as

h(z) =

{
0 |z| ≤ γ
|z − γ| |z| ≥ γ,

and the ‘quadratic-linear’ function h, defined as

h(z) =

{
z2 |z| ≤ γ
2γ|z| − γ2 |z| ≥ γ.

Example 8.6 We consider a placement problem in R2 with 6 free points, 8 fixed
points, and 27 links. Figures 8.15–8.17 show the optimal solutions for the criteria∑

(i,j)∈A

‖xi − xj‖2,
∑

(i,j)∈A

‖xi − xj‖22,
∑

(i,j)∈A

‖xi − xj‖42,

i.e., using the penalty functions h(z) = z, h(z) = z2, and h(z) = z4. The figures also
show the resulting distributions of the link lengths.

Comparing the results, we see that the linear placement concentrates the free points in
a small area, while the quadratic and fourth-order placements spread the points over
larger areas. The linear placement includes many very short links, and a few very long
ones (3 lengths under 0.2 and 2 lengths above 1.5.). The quadratic penalty function



8.7 Placement and location 435

−1 0 1
−1

0

1

0 0.5 1 1.5 2
0

1

2

3

4

Figure 8.15 Linear placement. Placement problem with 6 free points (shown
as dots), 8 fixed points (shown as squares), and 27 links. The coordinates of
the free points minimize the sum of the Euclidean lengths of the links. The
right plot is the distribution of the 27 link lengths. The dashed curve is the
(scaled) penalty function h(z) = z.

−1 0 1
−1

0

1

0 0.5 1 1.5
0

1

2

3

4

Figure 8.16 Quadratic placement. Placement that minimizes the sum of
squares of the Euclidean lengths of the links, for the same data as in fig-
ure 8.15. The dashed curve is the (scaled) penalty function h(z) = z2.



436 8 Geometric problems

−1 0 1
−1

0

1

0 0.5 1 1.5
0

1

2

3

4

5

6

Figure 8.17 Fourth-order placement. Placement that minimizes the sum of
the fourth powers of the Euclidean lengths of the links. The dashed curve
is the (scaled) penalty function h(z) = z4.

puts a higher penalty on long lengths relative to short lengths, and for lengths under
0.1, the penalty is almost negligible. As a result, the maximum length is shorter (less
than 1.4), but we also have fewer short links. The fourth-order function puts an even
higher penalty on long lengths, and has a wider interval (between zero and about
0.4) where it is negligible. As a result, the maximum length is shorter than for the
quadratic placement, but we also have more lengths close to the maximum.

8.7.4 Location problems with path constraints

Path constraints

A p-link path along the points x1, . . . , xN is described by a sequence of nodes,
i0, . . . , ip ∈ {1, . . . , N}. The length of the path is given by

‖xi1 − xi0‖+ ‖xi2 − xi1‖+ · · ·+ ‖xip − xip−1‖,
which is a convex function of x1, . . . , xN , so imposing an upper bound on the length
of a path is a convex constraint. Several interesting placement problems involve
path constraints, or have an objective based on path lengths. We describe one
typical example, in which the objective is based on a maximum path length over a
set of paths.

Minimax delay placement

We consider a directed acyclic graph with nodes 1, . . . , N , and arcs or links repre-
sented by a set A of ordered pairs: (i, j) ∈ A if and only if an arc points from i
to j. We say node i is a source node if no arc A points to it; it is a sink node or
destination node if no arc in A leaves from it. We will be interested in the maximal
paths in the graph, which begin at a source node and end at a sink node.

The arcs of the graph are meant to model some kind of flow, say of goods or
information, in a network with nodes at positions x1, . . . , xN . The flow starts at



8.7 Placement and location 437

a source node, then moves along a path from node to node, ending at a sink or
destination node. We use the distance between successive nodes to model prop-
agation time, or shipment time, of the goods between nodes; the total delay or
propagation time of a path is (proportional to) the sum of the distances between
successive nodes.

Now we can describe the minimax delay placement problem. Some of the node
locations are fixed, and the others are free, i.e., optimization variables. The goal
is to choose the free node locations in order to minimize the maximum total delay,
for any path from a source node to a sink node. Evidently this is a convex problem,
since the objective

Tmax = max{‖xi1 − xi0‖+ · · ·+ ‖xip − xip−1‖ | i0, . . . , ip is a source-sink path}
(8.29)

is a convex function of the locations x1, . . . , xN .
While the problem of minimizing (8.29) is convex, the number of source-sink

paths can be very large, exponential in the number of nodes or arcs. There is
a useful reformulation of the problem, which avoids enumerating all sink-source
paths.

We first explain how we can evaluate the maximum delay Tmax far more ef-
ficiently than by evaluating the delay for every source-sink path, and taking the
maximum. Let τk be the maximum total delay of any path from node k to a sink
node. Clearly we have τk = 0 when k is a sink node. Consider a node k, which has
outgoing arcs to nodes j1, . . . , jp. For a path starting at node k and ending at a
sink node, its first arc must lead to one of the nodes j1, . . . , jp. If such a path first
takes the arc leading to ji, and then takes the longest path from there to a sink
node, the total length is

‖xji − xk‖+ τji ,
i.e., the length of the arc to ji, plus the total length of the longest path from ji to
a sink node. It follows that the maximum delay of a path starting at node k and
leading to a sink node satisfies

τk = max{‖xj1 − xk‖+ τj1 , . . . , ‖xjp − xk‖+ τjp}. (8.30)

(This is a simple dynamic programming argument.)
The equations (8.30) give a recursion for finding the maximum delay from any

node: we start at the sink nodes (which have maximum delay zero), and then
work backward using the equations (8.30), until we reach all source nodes. The
maximum delay over any such path is then the maximum of all the τk, which will
occur at one of the source nodes. This dynamic programming recursion shows
how the maximum delay along any source-sink path can be computed recursively,
without enumerating all the paths. The number of arithmetic operations required
for this recursion is approximately the number of links.

Now we show how the recursion based on (8.30) can be used to formulate the
minimax delay placement problem. We can express the problem as

minimize max{τk | k a source node}
subject to τk = 0, k a sink node

τk = max{‖xj − xk‖+ τj | there is an arc from k to j},



438 8 Geometric problems

with variables τ1, . . . , τN and the free positions. This problem is not convex, but
we can express it in an equivalent form that is convex, by replacing the equality
constraints with inequalities. We introduce new variables T1, . . . , TN , which will be
upper bounds on τ1, . . . , τN , respectively. We will take Tk = 0 for all sink nodes,
and in place of (8.30) we take the inequalities

Tk ≥ max{‖xj1 − xk‖+ Tj1 , . . . , ‖xjp − xk‖+ Tjp}.
If these inequalities are satisfied, then Tk ≥ τk. Now we form the problem

minimize max{Tk | k a source node}
subject to Tk = 0, k a sink node

Tk ≥ max{‖xj − xk‖+ Tj | there is an arc from k to j}.
This problem, with variables T1, . . . , TN and the free locations, is convex, and solves
the minimax delay location problem.

8.8 Floor planning

In placement problems, the variables represent the coordinates of a number of
points that are to be optimally placed. A floor planning problem can be considered
an extension of a placement problem in two ways:

• The objects to be placed are rectangles or boxes aligned with the axes (as
opposed to points), and must not overlap.

• Each rectangle or box to be placed can be reconfigured, within some limits.
For example we might fix the area of each rectangle, but not the length and
height separately.

The objective is usually to minimize the size (e.g., area, volume, perimeter) of the
bounding box, which is the smallest box that contains the boxes to be configured
and placed.

The non-overlap constraints make the general floor planning problem a compli-
cated combinatorial optimization problem or rectangle packing problem. However,
if the relative positioning of the boxes is specified, several types of floor planning
problems can be formulated as convex optimization problems. We explore some
of these in this section. We consider the two-dimensional case, and make a few
comments on extensions to higher dimensions (when they are not obvious).

We have N cells or modules C1, . . . , CN that are to be configured and placed
in a rectangle with width W and height H, and lower left corner at the position
(0, 0). The geometry and position of the ith cell is specified by its width wi and
height hi, and the coordinates (xi, yi) of its lower left corner. This is illustrated in
figure 8.18.

The variables in the problem are xi, yi, wi, hi for i = 1, . . . , N , and the width
W and height H of the bounding rectangle. In all floor planning problems, we
require that the cells lie inside the bounding rectangle, i.e.,

xi ≥ 0, yi ≥ 0, xi + wi ≤W, yi + hi ≤ H, i = 1, . . . , N. (8.31)



8.8 Floor planning 439

W

H

hi

wi

(xi, yi)

Ci

Figure 8.18 Floor planning problem. Non-overlapping rectangular cells are
placed in a rectangle with widthW , height H, and lower left corner at (0, 0).
The ith cell is specified by its width wi, height hi, and the coordinates of its
lower left corner, (xi, yi).

We also require that the cells do not overlap, except possibly on their boundaries:

int (Ci ∩ Cj) = ∅ for i 6= j.

(It is also possible to require a positive minimum clearance between the cells.) The
non-overlap constraint int(Ci ∩ Cj) = ∅ holds if and only if for i 6= j,

Ci is left of Cj , or Ci is right of Cj , or Ci is below Cj , or Ci is above Cj .

These four geometric conditions correspond to the inequalities

xi + wi ≤ xj , or xj + wj ≤ xi, or yi + hj ≤ yj , or yj + hi ≤ yi, (8.32)

at least one of which must hold for each i 6= j. Note the combinatorial nature of
these constraints: for each pair i 6= j, at least one of the four inequalities above
must hold.

8.8.1 Relative positioning constraints

The idea of relative positioning constraints is to specify, for each pair of cells,
one of the four possible relative positioning conditions, i.e., left, right, above, or
below. One simple method to specify these constraints is to give two relations on
{1, . . . , N}: L (meaning ‘left of’) and B (meaning ‘below’). We then impose the
constraint that Ci is to the left of Cj if (i, j) ∈ L, and Ci is below Cj if (i, j) ∈ B.
This yields the constraints

xi + wi ≤ xj for (i, j) ∈ L, yi + hi ≤ yj for (i, j) ∈ B, (8.33)



440 8 Geometric problems

for i, j = 1, . . . , N . To ensure that the relations L and B specify the relative
positioning of each pair of cells, we require that for each (i, j) with i 6= j, one of
the following holds:

(i, j) ∈ L, (j, i) ∈ L, (i, j) ∈ B, (j, i) ∈ B,
and that (i, i) 6∈ L, (i, i) 6∈ B. The inequalities (8.33) are a set of N(N −1)/2 linear
inequalities in the variables. These inequalities imply the non-overlap inequali-
ties (8.32), which are a set of N(N − 1)/2 disjunctions of four linear inequalities.

We can assume that the relations L and B are anti-symmetric (i.e., (i, j) ∈
L ⇒ (j, i) 6∈ L) and transitive (i.e., (i, j) ∈ L, (j, k) ∈ L ⇒ (i, k) ∈ L). (If this
were not the case, the relative positioning constraints would clearly be infeasible.)
Transitivity corresponds to the obvious condition that if cell Ci is to the left of cell
Cj , which is to the left of cell Ck, then cell Ci must be to the left of cell Ck. In
this case the inequality corresponding to (i, k) ∈ L is redundant; it is implied by
the other two. By exploiting transitivity of the relations L and B we can remove
redundant constraints, and obtain a compact set of relative positioning inequalities.

A minimal set of relative positioning constraints is conveniently described using
two directed acyclic graphsH and V (for horizontal and vertical). Both graphs have
N nodes, corresponding to the N cells in the floor planning problem. The graph
H generates the relation L as follows: we have (i, j) ∈ L if and only if there is
a (directed) path in H from i to j. Similarly, the graph V generates the relation
B: (i, j) ∈ B if and only if there is a (directed) path in V from i to j. To ensure
that a relative positioning constraint is given for every pair of cells, we require that
for every pair of cells, there is a directed path from one to the other in one of the
graphs.

Evidently, we only need to impose the inequalities that correspond to the edges
of the graphs H and V; the others follow from transitivity. We arrive at the set of
inequalities

xi + wi ≤ xj for (i, j) ∈ H, yi + hi ≤ yj for (i, j) ∈ V, (8.34)
which is a set of linear inequalities, one for each edge in H and V. The set of
inequalities (8.34) is a subset of the set of inequalities (8.33), and equivalent.

In a similar way, the 4N inequalities (8.31) can be reduced to a minimal, equiv-
alent set. The constraint xi ≥ 0 only needs to be imposed on the left-most cells,
i.e., for i that are minimal in the relation L. These correspond to the sources in
the graph H, i.e., those nodes that have no edges pointing to them. Similarly, the
inequalities xi + wi ≤ W only need to be imposed for the right-most cells. In the
same way the vertical bounding box inequalities can be pruned to a minimal set.
This yields the minimal equivalent set of bounding box inequalities

xi ≥ 0 for i L minimal, xi + wi ≤W for i L maximal,
yi ≥ 0 for i B minimal, yi + hi ≤ H for i B maximal. (8.35)

A simple example is shown in figure 8.19. In this example, the L minimal or
left-most cells are C1, C2, and C4, and the only right-most cell is C5. The minimal
set of inequalities specifying the horizontal relative positioning is given by

x1 ≥ 0, x2 ≥ 0, x4 ≥ 0, x5 + w5 ≤W, x1 + w1 ≤ x3,
x2 + w2 ≤ x3, x3 + w3 ≤ x5, x4 + w4 ≤ x5.



8.8 Floor planning 441

H

V

1

2

3

4

5

12

3

4

5

1

2

3

4

5

Figure 8.19 Example illustrating the horizontal and vertical graphs H and
V that specify the relative positioning of the cells. If there is a path from
node i to node j in H, then cell i must be placed to the left of cell j. If there
is a path from node i to node j in V, then cell i must be placed below cell
j. The floorplan shown at right satisfies the relative positioning specified by
the two graphs.

The minimal set of inequalities specifying the vertical relative positioning is given
by

y2 ≥ 0, y3 ≥ 0, y5 ≥ 0, y4 + h4 ≤ H, y5 + h5 ≤ H,
y2 + h2 ≤ y1, y1 + h1 ≤ y4, y3 + h3 ≤ y4.

8.8.2 Floor planning via convex optimization

In this formulation, the variables are the bounding box width and height W and
H, and the cell widths, heights, and positions: wi, hi, xi, and wi, for i = 1, . . . , N .
We impose the bounding box constraints (8.35) and the relative positioning con-
straints (8.34), which are linear inequalities. As objective, we take the perimeter
of the bounding box, i.e., 2(W + H), which is a linear function of the variables.
We now list some of the constraints that can be expressed as convex inequalities
or linear equalities in the variables.

Minimum spacing

We can impose a minimum spacing ρ > 0 between cells by changing the relative
position constraints from xi + wi ≤ xj for (i, j) ∈ H, to xi + wi + ρ ≤ xj for
(i, j) ∈ H, and similarly for the vertical graph. We can have a different minimum
spacing associated with each edge in H and V. Another possibility is to fix W and
H, and maximize the minimum spacing ρ as objective.



442 8 Geometric problems

Minimum cell area

For each cell we specify a minimum area, i.e., we require that wihi ≥ Ai, where
Ai > 0. These minimum cell area constraints can be expressed as convex inequali-

ties in several ways, e.g., wi ≥ Ai/hi, (wihi)1/2 ≥ A1/2i , or logwi + log hi ≥ logAi.

Aspect ratio constraints

We can impose upper and lower bounds on the aspect ratio of each cell, i.e.,

li ≤ hi/wi ≤ ui.

Multiplying through by wi transforms these constraints into linear inequalities. We
can also fix the aspect ratio of a cell, which results in a linear equality constraint.

Alignment constraints

We can impose the constraint that two edges, or a center line, of two cells are
aligned. For example, the horizontal center line of cell i aligns with the top of cell
j when

yi + wi/2 = yj + wj .

These are linear equality constraints. In a similar way we can require that a cell is
flushed against the bounding box boundary.

Symmetry constraints

We can require pairs of cells to be symmetric about a vertical or horizontal axis,
that can be fixed or floating (i.e., whose position is fixed or not). For example, to
specify that the pair of cells i and j are symmetric about the vertical axis x = xaxis,
we impose the linear equality constraint

xaxis − (xi + wi/2) = xj + wj/2− xaxis.

We can require that several pairs of cells be symmetric about an unspecified vertical
axis by imposing these equality constraints, and introducing xaxis as a new variable.

Similarity constraints

We can require that cell i be an a-scaled translate of cell j by the equality con-
straints wi = awj , hi = ahj . Here the scaling factor a must be fixed. By imposing
only one of these constraints, we require that the width (or height) of one cell be
a given factor times the width (or height) of the other cell.

Containment constraints

We can require that a particular cell contains a given point, which imposes two lin-
ear inequalities. We can require that a particular cell lie inside a given polyhedron,
again by imposing linear inequalities.



8.8 Floor planning 443

Distance constraints

We can impose a variety of constraints that limit the distance between pairs of
cells. In the simplest case, we can limit the distance between the center points
of cell i and j (or any other fixed points on the cells, such as lower left corners).
For example, to limit the distance between the centers of cells i and j, we use the
(convex) inequality

‖(xi + wi/2, yi + hi/2)− (xj + wj/2, yj + hj/2)‖ ≤ Dij .
As in placement problems, we can limit sums of distances, or use sums of distances
as the objective.

We can also limit the distance dist(Ci, Cj) between cell i and cell j, i.e., the
minimum distance between a point in cell i and a point in cell j. In the general
case this can be done as follows. To limit the distance between cells i and j in the
norm ‖ · ‖, we can introduce four new variables ui, vi, uj , vj . The pair (ui, vi)
will represent a point in Ci, and the pair (uj , vj) will represent a point in Cj . To
ensure this we impose the linear inequalities

xi ≤ ui ≤ xi + wi, yi ≤ vi ≤ yi + hi,
and similarly for cell j. Finally, to limit dist(Ci, Cj), we add the convex inequality

‖(ui, vi)− (uj , vj)‖ ≤ Dij .
In many specific cases we can express these distance constraints more efficiently,

by exploiting the relative positioning constraints or deriving a more explicit formu-
lation. As an example consider the ℓ∞-norm, and suppose cell i lies to the left of
cell j (by a relative positioning constraint). The horizontal displacement between
the two cells is xj − (xi + wi) Then we have dist(Ci, Cj) ≤ Dij if and only if

xj − (xi + wi) ≤ Dij , yj − (yi + hi) ≤ Dij , yi − (yj + hj) ≤ Dij .
The first inequality states that the horizontal displacement between the right edge
of cell i and the left edge of cell j does not exceed Dij . The second inequality
requires that the bottom of cell j is no more than Dij above the top of cell i, and
the third inequality requires that the bottom of cell i is no more than Dij above the
top of cell j. These three inequalities together are equivalent to dist(Ci, Cj) ≤ Dij .
In this case, we do not need to introduce any new variables.

We can limit the ℓ1- (or ℓ2-) distance between two cells in a similar way. Here
we introduce one new variable dv, which will serve as a bound on the vertical
displacement between the cells. To limit the ℓ1-distance, we add the constraints

yj − (yi + hi) ≤ dv, yi − (yj + hj) ≤ dv, dv ≥ 0
and the constraints

xj − (xi + wi) + dv ≤ Dij .
(The first term is the horizontal displacement and the second is an upper bound
on the vertical displacement.) To limit the Euclidean distance between the cells,
we replace this last constraint with

(xj − (xi + wi))2 + d2v ≤ D2ij .



444 8 Geometric problems

1
1

1
1

2
2

22

3

3

3
3

4

4

4
4

55

55

Figure 8.20 Four instances of an optimal floor plan, using the relative po-
sitioning constraints shown in figure 8.19. In each case the objective is to
minimize the perimeter, and the same minimum spacing constraint between
cells is imposed. We also require the aspect ratios to lie between 1/5 and 5.
The four cases differ in the minimum areas required for each cell. The sum
of the minimum areas is the same for each case.

Example 8.7 Figure 8.20 shows an example with 5 cells, using the ordering constraints
of figure 8.19, and four different sets of constraints. In each case we impose the
same minimum required spacing constraint, and the same aspect ratio constraint
1/5 ≤ wi/hi ≤ 5. The four cases differ in the minimum required cell areas Ai. The
values of Ai are chosen so that the total minimum required area

∑5
i=1

Ai is the same
for each case.

8.8.3 Floor planning via geometric programming

The floor planning problem can also be formulated as a geometric program in the
variables xi, yi, wi, hi, W, H. The objectives and constraints that can be handled
in this formulation are a bit different from those that can be expressed in the convex
formulation.

First we note that the bounding box constraints (8.35) and the relative po-



8.8 Floor planning 445

sitioning constraints (8.34) are posynomial inequalities, since the lefthand sides
are sums of variables, and the righthand sides are single variables, hence monomi-
als. Dividing these inequalities by the righthand side yields standard posynomial
inequalities.

In the geometric programming formulation we can minimize the bounding box
area, since WH is a monomial, hence posynomial. We can also exactly specify
the area of each cell, since wihi = Ai is a monomial equality constraint. On the
other hand alignment, symmetry, and distance constraints cannot be handled in
the geometric programming formulation. Similarity, however, can be; indeed it
is possible to require that one cell be similar to another, without specifying the
scaling ratio (which can be treated as just another variable).



446 8 Geometric problems

Bibliography

The characterization of Euclidean distance matrices in §8.3.3 appears in Schoenberg
[Sch35]; see also Gower [Gow85].

Our use of the term Lo¨wner-John ellipsoid follows Gro¨tschel, Lova´sz, and Schrijver
[GLS88, page 69]. The efficiency results for ellipsoidal approximations in §8.4 were proved
by John [Joh85]. Boyd, El Ghaoui, Feron, and Balakrishnan [BEFB94, §3.7] give con-
vex formulations of several ellipsoidal approximation problems involving sets defined as
unions, intersections or sums of ellipsoids.

The different centers defined in §8.5 have applications in design centering (see, for exam-
ple, Seifi, Ponnambalan, and Vlach [SPV99]), and cutting-plane methods (Elzinga and

Moore [EM75], Tarasov, Khachiyan, and E`rlikh [TKE88], and Ye [Ye97, chapter 8]). The
inner ellipsoid defined by the Hessian of the logarithmic barrier function (page 420) is
sometimes called the Dikin ellipsoid, and is the basis of Dikin’s algorithm for linear and
quadratic programming [Dik67]. The expression for the outer ellipsoid at the analytic
center was given by Sonnevend [Son86]. For extensions to nonpolyhedral convex sets, see
Boyd and El Ghaoui [BE93], Jarre [Jar94], and Nesterov and Nemirovski [NN94, page
34].

Convex optimization has been applied to linear and nonlinear discrimination problems
since the 1960s; see Mangasarian [Man65] and Rosen [Ros65]. Standard texts that dis-
cuss pattern classification include Duda, Hart, and Stork [DHS99] and Hastie, Tibshirani,
and Friedman [HTF01]. For a detailed discussion of support vector classifiers, see Vap-
nik [Vap00] or Scho¨lkopf and Smola [SS01].

The Weber point defined in example 8.4 is named after Weber [Web71]. Linear and
quadratic placement is used in circuit design (Kleinhaus, Sigl, Johannes, and Antre-
ich [KSJA91, SDJ91]). Sherwani [She99] is a recent overview of algorithms for placement,
layout, floor planning, and other geometric optimization problems in VLSI circuit design.



Exercises 447

Exercises

Projection on a set

8.1 Uniqueness of projection. Show that if C ⊆ Rn is nonempty, closed and convex, and the
norm ‖ · ‖ is strictly convex, then for every x0 there is exactly one x ∈ C closest to x0. In
other words the projection of x0 on C is unique.

8.2 [Web94, Val64] Chebyshev characterization of convexity. A set C ∈ Rn is called a Cheby-
shev set if for every x0 ∈ Rn, there is a unique point in C closest (in Euclidean norm)
to x0. From the result in exercise 8.1, every nonempty, closed, convex set is a Chebyshev
set. In this problem we show the converse, which is known as Motzkin’s theorem.

Let C ∈ Rn be a Chebyshev set.
(a) Show that C is nonempty and closed.

(b) Show that PC , the Euclidean projection on C, is continuous.

(c) Suppose x0 6∈ C. Show that PC(x) = PC(x0) for all x = θx0 + (1 − θ)PC(x0) with
0 ≤ θ ≤ 1.

(d) Suppose x0 6∈ C. Show that PC(x) = PC(x0) for all x = θx0 + (1 − θ)PC(x0) with
θ ≥ 1.

(e) Combining parts (c) and (d), we can conclude that all points on the ray with base
PC(x0) and direction x0 − PC(x0) have projection PC(x0). Show that this implies
that C is convex.

8.3 Euclidean projection on proper cones.

(a) Nonnegative orthant. Show that Euclidean projection onto the nonnegative orthant
is given by the expression on page 399.

(b) Positive semidefinite cone. Show that Euclidean projection onto the positive semidef-
inite cone is given by the expression on page 399.

(c) Second-order cone. Show that the Euclidean projection of (x0, t0) on the second-
order cone

K = {(x, t) ∈ Rn+1 | ‖x‖2 ≤ t}
is given by

PK(x0, t0) =

{
0 ‖x0‖2 ≤ −t0
(x0, t0) ‖x0‖2 ≤ t0
(1/2)(1 + t0/‖x0‖2)(x0, ‖x0‖2) ‖x0‖2 ≥ |t0|.

8.4 The Euclidean projection of a point on a convex set yields a simple separating hyperplane

(PC(x0)− x0)T (x− (1/2)(x0 + PC(x0))) = 0.
Find a counterexample that shows that this construction does not work for general norms.

8.5 [HUL93, volume 1, page 154] Depth function and signed distance to boundary. Let C ⊆ Rn
be a nonempty convex set, and let dist(x,C) be the distance of x to C in some norm.
We already know that dist(x,C) is a convex function of x.

(a) Show that the depth function,

depth(x,C) = dist(x,Rn \ C),
is concave for x ∈ C.

(b) The signed distance to the boundary of C is defined as

s(x) =

{
dist(x,C) x 6∈ C
−depth(x,C) x ∈ C.

Thus, s(x) is positive outside C, zero on its boundary, and negative on its interior.
Show that s is a convex function.



448 8 Geometric problems

Distance between sets

8.6 Let C, D be convex sets.

(a) Show that dist(C, x+D) is a convex function of x.

(b) Show that dist(tC, x+ tD) is a convex function of (x, t) for t > 0.

8.7 Separation of ellipsoids. Let E1 and E2 be two ellipsoids defined as
E1 = {x | (x− x1)TP−11 (x− x1) ≤ 1}, E2 = {x | (x− x2)TP−12 (x− x2) ≤ 1},

where P1, P2 ∈ Sn++. Show that E1 ∩ E2 = ∅ if and only if there exists an a ∈ Rn with
‖P 1/22 a‖2 + ‖P 1/21 a‖2 < aT (x1 − x2).

8.8 Intersection and containment of polyhedra. Let P1 and P2 be two polyhedra defined as
P1 = {x | Ax � b}, P2 = {x | Fx � g},

with A ∈ Rm×n, b ∈ Rm, F ∈ Rp×n, g ∈ Rp. Formulate each of the following problems
as an LP feasibility problem, or a set of LP feasibility problems.

(a) Find a point in the intersection P1 ∩ P2.
(b) Determine whether P1 ⊆ P2.
For each problem, derive a set of linear inequalities and equalities that forms a strong
alternative, and give a geometric interpretation of the alternative.
Repeat the question for two polyhedra defined as

P1 = conv{v1, . . . , vK}, P2 = conv{w1, . . . , wL}.

Euclidean distance and angle problems

8.9 Closest Euclidean distance matrix to given data. We are given data dˆij , for i, j = 1, . . . , n,
which are corrupted measurements of the Euclidean distances between vectors in Rk:

dˆij = ‖xi − xj‖2 + vij , i, j = 1, . . . , n,
where vij is some noise or error. These data satisfy dˆij ≥ 0 and dˆij = dˆji, for all i, j. The
dimension k is not specified.
Show how to solve the following problem using convex optimization. Find a dimension

k and x1, . . . , xn ∈ Rk so that
∑n

i,j=1
(dij − dˆij)2 is minimized, where dij = ‖xi − xj‖2,

i, j = 1, . . . , n. In other words, given some data that are approximate Euclidean distances,
you are to find the closest set of actual Euclidean distances, in the least-squares sense.

8.10 Minimax angle fitting. Suppose that y1, . . . , ym ∈ Rk are affine functions of a variable
x ∈ Rn:

yi = Aix+ bi, i = 1, . . . ,m,

and z1, . . . , zm ∈ Rk are given nonzero vectors. We want to choose the variable x, subject
to some convex constraints, (e.g., linear inequalities) to minimize the maximum angle
between yi and zi,

max{ 6 (y1, z1), . . . , 6 (ym, zm)}.
The angle between nonzero vectors is defined as usual:

6 (u, v) = cos−1
(

uT v

‖u‖2‖v‖2

)
,

where we take cos−1(a) ∈ [0, π]. We are only interested in the case when the optimal
objective value does not exceed π/2.
Formulate this problem as a convex or quasiconvex optimization problem. When the
constraints on x are linear inequalities, what kind of problem (or problems) do you have
to solve?



Exercises 449

8.11 Smallest Euclidean cone containing given points. In Rn, we define a Euclidean cone, with
center direction c 6= 0, and angular radius θ, with 0 ≤ θ ≤ π/2, as the set

{x ∈ Rn | 6 (c, x) ≤ θ}.
(A Euclidean cone is a second-order cone, i.e., it can be represented as the image of the
second-order cone under a nonsingular linear mapping.)

Let a1, . . . , am ∈ Rn. How would you find the Euclidean cone, of smallest angular radius,
that contains a1, . . . , am? (In particular, you should explain how to solve the feasibility
problem, i.e., how to determine whether there is a Euclidean cone which contains the
points.)

Extremal volume ellipsoids

8.12 Show that the maximum volume ellipsoid enclosed in a set is unique. Show that the
Lo¨wner-John ellipsoid of a set is unique.

8.13 Lo¨wner-John ellipsoid of a simplex. In this exercise we show that the Lo¨wner-John el-
lipsoid of a simplex in Rn must be shrunk by a factor n to fit inside the simplex. Since
the Lo¨wner-John ellipsoid is affinely invariant, it is sufficient to show the result for one
particular simplex.

Derive the Lo¨wner-John ellipsoid Elj for the simplex C = conv{0, e1, . . . , en}. Show that
Elj must be shrunk by a factor 1/n to fit inside the simplex.

8.14 Efficiency of ellipsoidal inner approximation. Let C be a polyhedron in Rn described as
C = {x | Ax � b}, and suppose that {x | Ax ≺ b} is nonempty.
(a) Show that the maximum volume ellipsoid enclosed in C, expanded by a factor n

about its center, is an ellipsoid that contains C.

(b) Show that if C is symmetric about the origin, i.e., of the form C = {x | −1 � Ax �
1}, then expanding the maximum volume inscribed ellipsoid by a factor √n gives
an ellipsoid that contains C.

8.15 Minimum volume ellipsoid covering union of ellipsoids. Formulate the following problem
as a convex optimization problem. Find the minimum volume ellipsoid E = {x | (x −
x0)

TA−1(x− x0) ≤ 1} that contains K given ellipsoids

Ei = {x | xTAix+ 2bTi x+ ci ≤ 0}, i = 1, . . . ,K.
Hint. See appendix B.

8.16 Maximum volume rectangle inside a polyhedron. Formulate the following problem as a
convex optimization problem. Find the rectangle

R = {x ∈ Rn | l � x � u}
of maximum volume, enclosed in a polyhedron P = {x | Ax � b}. The variables are
l, u ∈ Rn. Your formulation should not involve an exponential number of constraints.

Centering

8.17 Affine invariance of analytic center. Show that the analytic center of a set of inequalities is
affine invariant. Show that it is invariant with respect to positive scaling of the inequalities.

8.18 Analytic center and redundant inequalities. Two sets of linear inequalities that describe
the same polyhedron can have different analytic centers. Show that by adding redundant
inequalities, we can make any interior point x0 of a polyhedron

P = {x ∈ Rn | Ax � b}



450 8 Geometric problems

the analytic center. More specifically, suppose A ∈ Rm×n and Ax0 ≺ b. Show that there
exist c ∈ Rn, γ ∈ R, and a positive integer q, such that P is the solution set of the m+ q
inequalities

Ax � b, cTx ≤ γ, cTx ≤ γ, . . . , cTx ≤ γ (8.36)
(where the inequality cTx ≤ γ is added q times), and x0 is the analytic center of (8.36).

8.19 Let xac be the analytic center of a set of linear inequalities

aTi x ≤ bi, i = 1, . . . ,m,
and define H as the Hessian of the logarithmic barrier function at xac:

H =

m∑
i=1

1

(bi − aTi xac)2
aia

T
i .

Show that the kth inequality is redundant (i.e., it can be deleted without changing the
feasible set) if

bk − aTk xac ≥ m(aTkH−1ak)1/2.
8.20 Ellipsoidal approximation from analytic center of linear matrix inequality. Let C be the

solution set of the LMI
x1A1 + x2A2 + · · ·+ xnAn � B,

where Ai, B ∈ Sm, and let xac be its analytic center. Show that
Einner ⊆ C ⊆ Eouter,

where

Einner = {x | (x− xac)TH(x− xac) ≤ 1},
Eouter = {x | (x− xac)TH(x− xac) ≤ m(m− 1)},

and H is the Hessian of the logarithmic barrier function

− log det(B − x1A1 − x2A2 − · · · − xnAn)
evaluated at xac.

8.21 [BYT99] Maximum likelihood interpretation of analytic center. We use the linear mea-
surement model of page 352,

y = Ax+ v,

where A ∈ Rm×n. We assume the noise components vi are IID with support [−1, 1]. The
set of parameters x consistent with the measurements y ∈ Rm is the polyhedron defined
by the linear inequalities

−1+ y � Ax � 1+ y. (8.37)
Suppose the probability density function of vi has the form

p(v) =

{
αr(1− v2)r −1 ≤ v ≤ 1
0 otherwise,

where r ≥ 1 and αr > 0. Show that the maximum likelihood estimate of x is the analytic
center of (8.37).

8.22 Center of gravity. The center of gravity of a set C ⊆ Rn with nonempty interior is defined
as

xcg =

∫
C
u du∫

C
1 du

.



Exercises 451

The center of gravity is affine invariant, and (clearly) a function of the set C, and not
its particular description. Unlike the centers described in the chapter, however, it is very
difficult to compute the center of gravity, except in simple cases (e.g., ellipsoids, balls,
simplexes).

Show that the center of gravity xcg is the minimizer of the convex function

f(x) =

∫
C

‖u− x‖22 du.

Classification

8.23 Robust linear discrimination. Consider the robust linear discrimination problem given
in (8.23).

(a) Show that the optimal value t⋆ is positive if and only if the two sets of points can
be linearly separated. When the two sets of points can be linearly separated, show
that the inequality ‖a‖2 ≤ 1 is tight, i.e., we have ‖a⋆‖2 = 1, for the optimal a⋆.

(b) Using the change of variables a˜ = a/t, b˜ = b/t, prove that the problem (8.23) is
equivalent to the QP

minimize ‖a˜‖2
subject to a˜Txi − b˜ ≥ 1, i = 1, . . . , N

a˜T yi − b˜ ≤ −1, i = 1, . . . ,M.

8.24 Linear discrimination maximally robust to weight errors. Suppose we are given two sets of
points {x1, . . . , xN} and and {y1, . . . , yM} in Rn that can be linearly separated. In §8.6.1
we showed how to find the affine function that discriminates the sets, and gives the largest
gap in function values. We can also consider robustness with respect to changes in the
vector a, which is sometimes called the weight vector. For a given a and b for which
f(x) = aTx− b separates the two sets, we define the weight error margin as the norm of
the smallest u ∈ Rn such that the affine function (a + u)Tx − b no longer separates the
two sets of points. In other words, the weight error margin is the maximum ρ such that

(a+ u)Txi ≥ b, i = 1, . . . , N, (a+ u)T yj ≤ b, i = 1, . . . ,M,
holds for all u with ‖u‖2 ≤ ρ.
Show how to find a and b that maximize the weight error margin, subject to the normal-
ization constraint ‖a‖2 ≤ 1.

8.25 Most spherical separating ellipsoid. We are given two sets of vectors x1, . . . , xN ∈ Rn, and
y1, . . . , yM ∈ Rn, and wish to find the ellipsoid with minimum eccentricity (i.e., minimum
condition number of the defining matrix) that contains the points x1, . . . , xN , but not the
points y1, . . . , yM . Formulate this as a convex optimization problem.

Placement and floor planning

8.26 Quadratic placement. We consider a placement problem in R2, defined by an undirected
graph A with N nodes, and with quadratic costs:

minimize
∑

(i,j)∈A
‖xi − xj‖22.

The variables are the positions xi ∈ R2, i = 1, . . . ,M . The positions xi, i =M+1, . . . , N
are given. We define two vectors u, v ∈ RM by

u = (x11, x21, . . . , xM1), v = (x12, x22, . . . , xM2),

containing the first and second components, respectively, of the free nodes.



452 8 Geometric problems

Show that u and v can be found by solving two sets of linear equations,

Cu = d1, Cv = d2,

where C ∈ SM . Give a simple expression for the coefficients of C in terms of the graph A.
8.27 Problems with minimum distance constraints. We consider a problem with variables

x1, . . . , xN ∈ Rk. The objective, f0(x1, . . . , xN ), is convex, and the constraints
fi(x1, . . . , xN ) ≤ 0, i = 1, . . . ,m,

are convex (i.e., the functions fi : R
Nk → R are convex). In addition, we have the

minimum distance constraints

‖xi − xj‖2 ≥ Dmin, i 6= j, i, j = 1, . . . , N.
In general, this is a hard nonconvex problem.

Following the approach taken in floorplanning, we can form a convex restriction of the
problem, i.e., a problem which is convex, but has a smaller feasible set. (Solving the
restricted problem is therefore easy, and any solution is guaranteed to be feasible for the
nonconvex problem.) Let aij ∈ Rk, for i < j, i, j = 1, . . . , N , satisfy ‖aij‖2 = 1.
Show that the restricted problem

minimize f0(x1, . . . , xN )
subject to fi(x1, . . . , xN ) ≤ 0, i = 1, . . . ,m

aTij(xi − xj) ≥ Dmin, i < j, i, j = 1, . . . , N,
is convex, and that every feasible point satisfies the minimum distance constraint.

Remark. There are many good heuristics for choosing the directions aij . One simple
one starts with an approximate solution xˆ1, . . . , xˆN (that need not satisfy the minimum
distance constraints). We then set aij = (xˆi − xˆj)/‖xˆi − xˆj‖2.

Miscellaneous problems

8.28 Let P1 and P2 be two polyhedra described as
P1 = {x | Ax � b} , P2 = {x | −1 � Cx � 1} ,

where A ∈ Rm×n, C ∈ Rp×n, and b ∈ Rm. The polyhedron P2 is symmetric about the
origin. For t ≥ 0 and xc ∈ Rn, we use the notation tP2 + xc to denote the polyhedron

tP2 + xc = {tx+ xc | x ∈ P2},
which is obtained by first scaling P2 by a factor t about the origin, and then translating
its center to xc.

Show how to solve the following two problems, via an LP, or a set of LPs.

(a) Find the largest polyhedron tP2 + xc enclosed in P1, i.e.,
maximize t
subject to tP2 + xc ⊆ P1

t ≥ 0.

(b) Find the smallest polyhedron tP2 + xc containing P1, i.e.,
minimize t
subject to P1 ⊆ tP2 + xc

t ≥ 0.



Exercises 453

In both problems the variables are t ∈ R and xc ∈ Rn.
8.29 Outer polyhedral approximations. Let P = {x ∈ Rn | Ax � b} be a polyhedron, and

C ⊆ Rn a given set (not necessarily convex). Use the support function SC to formulate
the following problem as an LP:

minimize t
subject to C ⊆ tP + x

t ≥ 0.
Here tP+x = {tu+x | u ∈ P}, the polyhedron P scaled by a factor of t about the origin,
and translated by x. The variables are t ∈ R and x ∈ Rn.

8.30 Interpolation with piecewise-arc curve. A sequence of points a1, . . . , an ∈ R2 is given. We
construct a curve that passes through these points, in order, and is an arc (i.e., part of a
circle) or line segment (which we think of as an arc of infinite radius) between consecutive
points. Many arcs connect ai and ai+1; we parameterize these arcs by giving the angle
θi ∈ (−π, π) between its tangent at ai and the line segment [ai, ai+1]. Thus, θi = 0 means
the arc between ai and ai+1 is in fact the line segment [ai, ai+1]; θi = π/2 means the arc
between ai and ai+1 is a half-circle (above the linear segment [a1, a2]); θi = −π/2 means
the arc between ai and ai+1 is a half-circle (below the linear segment [a1, a2]). This is
illustrated below.

ai ai+1
θi = 0

θi = π/4

θi = π/2

θi = 3π/4

Our curve is completely specified by the angles θ1, . . . , θn, which can be chosen in the
interval (−π, π). The choice of θi affects several properties of the curve, for example, its
total arc length L, or the joint angle discontinuities, which can be described as follows.

At each point ai, i = 2, . . . , n− 1, two arcs meet, one coming from the previous point and
one going to the next point. If the tangents to these arcs exactly oppose each other, so the
curve is differentiable at ai, we say there is no joint angle discontinuity at ai. In general,
we define the joint angle discontinuity at ai as |θi−1+θi+ψi|, where ψi is the angle between
the line segment [ai, ai+1] and the line segment [ai−1, ai], i.e., ψi = 6 (ai−ai+1, ai−1−ai).
This is shown below. Note that the angles ψi are known (since the ai are known).

θi−1

θi

ψi

ai−1

ai ai+1

We define the total joint angle discontinuity as

D =

n∑
i=2

|θi−1 + θi + ψi|.

Formulate the problem of minimizing total arc length length L, and total joint angle
discontinuity D, as a bi-criterion convex optimization problem. Explain how you would
find the extreme points on the optimal trade-off curve.





Part III

Algorithms





Chapter 9

Unconstrained minimization

9.1 Unconstrained minimization problems

In this chapter we discuss methods for solving the unconstrained optimization
problem

minimize f(x) (9.1)

where f : Rn → R is convex and twice continuously differentiable (which implies
that dom f is open). We will assume that the problem is solvable, i.e., there exists
an optimal point x⋆. (More precisely, the assumptions later in the chapter will
imply that x⋆ exists and is unique.) We denote the optimal value, infx f(x) =
f(x⋆), as p⋆.

Since f is differentiable and convex, a necessary and sufficient condition for a
point x⋆ to be optimal is

∇f(x⋆) = 0 (9.2)
(see §4.2.3). Thus, solving the unconstrained minimization problem (9.1) is the
same as finding a solution of (9.2), which is a set of n equations in the n variables
x1, . . . , xn. In a few special cases, we can find a solution to the problem (9.1) by
analytically solving the optimality equation (9.2), but usually the problem must
be solved by an iterative algorithm. By this we mean an algorithm that computes
a sequence of points x(0), x(1), . . . ∈ dom f with f(x(k)) → p⋆ as k → ∞. Such
a sequence of points is called a minimizing sequence for the problem (9.1). The
algorithm is terminated when f(x(k)) − p⋆ ≤ ǫ, where ǫ > 0 is some specified
tolerance.

Initial point and sublevel set

The methods described in this chapter require a suitable starting point x(0). The
starting point must lie in dom f , and in addition the sublevel set

S = {x ∈ dom f | f(x) ≤ f(x(0))} (9.3)

must be closed. This condition is satisfied for all x(0) ∈ dom f if the function f is
closed, i.e., all its sublevel sets are closed (see §A.3.3). Continuous functions with



458 9 Unconstrained minimization

dom f = Rn are closed, so if dom f = Rn, the initial sublevel set condition is
satisfied by any x(0). Another important class of closed functions are continuous
functions with open domains, for which f(x) tends to infinity as x approaches
bddom f .

9.1.1 Examples

Quadratic minimization and least-squares

The general convex quadratic minimization problem has the form

minimize (1/2)xTPx+ qTx+ r, (9.4)

where P ∈ Sn+, q ∈ Rn, and r ∈ R. This problem can be solved via the optimality
conditions, Px⋆ + q = 0, which is a set of linear equations. When P ≻ 0, there is
a unique solution, x⋆ = −P−1q. In the more general case when P is not positive
definite, any solution of Px⋆ = −q is optimal for (9.4); if Px⋆ = −q does not
have a solution, then the problem (9.4) is unbounded below (see exercise 9.1). Our
ability to analytically solve the quadratic minimization problem (9.4) is the basis
for Newton’s method, a powerful method for unconstrained minimization described
in §9.5.

One special case of the quadratic minimization problem that arises very fre-
quently is the least-squares problem

minimize ‖Ax− b‖22 = xT (ATA)x− 2(AT b)Tx+ bT b.
The optimality conditions

ATAx⋆ = AT b

are called the normal equations of the least-squares problem.

Unconstrained geometric programming

As a second example, we consider an unconstrained geometric program in convex
form,

minimize f(x) = log
(∑m

i=1 exp(a
T
i x+ bi)

)
.

The optimality condition is

∇f(x⋆) = 1∑m
j=1 exp(a

T
j x

⋆ + bj)

m∑
i=1

exp(aTi x
⋆ + bi)ai = 0,

which in general has no analytical solution, so here we must resort to an iterative
algorithm. For this problem, dom f = Rn, so any point can be chosen as the
initial point x(0).

Analytic center of linear inequalities

We consider the optimization problem

minimize f(x) = −∑mi=1 log(bi − aTi x), (9.5)



9.1 Unconstrained minimization problems 459

where the domain of f is the open set

dom f = {x | aTi x < bi, i = 1, . . . ,m}.
The objective function f in this problem is called the logarithmic barrier for the
inequalities aTi x ≤ bi. The solution of (9.5), if it exists, is called the analytic
center of the inequalities. The initial point x(0) must satisfy the strict inequalities
aTi x

(0) < bi, i = 1, . . . ,m. Since f is closed, the sublevel set S for any such point
is closed.

Analytic center of a linear matrix inequality

A closely related problem is

minimize f(x) = log detF (x)−1 (9.6)

where F : Rn → Sp is affine, i.e.,
F (x) = F0 + x1F1 + · · ·+ xnFn,

with Fi ∈ Sp. Here the domain of f is
dom f = {x | F (x) ≻ 0}.

The objective function f is called the logarithmic barrier for the linear matrix
inequality F (x) � 0, and the solution (if it exists) is called the analytic center of
the linear matrix inequality. The initial point x(0) must satisfy the strict linear
matrix inequality F (x(0)) ≻ 0. As in the previous example, the sublevel set of any
such point will be closed, since f is closed.

9.1.2 Strong convexity and implications

In much of this chapter (with the exception of §9.6) we assume that the objective
function is strongly convex on S, which means that there exists an m > 0 such that

∇2f(x) � mI (9.7)
for all x ∈ S. Strong convexity has several interesting consequences. For x, y ∈ S
we have

f(y) = f(x) +∇f(x)T (y − x) + 1
2
(y − x)T∇2f(z)(y − x)

for some z on the line segment [x, y]. By the strong convexity assumption (9.7), the
last term on the righthand side is at least (m/2)‖y−x‖22, so we have the inequality

f(y) ≥ f(x) +∇f(x)T (y − x) + m
2
‖y − x‖22 (9.8)

for all x and y in S. When m = 0, we recover the basic inequality characterizing
convexity; for m > 0 we obtain a better lower bound on f(y) than follows from
convexity alone.



460 9 Unconstrained minimization

We will first show that the inequality (9.8) can be used to bound f(x) − p⋆,
which is the suboptimality of the point x, in terms of ‖∇f(x)‖2. The righthand
side of (9.8) is a convex quadratic function of y (for fixed x). Setting the gradient
with respect to y equal to zero, we find that y˜ = x − (1/m)∇f(x) minimizes the
righthand side. Therefore we have

f(y) ≥ f(x) +∇f(x)T (y − x) + m
2
‖y − x‖22

≥ f(x) +∇f(x)T (y˜ − x) + m
2
‖y˜ − x‖22

= f(x)− 1
2m

‖∇f(x)‖22.

Since this holds for any y ∈ S, we have

p⋆ ≥ f(x)− 1
2m

‖∇f(x)‖22. (9.9)

This inequality shows that if the gradient is small at a point, then the point is
nearly optimal. The inequality (9.9) can also be interpreted as a condition for
suboptimality which generalizes the optimality condition (9.2):

‖∇f(x)‖2 ≤ (2mǫ)1/2 =⇒ f(x)− p⋆ ≤ ǫ. (9.10)

We can also derive a bound on ‖x − x⋆‖2, the distance between x and any
optimal point x⋆, in terms of ‖∇f(x)‖2:

‖x− x⋆‖2 ≤ 2
m
‖∇f(x)‖2. (9.11)

To see this, we apply (9.8) with y = x⋆ to obtain

p⋆ = f(x⋆) ≥ f(x) +∇f(x)T (x⋆ − x) + m
2
‖x⋆ − x‖22

≥ f(x)− ‖∇f(x)‖2‖x⋆ − x‖2 + m
2
‖x⋆ − x‖22,

where we use the Cauchy-Schwarz inequality in the second inequality. Since p⋆ ≤
f(x), we must have

−‖∇f(x)‖2 ‖x⋆ − x‖2 + m
2
‖x⋆ − x‖22 ≤ 0,

from which (9.11) follows. One consequence of (9.11) is that the optimal point x⋆

is unique.

Upper bound on ∇2f(x)
The inequality (9.8) implies that the sublevel sets contained in S are bounded, so in
particular, S is bounded. Therefore the maximum eigenvalue of ∇2f(x), which is a
continuous function of x on S, is bounded above on S, i.e., there exists a constant
M such that

∇2f(x) �MI (9.12)



9.1 Unconstrained minimization problems 461

for all x ∈ S. This upper bound on the Hessian implies for any x, y ∈ S,

f(y) ≤ f(x) +∇f(x)T (y − x) + M
2
‖y − x‖22, (9.13)

which is analogous to (9.8). Minimizing each side over y yields

p⋆ ≤ f(x)− 1
2M

‖∇f(x)‖22, (9.14)

the counterpart of (9.9).

Condition number of sublevel sets

From the strong convexity inequality (9.7) and the inequality (9.12), we have

mI � ∇2f(x) �MI (9.15)

for all x ∈ S. The ratio κ = M/m is thus an upper bound on the condition
number of the matrix ∇2f(x), i.e., the ratio of its largest eigenvalue to its smallest
eigenvalue. We can also give a geometric interpretation of (9.15) in terms of the
sublevel sets of f .

We define the width of a convex set C ⊆ Rn, in the direction q, where ‖q‖2 = 1,
as

W (C, q) = sup
z∈C

qT z − inf
z∈C

qT z.

The minimum width and maximum width of C are given by

Wmin = inf
‖q‖2=1

W (C, q), Wmax = sup
‖q‖2=1

W (C, q).

The condition number of the convex set C is defined as

cond(C) =
W 2max
W 2min

,

i.e., the square of the ratio of its maximum width to its minimum width. The
condition number of C gives a measure of its anisotropy or eccentricity. If the
condition number of a set C is small (say, near one) it means that the set has
approximately the same width in all directions, i.e., it is nearly spherical. If the
condition number is large, it means that the set is far wider in some directions than
in others.

Example 9.1 Condition number of an ellipsoid. Let E be the ellipsoid
E = {x | (x− x0)TA−1(x− x0) ≤ 1},

where A ∈ Sn++. The width of E in the direction q is

sup
z∈E

qT z − inf
z∈E

qT z = (‖A1/2q‖2 + qTx0)− (−‖A1/2q‖2 + qTx0)

= 2‖A1/2q‖2.



462 9 Unconstrained minimization

It follows that its minimum and maximum width are

Wmin = 2λmin(A)
1/2, Wmax = 2λmax(A)

1/2,

and its condition number is

cond(E) = λmax(A)
λmin(A)

= κ(A),

where κ(A) denotes the condition number of the matrix A, i.e., the ratio of its
maximum singular value to its minimum singular value. Thus the condition number
of the ellipsoid E is the same as the condition number of the matrix A that defines
it.

Now suppose f satisfies mI � ∇2f(x) � MI for all x ∈ S. We will derive
a bound on the condition number of the α-sublevel Cα = {x | f(x) ≤ α}, where
p⋆ < α ≤ f(x(0)). Applying (9.13) and (9.8) with x = x⋆, we have

p⋆ + (M/2)‖y − x⋆‖22 ≥ f(y) ≥ p⋆ + (m/2)‖y − x⋆‖22.

This implies that Binner ⊆ Cα ⊆ Bouter where

Binner = {y | ‖y − x⋆‖2 ≤ (2(α− p⋆)/M)1/2},
Bouter = {y | ‖y − x⋆‖2 ≤ (2(α− p⋆)/m)1/2}.

In other words, the α-sublevel set contains Binner, and is contained in Bouter, which
are balls with radii

(2(α− p⋆)/M)1/2, (2(α− p⋆)/m)1/2,

respectively. The ratio of the radii squared gives an upper bound on the condition
number of Cα:

cond(Cα) ≤ M
m
.

We can also give a geometric interpretation of the condition number κ(∇2f(x⋆))
of the Hessian at the optimum. From the Taylor series expansion of f around x⋆,

f(y) ≈ p⋆ + 1
2
(y − x⋆)T∇2f(x⋆)(y − x⋆),

we see that, for α close to p⋆,

Cα ≈ {y | (y − x⋆)T∇2f(x⋆)(y − x⋆) ≤ 2(α− p⋆)},

i.e., the sublevel set is well approximated by an ellipsoid with center x⋆. Therefore

lim
α→p⋆

cond(Cα) = κ(∇2f(x⋆)).

We will see that the condition number of the sublevel sets of f (which is bounded
by M/m) has a strong effect on the efficiency of some common methods for uncon-
strained minimization.



9.2 Descent methods 463

The strong convexity constants

It must be kept in mind that the constants m and M are known only in rare cases,
so the inequality (9.10) cannot be used as a practical stopping criterion. It can be
considered a conceptual stopping criterion; it shows that if the gradient of f at x
is small enough, then the difference between f(x) and p⋆ is small. If we terminate
an algorithm when ‖∇f(x(k))‖2 ≤ η, where η is chosen small enough to be (very
likely) smaller than (mǫ)1/2, then we have f(x(k))− p⋆ ≤ ǫ (very likely).

In the following sections we give convergence proofs for algorithms, which in-
clude bounds on the number of iterations required before f(x(k)) − p⋆ ≤ ǫ, where
ǫ is some positive tolerance. Many of these bounds involve the (usually unknown)
constants m and M , so the same comments apply. These results are at least con-
ceptually useful; they establish that the algorithm converges, even if the bound on
the number of iterations required to reach a given accuracy depends on constants
that are unknown.

We will encounter one important exception to this situation. In §9.6 we will
study a special class of convex functions, called self-concordant, for which we can
provide a complete convergence analysis (for Newton’s method) that does not de-
pend on any unknown constants.

9.2 Descent methods

The algorithms described in this chapter produce a minimizing sequence x(k), k =
1, . . . , where

x(k+1) = x(k) + t(k)∆x(k)

and t(k) > 0 (except when x(k) is optimal). Here the concatenated symbols ∆ and
x that form ∆x are to be read as a single entity, a vector in Rn called the step or
search direction (even though it need not have unit norm), and k = 0, 1, . . . denotes
the iteration number. The scalar t(k) ≥ 0 is called the step size or step length at
iteration k (even though it is not equal to ‖x(k+1) − x(k)‖ unless ‖∆x(k)‖ = 1).
The terms ‘search step’ and ‘scale factor’ are more accurate, but ‘search direction’
and ‘step length’ are the ones widely used. When we focus on one iteration of
an algorithm, we sometimes drop the superscripts and use the lighter notation
x+ = x+ t∆x, or x := x+ t∆x, in place of x(k+1) = x(k) + t(k)∆x(k).

All the methods we study are descent methods, which means that

f(x(k+1)) < f(x(k)),

except when x(k) is optimal. This implies that for all k we have x(k) ∈ S, the initial
sublevel set, and in particular we have x(k) ∈ dom f . From convexity we know
that ∇f(x(k))T (y − x(k)) ≥ 0 implies f(y) ≥ f(x(k)), so the search direction in a
descent method must satisfy

∇f(x(k))T∆x(k) < 0,
i.e., it must make an acute angle with the negative gradient. We call such a
direction a descent direction (for f , at x(k)).



464 9 Unconstrained minimization

The outline of a general descent method is as follows. It alternates between two
steps: determining a descent direction ∆x, and the selection of a step size t.

Algorithm 9.1 General descent method.

given a starting point x ∈ dom f .
repeat

1. Determine a descent direction ∆x.
2. Line search. Choose a step size t > 0.
3. Update. x := x+ t∆x.

until stopping criterion is satisfied.

The second step is called the line search since selection of the step size t deter-
mines where along the line {x + t∆x | t ∈ R+} the next iterate will be. (A more
accurate term might be ray search.)

A practical descent method has the same general structure, but might be or-
ganized differently. For example, the stopping criterion is often checked while, or
immediately after, the descent direction ∆x is computed. The stopping criterion
is often of the form ‖∇f(x)‖2 ≤ η, where η is small and positive, as suggested by
the suboptimality condition (9.9).

Exact line search

One line search method sometimes used in practice is exact line search, in which t
is chosen to minimize f along the ray {x+ t∆x | t ≥ 0}:

t = argmins≥0 f(x+ s∆x). (9.16)

An exact line search is used when the cost of the minimization problem with one
variable, required in (9.16), is low compared to the cost of computing the search
direction itself. In some special cases the minimizer along the ray can be found an-
alytically, and in others it can be computed efficiently. (This is discussed in §9.7.1.)

Backtracking line search

Most line searches used in practice are inexact : the step length is chosen to ap-
proximately minimize f along the ray {x + t∆x | t ≥ 0}, or even to just reduce
f ‘enough’. Many inexact line search methods have been proposed. One inexact
line search method that is very simple and quite effective is called backtracking line
search. It depends on two constants α, β with 0 < α < 0.5, 0 < β < 1.

Algorithm 9.2 Backtracking line search.

given a descent direction ∆x for f at x ∈ dom f , α ∈ (0, 0.5), β ∈ (0, 1).
t := 1.
while f(x+ t∆x) > f(x) + αt∇f(x)T∆x, t := βt.



9.2 Descent methods 465

t

f(x+ t∆x)

t = 0 t0

f(x) + αt∇f(x)T∆xf(x) + t∇f(x)T∆x

Figure 9.1 Backtracking line search. The curve shows f , restricted to the line
over which we search. The lower dashed line shows the linear extrapolation
of f , and the upper dashed line has a slope a factor of α smaller. The
backtracking condition is that f lies below the upper dashed line, i.e., 0 ≤
t ≤ t0.

The line search is called backtracking because it starts with unit step size and
then reduces it by the factor β until the stopping condition f(x + t∆x) ≤ f(x) +
αt∇f(x)T∆x holds. Since ∆x is a descent direction, we have ∇f(x)T∆x < 0, so
for small enough t we have

f(x+ t∆x) ≈ f(x) + t∇f(x)T∆x < f(x) + αt∇f(x)T∆x,
which shows that the backtracking line search eventually terminates. The constant
α can be interpreted as the fraction of the decrease in f predicted by linear extrap-
olation that we will accept. (The reason for requiring α to be smaller than 0.5 will
become clear later.)

The backtracking condition is illustrated in figure 9.1. This figure suggests,
and it can be shown, that the backtracking exit inequality f(x + t∆x) ≤ f(x) +
αt∇f(x)T∆x holds for t ≥ 0 in an interval (0, t0]. It follows that the backtracking
line search stops with a step length t that satisfies

t = 1, or t ∈ (βt0, t0].
The first case occurs when the step length t = 1 satisfies the backtracking condition,
i.e., 1 ≤ t0. In particular, we can say that the step length obtained by backtracking
line search satisfies

t ≥ min{1, βt0}.
When dom f is not all of Rn, the condition f(x+ t∆x) ≤ f(x)+αt∇f(x)T∆x

in the backtracking line search must be interpreted carefully. By our convention
that f is infinite outside its domain, the inequality implies that x+ t∆x ∈ dom f .
In a practical implementation, we first multiply t by β until x + t∆x ∈ dom f ;



466 9 Unconstrained minimization

then we start to check whether the inequality f(x + t∆x) ≤ f(x) + αt∇f(x)T∆x
holds.

The parameter α is typically chosen between 0.01 and 0.3, meaning that we
accept a decrease in f between 1% and 30% of the prediction based on the linear
extrapolation. The parameter β is often chosen to be between 0.1 (which corre-
sponds to a very crude search) and 0.8 (which corresponds to a less crude search).

9.3 Gradient descent method

A natural choice for the search direction is the negative gradient ∆x = −∇f(x).
The resulting algorithm is called the gradient algorithm or gradient descent method.

Algorithm 9.3 Gradient descent method.

given a starting point x ∈ dom f .
repeat

1. ∆x := −∇f(x).
2. Line search. Choose step size t via exact or backtracking line search.
3. Update. x := x+ t∆x.

until stopping criterion is satisfied.

The stopping criterion is usually of the form ‖∇f(x)‖2 ≤ η, where η is small and
positive. In most implementations, this condition is checked after step 1, rather
than after the update.

9.3.1 Convergence analysis

In this section we present a simple convergence analysis for the gradient method,
using the lighter notation x+ = x+ t∆x for x(k+1) = x(k)+ t(k)∆x(k), where ∆x =
−∇f(x). We assume f is strongly convex on S, so there are positive constants m
andM such that mI � ∇2f(x) �MI for all x ∈ S. Define the function f˜ : R→ R
by f˜(t) = f(x − t∇f(x)), i.e., f as a function of the step length t in the negative
gradient direction. In the following discussion we will only consider t for which
x − t∇f(x) ∈ S. From the inequality (9.13), with y = x − t∇f(x), we obtain a
quadratic upper bound on f˜ :

f˜(t) ≤ f(x)− t‖∇f(x)‖22 +
Mt2

2
‖∇f(x)‖22. (9.17)

Analysis for exact line search

We now assume that an exact line search is used, and minimize over t both sides
of the inequality (9.17). On the lefthand side we get f˜(texact), where texact is the
step length that minimizes f˜ . The righthand side is a simple quadratic, which



9.3 Gradient descent method 467

is minimized by t = 1/M , and has minimum value f(x) − (1/(2M))‖∇f(x)‖22.
Therefore we have

f(x+) = f˜(texact) ≤ f(x)− 1
2M

‖∇(f(x))‖22.

Subtracting p⋆ from both sides, we get

f(x+)− p⋆ ≤ f(x)− p⋆ − 1
2M

‖∇f(x)‖22.

We combine this with ‖∇f(x)‖22 ≥ 2m(f(x) − p⋆) (which follows from (9.9)) to
conclude

f(x+)− p⋆ ≤ (1−m/M)(f(x)− p⋆).
Applying this inequality recursively, we find that

f(x(k))− p⋆ ≤ ck(f(x(0))− p⋆) (9.18)
where c = 1−m/M < 1, which shows that f(x(k)) converges to p⋆ as k → ∞. In
particular, we must have f(x(k))− p⋆ ≤ ǫ after at most

log((f(x(0))− p⋆)/ǫ)
log(1/c)

(9.19)

iterations of the gradient method with exact line search.
This bound on the number of iterations required, even though crude, can give

some insight into the gradient method. The numerator,

log((f(x(0))− p⋆)/ǫ)
can be interpreted as the log of the ratio of the initial suboptimality (i.e., gap
between f(x(0)) and p⋆), to the final suboptimality (i.e., less than ǫ). This term
suggests that the number of iterations depends on how good the initial point is,
and what the final required accuracy is.

The denominator appearing in the bound (9.19), log(1/c), is a function ofM/m,
which we have seen is a bound on the condition number of ∇2f(x) over S, or the
condition number of the sublevel sets {z | f(z) ≤ α}. For large condition number
bound M/m, we have

log(1/c) = − log(1−m/M) ≈ m/M,
so our bound on the number of iterations required increases approximately linearly
with increasing M/m.

We will see that the gradient method does in fact require a large number of
iterations when the Hessian of f , near x⋆, has a large condition number. Conversely,
when the sublevel sets of f are relatively isotropic, so that the condition number
bound M/m can be chosen to be relatively small, the bound (9.18) shows that
convergence is rapid, since c is small, or at least not too close to one.

The bound (9.18) shows that the error f(x(k)) − p⋆ converges to zero at least
as fast as a geometric series. In the context of iterative numerical methods, this
is called linear convergence, since the error lies below a line on a log-linear plot of
error versus iteration number.



468 9 Unconstrained minimization

Analysis for backtracking line search

Now we consider the case where a backtracking line search is used in the gradient
descent method. We will show that the backtracking exit condition,

f˜(t) ≤ f(x)− αt‖∇f(x)‖22,
is satisfied whenever 0 ≤ t ≤ 1/M . First note that

0 ≤ t ≤ 1/M =⇒ − t+ Mt
2

2
≤ −t/2

(which follows from convexity of−t+Mt2/2). Using this result and the bound (9.17),
we have, for 0 ≤ t ≤ 1/M ,

f˜(t) ≤ f(x)− t‖∇f(x)‖22 +
Mt2

2
‖∇(f(x))‖22

≤ f(x)− (t/2)‖∇f(x)‖22
≤ f(x)− αt‖∇f(x)‖22,

since α < 1/2. Therefore the backtracking line search terminates either with t = 1
or with a value t ≥ β/M . This provides a lower bound on the decrease in the
objective function. In the first case we have

f(x+) ≤ f(x)− α‖∇f(x)‖22,
and in the second case we have

f(x+) ≤ f(x)− (βα/M)‖∇f(x)‖22.
Putting these together, we always have

f(x+) ≤ f(x)−min{α, βα/M}‖∇f(x)‖22.
Now we can proceed exactly as in the case of exact line search. We subtract p⋆

from both sides to get

f(x+)− p⋆ ≤ f(x)− p⋆ −min{α, βα/M}‖∇f(x)‖22,
and combine this with ‖∇f(x)‖22 ≥ 2m(f(x)− p⋆) to obtain

f(x+)− p⋆ ≤ (1−min{2mα, 2βαm/M})(f(x)− p⋆).
From this we conclude

f(x(k))− p⋆ ≤ ck(f(x(0))− p⋆)
where

c = 1−min{2mα, 2βαm/M} < 1.
In particular, f(x(k)) converges to p⋆ at least as fast as a geometric series with an
exponent that depends (at least in part) on the condition number bound M/m. In
the terminology of iterative methods, the convergence is at least linear.



9.3 Gradient descent method 469

x1

x
2

x(0)

x(1)

−10 0 10
−4

0

4

Figure 9.2 Some contour lines of the function f(x) = (1/2)(x21+10x
2
2). The

condition number of the sublevel sets, which are ellipsoids, is exactly 10.
The figure shows the iterates of the gradient method with exact line search,
started at x(0) = (10, 1).

9.3.2 Examples

A quadratic problem in R2

Our first example is very simple. We consider the quadratic objective function on
R2

f(x) =
1

2
(x21 + γx

2
2),

where γ > 0. Clearly, the optimal point is x⋆ = 0, and the optimal value is 0. The
Hessian of f is constant, and has eigenvalues 1 and γ, so the condition numbers of
the sublevel sets of f are all exactly

max{1, γ}
min{1, γ} = max{γ, 1/γ}.

The tightest choices for the strong convexity constants m and M are

m = min{1, γ}, M = max{1, γ}.
We apply the gradient descent method with exact line search, starting at the

point x(0) = (γ, 1). In this case we can derive the following closed-form expressions
for the iterates x(k) and their function values (exercise 9.6):

x
(k)
1 = γ

(
γ − 1
γ + 1

)k
, x

(k)
2 =

(
−γ − 1
γ + 1

)k
,

and

f(x(k)) =
γ(γ + 1)

2

(
γ − 1
γ + 1

)2k
=

(
γ − 1
γ + 1

)2k
f(x(0)).

This is illustrated in figure 9.2, for γ = 10.
For this simple example, convergence is exactly linear, i.e., the error is exactly

a geometric series, reduced by the factor |(γ − 1)/(γ + 1)|2 at each iteration. For



470 9 Unconstrained minimization

γ = 1, the exact solution is found in one iteration; for γ not far from one (say,
between 1/3 and 3) convergence is rapid. The convergence is very slow for γ ≫ 1
or γ ≪ 1.

We can compare the convergence with the bound derived above in §9.3.1. Using
the least conservative values m = min{1, γ} and M = max{1, γ}, the bound (9.18)
guarantees that the error in each iteration is reduced at least by the factor c =
(1−m/M). We have seen that the error is in fact reduced exactly by the factor(

1−m/M
1 +m/M

)2
in each iteration. For small m/M , which corresponds to large condition number,
the upper bound (9.19) implies that the number of iterations required to obtain
a given level of accuracy grows at most like M/m. For this example, the exact
number of iterations required grows approximately like (M/m)/4, i.e., one quarter
of the value of the bound. This shows that for this simple example, the bound on
the number of iterations derived in our simple analysis is only about a factor of four
conservative (using the least conservative values for m and M). In particular, the
convergence rate (as well as its upper bound) is very dependent on the condition
number of the sublevel sets.

A nonquadratic problem in R2

We now consider a nonquadratic example in R2, with

f(x1, x2) = e
x1+3x2−0.1 + ex1−3x2−0.1 + e−x1−0.1. (9.20)

We apply the gradient method with a backtracking line search, with α = 0.1,
β = 0.7. Figure 9.3 shows some level curves of f , and the iterates x(k) generated
by the gradient method (shown as small circles). The lines connecting successive
iterates show the scaled steps,

x(k+1) − x(k) = −t(k)∇f(x(k)).

Figure 9.4 shows the error f(x(k))−p⋆ versus iteration k. The plot reveals that
the error converges to zero approximately as a geometric series, i.e., the convergence
is approximately linear. In this example, the error is reduced from about 10 to
about 10−7 in 20 iterations, so the error is reduced by a factor of approximately
10−8/20 ≈ 0.4 each iteration. This reasonably rapid convergence is predicted by
our convergence analysis, since the sublevel sets of f are not too badly conditioned,
which in turn means that M/m can be chosen as not too large.

To compare backtracking line search with an exact line search, we use the
gradient method with an exact line search, on the same problem, and with the
same starting point. The results are given in figures 9.5 and 9.4. Here too the
convergence is approximately linear, about twice as fast as the gradient method
with backtracking line search. With exact line search, the error is reduced by
about 10−11 in 15 iterations, i.e., a reduction by a factor of about 10−11/15 ≈ 0.2
per iteration.



9.3 Gradient descent method 471

x(0)

x(1)

x(2)

Figure 9.3 Iterates of the gradient method with backtracking line search,
for the problem in R2 with objective f given in (9.20). The dashed curves
are level curves of f , and the small circles are the iterates of the gradient
method. The solid lines, which connect successive iterates, show the scaled
steps t(k)∆x(k).

k

f
(x

(k
)
)
−
p
⋆

backtracking l.s.

exact l.s.

0 5 10 15 20 25
10−15

10−10

10−5

100

105

Figure 9.4 Error f(x(k))− p⋆ versus iteration k of the gradient method with
backtracking and exact line search, for the problem in R2 with objective f
given in (9.20). The plot shows nearly linear convergence, with the error
reduced approximately by the factor 0.4 in each iteration of the gradient
method with backtracking line search, and by the factor 0.2 in each iteration
of the gradient method with exact line search.



472 9 Unconstrained minimization

x(0)

x(1)

Figure 9.5 Iterates of the gradient method with exact line search for the
problem in R2 with objective f given in (9.20).

A problem in R100

We next consider a larger example, of the form

f(x) = cTx−
m∑
i=1

log(bi − aTi x), (9.21)

with m = 500 terms and n = 100 variables.

The progress of the gradient method with backtracking line search, with pa-
rameters α = 0.1, β = 0.5, is shown in figure 9.6. In this example we see an initial
approximately linear and fairly rapid convergence for about 20 iterations, followed
by a slower linear convergence. Overall, the error is reduced by a factor of around
106 in around 175 iterations, which gives an average error reduction by a factor of
around 10−6/175 ≈ 0.92 per iteration. The initial convergence rate, for the first 20
iterations, is around a factor of 0.8 per iteration; the slower final convergence rate,
after the first 20 iterations, is around a factor of 0.94 per iteration.

Figure 9.6 shows the convergence of the gradient method with exact line search.
The convergence is again approximately linear, with an overall error reduction by
approximately a factor 10−6/140 ≈ 0.91 per iteration. This is only a bit faster than
the gradient method with backtracking line search.

Finally, we examine the influence of the backtracking line search parameters α
and β on the convergence rate, by determining the number of iterations required
to obtain f(x(k)) − p⋆ ≤ 10−5. In the first experiment, we fix β = 0.5, and vary
α from 0.05 to 0.5. The number of iterations required varies from about 80, for
larger values of α, in the range 0.2–0.5, to about 170 for smaller values of α. This,
and other experiments, suggest that the gradient method works better with fairly
large α, in the range 0.2–0.5.

Similarly, we can study the effect of the choice of β by fixing α = 0.1 and
varying β from 0.05 to 0.95. Again the variation in the total number of iterations
is not large, ranging from around 80 (when β ≈ 0.5) to around 200 (for β small,
or near 1). This experiment, and others, suggest that β ≈ 0.5 is a good choice.



9.3 Gradient descent method 473

k

f
(x

(k
)
)
−
p
⋆

exact l.s.

backtracking l.s.

0 50 100 150 200
10−4

10−2

100

102

104

Figure 9.6 Error f(x(k))−p⋆ versus iteration k for the gradient method with
backtracking and exact line search, for a problem in R100.

These experiments suggest that the effect of the backtracking parameters on the
convergence is not large, no more than a factor of two or so.

Gradient method and condition number

Our last experiment will illustrate the importance of the condition number of
∇2f(x) (or the sublevel sets) on the rate of convergence of the gradient method.
We start with the function given by (9.21), but replace the variable x by x = T x¯,
where

T = diag((1, γ1/n, γ2/n, . . . , γ(n−1)/n)),

i.e., we minimize

f¯(x¯) = cTT x¯−
m∑
i=1

log(bi − aTi T x¯). (9.22)

This gives us a family of optimization problems, indexed by γ, which affects the
problem condition number.

Figure 9.7 shows the number of iterations required to achieve f¯(x¯(k))−p¯⋆ < 10−5
as a function of γ, using a backtracking line search with α = 0.3 and β = 0.7. This
plot shows that for diagonal scaling as small as 10 : 1 (i.e., γ = 10), the number of
iterations grows to more than a thousand; for a diagonal scaling of 20 or more, the
gradient method slows to essentially useless.

The condition number of the Hessian ∇2f¯(x¯⋆) at the optimum is shown in
figure 9.8. For large and small γ, the condition number increases roughly as
max{γ2, 1/γ2}, in a very similar way as the number of iterations depends on γ.
This shows again that the relation between conditioning and convergence speed is
a real phenomenon, and not just an artifact of our analysis.



474 9 Unconstrained minimization

γ

it
er
at
io
n
s

10−1 100 101
102

103

Figure 9.7 Number of iterations of the gradient method applied to prob-
lem (9.22). The vertical axis shows the number of iterations required to

obtain f¯(x¯(k))− p¯⋆ < 10−5. The horizontal axis shows γ, which is a param-
eter that controls the amount of diagonal scaling. We use a backtracking
line search with α = 0.3, β = 0.7.

γ

κ
(∇

2
f¯
(x¯

⋆
))

10−1 100 101
101

102

103

104

Figure 9.8 Condition number of the Hessian of the function at its minimum,
as a function of γ. By comparing this plot with the one in figure 9.7, we see
that the condition number has a very strong influence on convergence rate.



9.4 Steepest descent method 475

Conclusions

From the numerical examples shown, and others, we can make the conclusions
summarized below.

• The gradient method often exhibits approximately linear convergence, i.e.,
the error f(x(k))− p⋆ converges to zero approximately as a geometric series.

• The choice of backtracking parameters α, β has a noticeable but not dramatic
effect on the convergence. An exact line search sometimes improves the con-
vergence of the gradient method, but the effect is not large (and probably
not worth the trouble of implementing the exact line search).

• The convergence rate depends greatly on the condition number of the Hessian,
or the sublevel sets. Convergence can be very slow, even for problems that are
moderately well conditioned (say, with condition number in the 100s). When
the condition number is larger (say, 1000 or more) the gradient method is so
slow that it is useless in practice.

The main advantage of the gradient method is its simplicity. Its main disadvantage
is that its convergence rate depends so critically on the condition number of the
Hessian or sublevel sets.

9.4 Steepest descent method

The first-order Taylor approximation of f(x+ v) around x is

f(x+ v) ≈ f̂(x+ v) = f(x) +∇f(x)T v.
The second term on the righthand side, ∇f(x)T v, is the directional derivative of
f at x in the direction v. It gives the approximate change in f for a small step v.
The step v is a descent direction if the directional derivative is negative.

We now address the question of how to choose v to make the directional deriva-
tive as negative as possible. Since the directional derivative ∇f(x)T v is linear in
v, it can be made as negative as we like by taking v large (provided v is a descent
direction, i.e., ∇f(x)T v < 0). To make the question sensible we have to limit the
size of v, or normalize by the length of v.

Let ‖ · ‖ be any norm on Rn. We define a normalized steepest descent direction
(with respect to the norm ‖ · ‖) as

∆xnsd = argmin{∇f(x)T v | ‖v‖ = 1}. (9.23)
(We say ‘a’ steepest descent direction because there can be multiple minimizers.)
A normalized steepest descent direction ∆xnsd is a step of unit norm that gives the
largest decrease in the linear approximation of f .

A normalized steepest descent direction can be interpreted geometrically as
follows. We can just as well define ∆xnsd as

∆xnsd = argmin{∇f(x)T v | ‖v‖ ≤ 1},



476 9 Unconstrained minimization

i.e., as the direction in the unit ball of ‖ · ‖ that extends farthest in the direction
−∇f(x).

It is also convenient to consider a steepest descent step ∆xsd that is unnormal-
ized, by scaling the normalized steepest descent direction in a particular way:

∆xsd = ‖∇f(x)‖∗∆xnsd, (9.24)
where ‖ · ‖∗ denotes the dual norm. Note that for the steepest descent step, we
have

∇f(x)T∆xsd = ‖∇f(x)‖∗∇f(x)T∆xnsd = −‖∇f(x)‖2∗
(see exercise 9.7).

The steepest descent method uses the steepest descent direction as search direc-
tion.

Algorithm 9.4 Steepest descent method.

given a starting point x ∈ dom f .
repeat

1. Compute steepest descent direction ∆xsd.
2. Line search. Choose t via backtracking or exact line search.
3. Update. x := x+ t∆xsd.

until stopping criterion is satisfied.

When exact line search is used, scale factors in the descent direction have no effect,
so the normalized or unnormalized direction can be used.

9.4.1 Steepest descent for Euclidean and quadratic norms

Steepest descent for Euclidean norm

If we take the norm ‖·‖ to be the Euclidean norm we find that the steepest descent
direction is simply the negative gradient, i.e., ∆xsd = −∇f(x). The steepest
descent method for the Euclidean norm coincides with the gradient descent method.

Steepest descent for quadratic norm

We consider the quadratic norm

‖z‖P = (zTPz)1/2 = ‖P 1/2z‖2,
where P ∈ Sn++. The normalized steepest descent direction is given by

∆xnsd = −
(∇f(x)TP−1∇f(x))−1/2 P−1∇f(x).

The dual norm is given by ‖z‖∗ = ‖P−1/2z‖2, so the steepest descent step with
respect to ‖ · ‖P is given by

∆xsd = −P−1∇f(x). (9.25)
The normalized steepest descent direction for a quadratic norm is illustrated in
figure 9.9.



9.4 Steepest descent method 477

−∇f(x)

∆xnsd

Figure 9.9 Normalized steepest descent direction for a quadratic norm. The
ellipsoid shown is the unit ball of the norm, translated to the point x. The
normalized steepest descent direction ∆xnsd at x extends as far as possible
in the direction −∇f(x) while staying in the ellipsoid. The gradient and
normalized steepest descent directions are shown.

Interpretation via change of coordinates

We can give an interesting alternative interpretation of the steepest descent direc-
tion ∆xsd as the gradient search direction after a change of coordinates is applied
to the problem. Define u¯ = P 1/2u, so we have ‖u‖P = ‖u¯‖2. Using this change
of coordinates, we can solve the original problem of minimizing f by solving the
equivalent problem of minimizing the function f¯ : Rn → R, given by

f¯(u¯) = f(P−1/2u¯) = f(u).

If we apply the gradient method to f¯ , the search direction at a point x¯ (which
corresponds to the point x = P−1/2x¯ for the original problem) is

∆x¯ = −∇f¯(x¯) = −P−1/2∇f(P−1/2x¯) = −P−1/2∇f(x).
This gradient search direction corresponds to the direction

∆x = P−1/2
(
−P−1/2∇f(x)

)
= −P−1∇f(x)

for the original variable x. In other words, the steepest descent method in the
quadratic norm ‖ · ‖P can be thought of as the gradient method applied to the
problem after the change of coordinates x¯ = P 1/2x.

9.4.2 Steepest descent for ℓ1-norm

As another example, we consider the steepest descent method for the ℓ1-norm. A
normalized steepest descent direction,

∆xnsd = argmin{∇f(x)T v | ‖v‖1 ≤ 1},



478 9 Unconstrained minimization

−∇f(x)
∆xnsd

Figure 9.10 Normalized steepest descent direction for the ℓ1-norm. The
diamond is the unit ball of the ℓ1-norm, translated to the point x. The
normalized steepest descent direction can always be chosen in the direction
of a standard basis vector; in this example we have ∆xnsd = e1.

is easily characterized. Let i be any index for which ‖∇f(x)‖∞ = |(∇f(x))i|. Then
a normalized steepest descent direction ∆xnsd for the ℓ1-norm is given by

∆xnsd = −sign
(
∂f(x)

∂xi

)
ei,

where ei is the ith standard basis vector. An unnormalized steepest descent step
is then

∆xsd = ∆xnsd‖∇f(x)‖∞ = −∂f(x)
∂xi

ei.

Thus, the normalized steepest descent step in ℓ1-norm can always be chosen to be a
standard basis vector (or a negative standard basis vector). It is the coordinate axis
direction along which the approximate decrease in f is greatest. This is illustrated
in figure 9.10.

The steepest descent algorithm in the ℓ1-norm has a very natural interpretation:
At each iteration we select a component of ∇f(x) with maximum absolute value,
and then decrease or increase the corresponding component of x, according to the
sign of (∇f(x))i. The algorithm is sometimes called a coordinate-descent algorithm,
since only one component of the variable x is updated at each iteration. This can
greatly simplify, or even trivialize, the line search.

Example 9.2 Frobenius norm scaling. In §4.5.4 we encountered the unconstrained
geometric program

minimize
∑n

i,j=1
M2ijd

2
i /d

2
j ,

where M ∈ Rn×n is given, and the variable is d ∈ Rn. Using the change of variables
xi = 2 log di we can express this geometric program in convex form as

minimize f(x) = log
(∑n

i,j=1
M2ije

xi−xj

)
.



9.4 Steepest descent method 479

It is easy to minimize f one component at a time. Keeping all components except
the kth fixed, we can write f(x) = log(αk + βke

−xk + γke
xk ), where

αk =M
2
kk +

∑
i,j 6=k

M2ije
xi−xj , βk =

∑
i 6=k

M2ike
xi , γk =

∑
j 6=k

M2kje
−xj .

The minimum of f(x), as a function of xk, is obtained for xk = log(βk/γk)/2. So
for this problem an exact line search can be carried out using a simple analytical
formula.

The ℓ1-steepest descent algorithm with exact line search consists of repeating the
following steps.

1. Compute the gradient

(∇f(x))i = −βie
−xi + γie

xi

αi + βie−xi + γiexi
, i = 1, . . . , n.

2. Select a largest (in absolute value) component of∇f(x): |∇f(x)|k = ‖∇f(x)‖∞.
3. Minimize f over the scalar variable xk, by setting xk = log(βk/γk)/2.

9.4.3 Convergence analysis

In this section we extend the convergence analysis for the gradient method with
backtracking line search to the steepest descent method for an arbitrary norm. We
will use the fact that any norm can be bounded in terms of the Euclidean norm,
so there exists constants γ, γ˜ ∈ (0, 1] such that

‖x‖ ≥ γ‖x‖2, ‖x‖∗ ≥ γ˜‖x‖2

(see §A.1.4).
Again we assume f is strongly convex on the initial sublevel set S. The upper

bound ∇2f(x) � MI implies an upper bound on the function f(x + t∆xsd) as a
function of t:

f(x+ t∆xsd) ≤ f(x) + t∇f(x)T∆xsd + M‖∆xsd‖
2
2

2
t2

≤ f(x) + t∇f(x)T∆xsd + M‖∆xsd‖
2

2γ2
t2

= f(x)− t‖∇f(x)‖2∗ +
M

2γ2
t2‖∇f(x)‖2∗. (9.26)

The step size tˆ = γ2/M (which minimizes the quadratic upper bound (9.26))
satisfies the exit condition for the backtracking line search:

f(x+ tˆ∆xsd) ≤ f(x)− γ
2

2M
‖∇f(x)‖2∗ ≤ f(x) +

αγ2

M
∇f(x)T∆xsd (9.27)



480 9 Unconstrained minimization

since α < 1/2 and ∇f(x)T∆xsd = −‖∇f(x)‖2∗. The line search therefore returns a
step size t ≥ min{1, βγ2/M}, and we have

f(x+) = f(x+ t∆xsd) ≤ f(x)− αmin{1, βγ2/M}‖∇f(x)‖2∗
≤ f(x)− αγ˜2min{1, βγ2/M}‖∇f(x)‖22.

Subtracting p⋆ from both sides and using (9.9), we obtain

f(x+)− p⋆ ≤ c(f(x)− p⋆),
where

c = 1− 2mαγ˜2min{1, βγ2/M} < 1.
Therefore we have

f(x(k))− p⋆ ≤ ck(f(x(0))− p⋆),
i.e., linear convergence exactly as in the gradient method.

9.4.4 Discussion and examples

Choice of norm for steepest descent

The choice of norm used to define the steepest descent direction can have a dra-
matic effect on the convergence rate. For simplicity, we consider the case of steep-
est descent with quadratic P -norm. In §9.4.1, we showed that the steepest descent
method with quadratic P -norm is the same as the gradient method applied to the
problem after the change of coordinates x¯ = P 1/2x. We know that the gradient
method works well when the condition numbers of the sublevel sets (or the Hes-
sian near the optimal point) are moderate, and works poorly when the condition
numbers are large. It follows that when the sublevel sets, after the change of coor-
dinates x¯ = P 1/2x, are moderately conditioned, the steepest descent method will
work well.

This observation provides a prescription for choosing P : It should be chosen
so that the sublevel sets of f , transformed by P−1/2, are well conditioned. For
example if an approximation Hˆ of the Hessian at the optimal point H(x⋆) were
known, a very good choice of P would be P = Hˆ, since the Hessian of f˜ at the
optimum is then

Hˆ−1/2∇2f(x⋆)Hˆ−1/2 ≈ I,
and so is likely to have a low condition number.

This same idea can be described without a change of coordinates. Saying that
a sublevel set has low condition number after the change of coordinates x¯ = P 1/2x
is the same as saying that the ellipsoid

E = {x | xTPx ≤ 1}
approximates the shape of the sublevel set. (In other words, it gives a good ap-
proximation after appropriate scaling and translation.)

This dependence of the convergence rate on the choice of P can be viewed from
two sides. The optimist’s viewpoint is that for any problem, there is always a



9.4 Steepest descent method 481

x(0)

x(1) x(2)

Figure 9.11 Steepest descent method with a quadratic norm ‖ · ‖P1 . The
ellipses are the boundaries of the norm balls {x | ‖x− x(k)‖P1 ≤ 1} at x(0)
and x(1).

choice of P for which the steepest descent method works very well. The challenge,
of course, is to find such a P . The pessimist’s viewpoint is that for any problem,
there are a huge number of choices of P for which steepest descent works very
poorly. In summary, we can say that the steepest descent method works well in
cases where we can identify a matrix P for which the transformed problem has
moderate condition number.

Examples

In this section we illustrate some of these ideas using the nonquadratic problem in
R2 with objective function (9.20). We apply the steepest descent method to the
problem, using the two quadratic norms defined by

P1 =

[
2 0
0 8

]
, P2 =

[
8 0
0 2

]
.

In both cases we use a backtracking line search with α = 0.1 and β = 0.7.

Figures 9.11 and 9.12 show the iterates for steepest descent with norm ‖·‖P1 and
norm ‖ · ‖P2 . Figure 9.13 shows the error versus iteration number for both norms.
Figure 9.13 shows that the choice of norm strongly influences the convergence.
With the norm ‖ · ‖P1 , convergence is a bit more rapid than the gradient method,
whereas with the norm ‖ · ‖P2 , convergence is far slower.

This can be explained by examining the problems after the changes of coor-

dinates x¯ = P
1/2
1 x and x¯ = P

1/2
2 x, respectively. Figures 9.14 and 9.15 show the

problems in the transformed coordinates. The change of variables associated with
P1 yields sublevel sets with modest condition number, so convergence is fast. The
change of variables associated with P2 yields sublevel sets that are more poorly
conditioned, which explains the slower convergence.



482 9 Unconstrained minimization

x(0)

x(1)

x(2)

Figure 9.12 Steepest descent method, with quadratic norm ‖ · ‖P2 .

k

P1

P2

f
(x

(k
)
)
−
p
⋆

0 10 20 30 40
10−15

10−10

10−5

100

105

Figure 9.13 Error f(x(k)) − p⋆ versus iteration k, for the steepest descent
method with the quadratic norm ‖ · ‖P1 and the quadratic norm ‖ · ‖P2 .
Convergence is rapid for the norm ‖ · ‖P1 and very slow for ‖ · ‖P2 .



9.4 Steepest descent method 483

x¯(0)

x¯(1)

Figure 9.14 The iterates of steepest descent with norm ‖ · ‖P1 , after the
change of coordinates. This change of coordinates reduces the condition
number of the sublevel sets, and so speeds up convergence.

x¯(0)

x¯(1)

Figure 9.15 The iterates of steepest descent with norm ‖ · ‖P2 , after the
change of coordinates. This change of coordinates increases the condition
number of the sublevel sets, and so slows down convergence.



484 9 Unconstrained minimization

f

f̂

(x, f(x))

(x+∆xnt, f(x+∆xnt))

Figure 9.16 The function f (shown solid) and its second-order approximation

f̂ at x (dashed). The Newton step ∆xnt is what must be added to x to give

the minimizer of f̂ .

9.5 Newton’s method

9.5.1 The Newton step

For x ∈ dom f , the vector

∆xnt = −∇2f(x)−1∇f(x)

is called the Newton step (for f , at x). Positive definiteness of ∇2f(x) implies that

∇f(x)T∆xnt = −∇f(x)T∇2f(x)−1∇f(x) < 0

unless ∇f(x) = 0, so the Newton step is a descent direction (unless x is optimal).
The Newton step can be interpreted and motivated in several ways.

Minimizer of second-order approximation

The second-order Taylor approximation (or model) f̂ of f at x is

f̂(x+ v) = f(x) +∇f(x)T v + 1
2
vT∇2f(x)v, (9.28)

which is a convex quadratic function of v, and is minimized when v = ∆xnt. Thus,
the Newton step ∆xnt is what should be added to the point x to minimize the
second-order approximation of f at x. This is illustrated in figure 9.16.

This interpretation gives us some insight into the Newton step. If the function
f is quadratic, then x + ∆xnt is the exact minimizer of f . If the function f is
nearly quadratic, intuition suggests that x+∆xnt should be a very good estimate
of the minimizer of f , i.e., x⋆. Since f is twice differentiable, the quadratic model
of f will be very accurate when x is near x⋆. It follows that when x is near x⋆,
the point x + ∆xnt should be a very good estimate of x

⋆. We will see that this
intuition is correct.



9.5 Newton’s method 485

x

x+∆xnt
x+∆xnsd

Figure 9.17 The dashed lines are level curves of a convex function. The
ellipsoid shown (with solid line) is {x + v | vT∇2f(x)v ≤ 1}. The arrow
shows −∇f(x), the gradient descent direction. The Newton step ∆xnt is
the steepest descent direction in the norm ‖ · ‖∇2f(x). The figure also shows
∆xnsd, the normalized steepest descent direction for the same norm.

Steepest descent direction in Hessian norm

The Newton step is also the steepest descent direction at x, for the quadratic norm
defined by the Hessian ∇2f(x), i.e.,

‖u‖∇2f(x) = (uT∇2f(x)u)1/2.
This gives another insight into why the Newton step should be a good search
direction, and a very good search direction when x is near x⋆.

Recall from our discussion above that steepest descent, with quadratic norm
‖ · ‖P , converges very rapidly when the Hessian, after the associated change of
coordinates, has small condition number. In particular, near x⋆, a very good choice
is P = ∇2f(x⋆). When x is near x⋆, we have ∇2f(x) ≈ ∇2f(x⋆), which explains
why the Newton step is a very good choice of search direction. This is illustrated
in figure 9.17.

Solution of linearized optimality condition

If we linearize the optimality condition ∇f(x⋆) = 0 near x we obtain
∇f(x+ v) ≈ ∇f(x) +∇2f(x)v = 0,

which is a linear equation in v, with solution v = ∆xnt. So the Newton step ∆xnt is
what must be added to x so that the linearized optimality condition holds. Again,
this suggests that when x is near x⋆ (so the optimality conditions almost hold),
the update x+∆xnt should be a very good approximation of x

⋆.
When n = 1, i.e., f : R → R, this interpretation is particularly simple. The

solution x⋆ of the minimization problem is characterized by f ′(x⋆) = 0, i.e., it is



486 9 Unconstrained minimization

f ′

f̂ ′

(x, f ′(x))

(x+∆xnt, f
′(x+∆xnt))

Figure 9.18 The solid curve is the derivative f ′ of the function f shown in

figure 9.16. f̂ ′ is the linear approximation of f ′ at x. The Newton step ∆xnt
is the difference between the root of f̂ ′ and the point x.

the zero-crossing of the derivative f ′, which is monotonically increasing since f is
convex. Given our current approximation x of the solution, we form a first-order
Taylor approximation of f ′ at x. The zero-crossing of this affine approximation is
then x+∆xnt. This interpretation is illustrated in figure 9.18.

Affine invariance of the Newton step

An important feature of the Newton step is that it is independent of linear (or
affine) changes of coordinates. Suppose T ∈ Rn×n is nonsingular, and define
f¯(y) = f(Ty). Then we have

∇f¯(y) = TT∇f(x), ∇2f¯(y) = TT∇2f(x)T,

where x = Ty. The Newton step for f¯ at y is therefore

∆ynt = −
(
TT∇2f(x)T )−1 (TT∇f(x))

= −T−1∇2f(x)−1∇f(x)
= T−1∆xnt,

where ∆xnt is the Newton step for f at x. Hence the Newton steps of f and f¯ are
related by the same linear transformation, and

x+∆xnt = T (y +∆ynt).

The Newton decrement

The quantity

λ(x) =
(∇f(x)T∇2f(x)−1∇f(x))1/2

is called the Newton decrement at x. We will see that the Newton decrement
plays an important role in the analysis of Newton’s method, and is also useful



9.5 Newton’s method 487

as a stopping criterion. We can relate the Newton decrement to the quantity
f(x)− infy f̂(y), where f̂ is the second-order approximation of f at x:

f(x)− inf
y
f̂(y) = f(x)− f̂(x+∆xnt) = 1

2
λ(x)2.

Thus, λ2/2 is an estimate of f(x)− p⋆, based on the quadratic approximation of f
at x.

We can also express the Newton decrement as

λ(x) =
(
∆xTnt∇2f(x)∆xnt

)1/2
. (9.29)

This shows that λ is the norm of the Newton step, in the quadratic norm defined
by the Hessian, i.e., the norm

‖u‖∇2f(x) =
(
uT∇2f(x)u)1/2 .

The Newton decrement comes up in backtracking line search as well, since we have

∇f(x)T∆xnt = −λ(x)2. (9.30)
This is the constant used in a backtracking line search, and can be interpreted as
the directional derivative of f at x in the direction of the Newton step:

−λ(x)2 = ∇f(x)T∆xnt = d
dt
f(x+∆xntt)

∣∣∣∣
t=0

.

Finally, we note that the Newton decrement is, like the Newton step, affine in-
variant. In other words, the Newton decrement of f¯(y) = f(Ty) at y, where T is
nonsingular, is the same as the Newton decrement of f at x = Ty.

9.5.2 Newton’s method

Newton’s method, as outlined below, is sometimes called the damped Newton
method or guarded Newton method, to distinguish it from the pure Newton method,
which uses a fixed step size t = 1.

Algorithm 9.5 Newton’s method.

given a starting point x ∈ dom f , tolerance ǫ > 0.
repeat

1. Compute the Newton step and decrement.
∆xnt := −∇2f(x)−1∇f(x); λ2 := ∇f(x)T∇2f(x)−1∇f(x).

2. Stopping criterion. quit if λ2/2 ≤ ǫ.
3. Line search. Choose step size t by backtracking line search.
4. Update. x := x+ t∆xnt.

This is essentially the general descent method described in §9.2, using the New-
ton step as search direction. The only difference (which is very minor) is that the
stopping criterion is checked after computing the search direction, rather than after
the update.



488 9 Unconstrained minimization

9.5.3 Convergence analysis

We assume, as before, that f is twice continuously differentiable, and strongly
convex with constant m, i.e., ∇2f(x) � mI for x ∈ S. We have seen that this also
implies that there exists an M > 0 such that ∇2f(x) �MI for all x ∈ S.

In addition, we assume that the Hessian of f is Lipschitz continuous on S with
constant L, i.e.,

‖∇2f(x)−∇2f(y)‖2 ≤ L‖x− y‖2 (9.31)
for all x, y ∈ S. The coefficient L, which can be interpreted as a bound on the
third derivative of f , can be taken to be zero for a quadratic function. More
generally L measures how well f can be approximated by a quadratic model, so
we can expect the Lipschitz constant L to play a critical role in the performance
of Newton’s method. Intuition suggests that Newton’s method will work very well
for a function whose quadratic model varies slowly (i.e., has small L).

Idea and outline of convergence proof

We first give the idea and outline of the convergence proof, and the main conclusion,
and then the details of the proof. We will show there are numbers η and γ with
0 < η ≤ m2/L and γ > 0 such that the following hold.

• If ‖∇f(x(k))‖2 ≥ η, then

f(x(k+1))− f(x(k)) ≤ −γ. (9.32)

• If ‖∇f(x(k))‖2 < η, then the backtracking line search selects t(k) = 1 and

L

2m2
‖∇f(x(k+1))‖2 ≤

(
L

2m2
‖∇f(x(k))‖2

)2
. (9.33)

Let us analyze the implications of the second condition. Suppose that it
is satisfied for iteration k, i.e., ‖∇f(x(k))‖2 < η. Since η ≤ m2/L, we have
‖∇f(x(k+1))‖2 < η, i.e., the second condition is also satisfied at iteration k + 1.
Continuing recursively, we conclude that once the second condition holds, it will
hold for all future iterates, i.e., for all l ≥ k, we have ‖∇f(x(l))‖2 < η. Therefore
for all l ≥ k, the algorithm takes a full Newton step t = 1, and

L

2m2
‖∇f(x(l+1))‖2 ≤

(
L

2m2
‖∇f(x(l))‖2

)2
. (9.34)

Applying this inequality recursively, we find that for l ≥ k,

L

2m2
‖∇f(x(l))‖2 ≤

(
L

2m2
‖∇f(x(k))‖2

)2l−k
≤
(
1

2

)2l−k
,

and hence

f(x(l))− p⋆ ≤ 1
2m

‖∇f(x(l))‖22 ≤
2m3

L2

(
1

2

)2l−k+1
. (9.35)



9.5 Newton’s method 489

This last inequality shows that convergence is extremely rapid once the second
condition is satisfied. This phenomenon is called quadratic convergence. Roughly
speaking, the inequality (9.35) means that, after a sufficiently large number of
iterations, the number of correct digits doubles at each iteration.

The iterations in Newton’s method naturally fall into two stages. The second
stage, which occurs once the condition ‖∇f(x)‖2 ≤ η holds, is called the quadrat-
ically convergent stage. We refer to the first stage as the damped Newton phase,
because the algorithm can choose a step size t < 1. The quadratically convergent
stage is also called the pure Newton phase, since in these iterations a step size t = 1
is always chosen.

Now we can estimate the total complexity. First we derive an upper bound on
the number of iterations in the damped Newton phase. Since f decreases by at
least γ at each iteration, the number of damped Newton steps cannot exceed

f(x(0))− p⋆
γ

,

since if it did, f would be less than p⋆, which is impossible.
We can bound the number of iterations in the quadratically convergent phase

using the inequality (9.35). It implies that we must have f(x) − p⋆ ≤ ǫ after no
more than

log2 log2(ǫ0/ǫ)

iterations in the quadratically convergent phase, where ǫ0 = 2m
3/L2.

Overall, then, the number of iterations until f(x)− p⋆ ≤ ǫ is bounded above by
f(x(0))− p⋆

γ
+ log2 log2(ǫ0/ǫ). (9.36)

The term log2 log2(ǫ0/ǫ), which bounds the number of iterations in the quadrati-
cally convergent phase, grows extremely slowly with required accuracy ǫ, and can
be considered a constant for practical purposes, say five or six. (Six iterations of
the quadratically convergent stage gives an accuracy of about ǫ ≈ 5 · 10−20ǫ0.)

Not quite accurately, then, we can say that the number of Newton iterations
required to minimize f is bounded above by

f(x(0))− p⋆
γ

+ 6. (9.37)

A more precise statement is that (9.37) is a bound on the number of iterations to
compute an extremely good approximation of the solution.

Damped Newton phase

We now establish the inequality (9.32). Assume ‖∇f(x)‖2 ≥ η. We first derive a
lower bound on the step size selected by the line search. Strong convexity implies
that ∇2f(x) �MI on S, and therefore

f(x+ t∆xnt) ≤ f(x) + t∇f(x)T∆xnt + M‖∆xnt‖
2
2

2
t2

≤ f(x)− tλ(x)2 + M
2m

t2λ(x)2,



490 9 Unconstrained minimization

where we use (9.30) and

λ(x)2 = ∆xTnt∇2f(x)∆xnt ≥ m‖∆xnt‖22.

The step size tˆ = m/M satisfies the exit condition of the line search, since

f(x+ tˆ∆xnt) ≤ f(x)− m
2M

λ(x)2 ≤ f(x)− αtˆλ(x)2.

Therefore the line search returns a step size t ≥ βm/M , resulting in a decrease of
the objective function

f(x+)− f(x) ≤ −αtλ(x)2

≤ −αβ m
M

λ(x)2

≤ −αβ m
M2

‖∇f(x)‖22
≤ −αβη2 m

M2
,

where we use

λ(x)2 = ∇f(x)T∇2f(x)−1∇f(x) ≥ (1/M)‖∇f(x)‖22.

Therefore, (9.32) is satisfied with

γ = αβη2
m

M2
. (9.38)

Quadratically convergent phase

We now establish the inequality (9.33). Assume ‖∇f(x)‖2 < η. We first show that
the backtracking line search selects unit steps, provided

η ≤ 3(1− 2α)m
2

L
.

By the Lipschitz condition (9.31), we have, for t ≥ 0,

‖∇2f(x+ t∆xnt)−∇2f(x)‖2 ≤ tL‖∆xnt‖2,

and therefore∣∣∆xTnt (∇2f(x+ t∆xnt)−∇2f(x))∆xnt∣∣ ≤ tL‖∆xnt‖32.
With f˜(t) = f(x + t∆xnt), we have f˜

′′(t) = ∆xTnt∇2f(x + t∆xnt)∆xnt, so the
inequality above is

|f˜ ′′(t)− f˜ ′′(0)| ≤ tL‖∆xnt‖32.
We will use this inequality to determine an upper bound on f˜(t). We start with

f˜ ′′(t) ≤ f˜ ′′(0) + tL‖∆xnt‖32 ≤ λ(x)2 + t
L

m3/2
λ(x)3,



9.5 Newton’s method 491

where we use f˜ ′′(0) = λ(x)2 and λ(x)2 ≥ m‖∆xnt‖22. We integrate the inequality
to get

f˜ ′(t) ≤ f˜ ′(0) + tλ(x)2 + t2 L
2m3/2

λ(x)3

= −λ(x)2 + tλ(x)2 + t2 L
2m3/2

λ(x)3,

using f˜ ′(0) = −λ(x)2. We integrate once more to get

f˜(t) ≤ f˜(0)− tλ(x)2 + t2 1
2
λ(x)2 + t3

L

6m3/2
λ(x)3.

Finally, we take t = 1 to obtain

f(x+∆xnt) ≤ f(x)− 1
2
λ(x)2 +

L

6m3/2
λ(x)3. (9.39)

Now suppose ‖∇f(x)‖2 ≤ η ≤ 3(1− 2α)m2/L. By strong convexity, we have
λ(x) ≤ 3(1− 2α)m3/2/L,

and by (9.39) we have

f(x+∆xnt) ≤ f(x)− λ(x)2
(
1

2
− Lλ(x)

6m3/2

)
≤ f(x)− αλ(x)2
= f(x) + α∇f(x)T∆xnt,

which shows that the unit step t = 1 is accepted by the backtracking line search.
Let us now examine the rate of convergence. Applying the Lipschitz condition,

we have

‖∇f(x+)‖2 = ‖∇f(x+∆xnt)−∇f(x)−∇2f(x)∆xnt‖2
=

∥∥∥∥∫ 1
0

(∇2f(x+ t∆xnt)−∇2f(x))∆xnt dt∥∥∥∥
2

≤ L
2
‖∆xnt‖22

=
L

2
‖∇2f(x)−1∇f(x)‖22

≤ L
2m2

‖∇f(x)‖22,
i.e., the inequality (9.33).

In conclusion, the algorithm selects unit steps and satisfies the condition (9.33)
if ‖∇f(x(k))‖2 < η, where

η = min {1, 3(1− 2α)} m
2

L
.

Substituting this bound and (9.38) into (9.37), we find that the number of iterations
is bounded above by

6 +
M2L2/m5

αβmin{1, 9(1− 2α)2} (f(x
(0))− p⋆). (9.40)



492 9 Unconstrained minimization

x(0)

x(1)

Figure 9.19 Newton’s method for the problem in R2, with objective f given
in (9.20), and backtracking line search parameters α = 0.1, β = 0.7. Also

shown are the ellipsoids {x | ‖x−x(k)‖∇2f(x(k)) ≤ 1} at the first two iterates.

9.5.4 Examples

Example in R2

We first apply Newton’s method with backtracking line search on the test func-
tion (9.20), with line search parameters α = 0.1, β = 0.7. Figure 9.19 shows the
Newton iterates, and also the ellipsoids

{x | ‖x− x(k)‖∇2f(x(k)) ≤ 1}
for the first two iterates k = 0, 1. The method works well because these ellipsoids
give good approximations of the shape of the sublevel sets.

Figure 9.20 shows the error versus iteration number for the same example.
This plot shows that convergence to a very high accuracy is achieved in only five
iterations. Quadratic convergence is clearly apparent: The last step reduces the
error from about 10−5 to 10−10.

Example in R100

Figure 9.21 shows the convergence of Newton’s method with backtracking and exact
line search for a problem in R100. The objective function has the form (9.21), with
the same problem data and the same starting point as was used in figure 9.6. The
plot for the backtracking line search shows that a very high accuracy is attained in
eight iterations. Like the example in R2, quadratic convergence is clearly evident
after about the third iteration. The number of iterations in Newton’s method
with exact line search is only one smaller than with a backtracking line search.
This is also typical. An exact line search usually gives a very small improvement in
convergence of Newton’s method. Figure 9.22 shows the step sizes for this example.
After two damped steps, the steps taken by the backtracking line search are all full,
i.e., t = 1.

Experiments with the values of the backtracking parameters α and β reveal that
they have little effect on the performance of Newton’s method, for this example



9.5 Newton’s method 493

k

f
(x

(k
)
)
−
p
⋆

0 1 2 3 4 5
10−15

10−10

10−5

100

105

Figure 9.20 Error versus iteration k of Newton’s method for the problem
in R2. Convergence to a very high accuracy is achieved in five iterations.

k

f
(x

(k
)
)
−
p
⋆

exact l.s.

backtracking l.s.

0 2 4 6 8 10
10−15

10−10

10−5

100

105

Figure 9.21 Error versus iteration for Newton’s method for the problem in
R100. The backtracking line search parameters are α = 0.01, β = 0.5. Here
too convergence is extremely rapid: a very high accuracy is attained in only
seven or eight iterations. The convergence of Newton’s method with exact
line search is only one iteration faster than with backtracking line search.



494 9 Unconstrained minimization

k

st
ep

si
ze

t(
k
)

exact l.s.

backtracking l.s.

0 2 4 6 8
0

0.5

1

1.5

2

Figure 9.22 The step size t versus iteration for Newton’s method with back-
tracking and exact line search, applied to the problem in R100. The back-
tracking line search takes one backtracking step in the first two iterations.
After the first two iterations it always selects t = 1.

(and others). With α fixed at 0.01, and values of β varying between 0.2 and 1,
the number of iterations required varies between 8 and 12. With β fixed at 0.5,
the number of iterations is 8, for all values of α between 0.005 and 0.5. For these
reasons, most practical implementations use a backtracking line search with a small
value of α, such as 0.01, and a larger value of β, such as 0.5.

Example in R10000

In this last example we consider a larger problem, of the form

minimize −
n∑
i=1

log(1− x2i )−
m∑
i=1

log(bi − aTi x)

with m = 100000 and n = 10000. The problem data ai are randomly generated
sparse vectors. Figure 9.23 shows the convergence of Newton’s method with back-
tracking line search, with parameters α = 0.01, β = 0.5. The performance is very
similar to the previous convergence plots. A linearly convergent initial phase of
about 13 iterations is followed by a quadratically convergent phase, that achieves
a very high accuracy in 4 or 5 more iterations.

Affine invariance of Newton’s method

A very important feature of Newton’s method is that it is independent of linear
(or affine) changes of coordinates. Let x(k) be the kth iterate of Newton’s method,
applied to f : Rn → R. Suppose T ∈ Rn×n is nonsingular, and define f¯(y) =
f(Ty). If we use Newton’s method (with the same backtracking parameters) to



9.5 Newton’s method 495

k

f
(x

(k
)
)
−
p
⋆

0 5 10 15 20

10−5

100

105

Figure 9.23 Error versus iteration of Newton’s method, for a problem
in R10000. A backtracking line search with parameters α = 0.01, β = 0.5 is
used. Even for this large scale problem, Newton’s method requires only 18
iterations to achieve very high accuracy.

minimize f¯ , starting from y(0) = T−1x(0), then we have

Ty(k) = x(k)

for all k. In other words, Newton’s method is the same: The iterates are related
by the same change of coordinates. Even the stopping criterion is the same, since
the Newton decrement for f¯ at y(k) is the same as the Newton decrement for f at
x(k). This is in stark contrast to the gradient (or steepest descent) method, which
is strongly affected by changes of coordinates.

As an example, consider the family of problems given in (9.22), indexed by the
parameter γ, which affects the condition number of the sublevel sets. We observed
(in figures 9.7 and 9.8) that the gradient method slows to useless for values of γ
smaller than 0.05 or larger than 20. In contrast, Newton’s method (with α = 0.01,
β = 0.5) solves this problem (in fact, to a far higher accuracy) in nine iterations,
for all values of γ between 10−10 and 1010.

In a real implementation, with finite precision arithmetic, Newton’s method is
not exactly independent of affine changes of coordinates, or the condition number
of the sublevel sets. But we can say that condition numbers ranging up to very
large values such as 1010 do not adversely affect a real implementation of Newton’s
method. For the gradient method, a far smaller range of condition numbers can
be tolerated. While choice of coordinates (or condition number of sublevel sets) is
a first-order issue for gradient and steepest descent methods, it is a second-order
issue for Newton’s method; its only effect is in the numerical linear algebra required
to compute the Newton step.



496 9 Unconstrained minimization

Summary

Newton’s method has several very strong advantages over gradient and steepest
descent methods:

• Convergence of Newton’s method is rapid in general, and quadratic near x⋆.
Once the quadratic convergence phase is reached, at most six or so iterations
are required to produce a solution of very high accuracy.

• Newton’s method is affine invariant. It is insensitive to the choice of coordi-
nates, or the condition number of the sublevel sets of the objective.

• Newton’s method scales well with problem size. Its performance on problems
inR10000 is similar to its performance on problems inR10, with only a modest
increase in the number of steps required.

• The good performance of Newton’s method is not dependent on the choice
of algorithm parameters. In contrast, the choice of norm for steepest descent
plays a critical role in its performance.

The main disadvantage of Newton’s method is the cost of forming and storing
the Hessian, and the cost of computing the Newton step, which requires solving
a set of linear equations. We will see in §9.7 that in many cases it is possible to
exploit problem structure to substantially reduce the cost of computing the Newton
step.

Another alternative is provided by a family of algorithms for unconstrained op-
timization called quasi-Newton methods. These methods require less computational
effort to form the search direction, but they share some of the strong advantages
of Newton methods, such as rapid convergence near x⋆. Since quasi-Newton meth-
ods are described in many books, and tangential to our main theme, we will not
consider them in this book.

9.6 Self-concordance

There are two major shortcomings of the classical convergence analysis of Newton’s
method given in §9.5.3. The first is a practical one: The resulting complexity
estimates involve the three constants m, M , and L, which are almost never known
in practice. As a result, the bound (9.40) on the number of Newton steps required
is almost never known specifically, since it depends on three constants that are, in
general, not known. Of course the convergence analysis and complexity estimate
are still conceptually useful.

The second shortcoming is that while Newton’s method is affinely invariant, the
classical analysis of Newton’s method is very much dependent on the coordinate
system used. If we change coordinates the constants m, M , and L all change. If
for no reason other than aesthetic, we should seek an analysis of Newton’s method
that is, like the method itself, independent of affine changes of coordinates. In



9.6 Self-concordance 497

other words, we seek an alternative to the assumptions

mI � ∇2f(x) �MI, ‖∇2f(x)−∇2f(y)‖2 ≤ L‖x− y‖2,
that is independent of affine changes of coordinates, and also allows us to analyze
Newton’s method.

A simple and elegant assumption that achieves this goal was discovered by
Nesterov and Nemirovski, who gave the name self-concordance to their condition.
Self-concordant functions are important for several reasons.

• They include many of the logarithmic barrier functions that play an impor-
tant role in interior-point methods for solving convex optimization problems.

• The analysis of Newton’s method for self-concordant functions does not de-
pend on any unknown constants.

• Self-concordance is an affine-invariant property, i.e., if we apply a linear
transformation of variables to a self-concordant function, we obtain a self-
concordant function. Therefore the complexity estimate that we obtain for
Newton’s method applied to a self-concordant function is independent of
affine changes of coordinates.

9.6.1 Definition and examples

Self-concordant functions on R

We start by considering functions on R. A convex function f : R → R is self-
concordant if

|f ′′′(x)| ≤ 2f ′′(x)3/2 (9.41)
for all x ∈ dom f . Since linear and (convex) quadratic functions have zero third
derivative, they are evidently self-concordant. Some more interesting examples are
given below.

Example 9.3 Logarithm and entropy.

• Negative logarithm. The function f(x) = − log x is self-concordant. Using
f ′′(x) = 1/x2, f ′′′(x) = −2/x3, we find that

|f ′′′(x)|
2f ′′(x)3/2

=
2/x3

2(1/x2)3/2
= 1,

so the defining inequality (9.41) holds with equality.

• Negative entropy plus negative logarithm. The function f(x) = x log x− log x is
self-concordant. To verify this, we use

f ′′(x) =
x+ 1

x2
, f ′′′(x) = −x+ 2

x3

to obtain
|f ′′′(x)|
2f ′′(x)3/2

=
x+ 2

2(x+ 1)3/2
.



498 9 Unconstrained minimization

The function on the righthand side is maximized on R+ by x = 0, where its
value is 1.

The negative entropy function by itself is not self-concordant; see exercise 11.13.

We should make two important remarks about the self-concordance defini-
tion (9.41). The first concerns the mysterious constant 2 that appears in the
definition. In fact, this constant is chosen for convenience, in order to simplify the
formulas later on; any other positive constant could be used instead. Suppose, for
example, that the convex function f : R→ R satisfies

|f ′′′(x)| ≤ kf ′′(x)3/2 (9.42)

where k is some positive constant. Then the function f˜(x) = (k2/4)f(x) satisfies

|f˜ ′′′(x)| = (k2/4)|f ′′′(x)|
≤ (k3/4)f ′′(x)3/2

= (k3/4)
(
(4/k2)f˜ ′′(x)

)3/2
= 2f˜ ′′(x)3/2

and therefore is self-concordant. This shows that a function that satisfies (9.42)
for some positive k can be scaled to satisfy the standard self-concordance inequal-
ity (9.41). So what is important is that the third derivative of the function is
bounded by some multiple of the 3/2-power of its second derivative. By appropri-
ately scaling the function, we can change the multiple to the constant 2.

The second comment is a simple calculation that shows why self-concordance
is so important: it is affine invariant. Suppose we define the function f˜ by f˜(y) =
f(ay + b), where a 6= 0. Then f˜ is self-concordant if and only if f is. To see this,
we substitute

f˜ ′′(y) = a2f ′′(x), f˜ ′′′(y) = a3f ′′′(x),

where x = ay + b, into the self-concordance inequality for f˜ , i.e., |f˜ ′′′(y)| ≤
2f˜ ′′(y)3/2, to obtain

|a3f ′′′(x)| ≤ 2(a2f ′′(x))3/2,

which (after dividing by a3) is the self-concordance inequality for f . Roughly
speaking, the self-concordance condition (9.41) is a way to limit the third derivative
of a function, in a way that is independent of affine coordinate changes.

Self-concordant functions on Rn

We now consider functions on Rn with n > 1. We say a function f : Rn → R
is self-concordant if it is self-concordant along every line in its domain, i.e., if the
function f˜(t) = f(x + tv) is a self-concordant function of t for all x ∈ dom f and
for all v.



9.6 Self-concordance 499

9.6.2 Self-concordant calculus

Scaling and sum

Self-concordance is preserved by scaling by a factor exceeding one: If f is self-
concordant and a ≥ 1, then af is self-concordant. Self-concordance is also preserved
by addition: If f1, f2 are self-concordant, then f1 + f2 is self-concordant. To show
this, it is sufficient to consider functions f1, f2 : R→ R. We have

|f ′′′1 (x) + f ′′′2 (x)| ≤ |f ′′′1 (x)|+ |f ′′′2 (x)|
≤ 2(f ′′1 (x)3/2 + f ′′2 (x)3/2)
≤ 2(f ′′1 (x) + f ′′2 (x))3/2.

In the last step we use the inequality

(u3/2 + v3/2)2/3 ≤ u+ v,
which holds for u, v ≥ 0.

Composition with affine function

If f : Rn → R is self-concordant, and A ∈ Rn×m, b ∈ Rn, then f(Ax + b) is
self-concordant.

Example 9.4 Log barrier for linear inequalities. The function

f(x) = −
m∑
i=1

log(bi − aTi x),

with dom f = {x | aTi x < bi, i = 1, . . . ,m}, is self-concordant. Each term − log(bi −
aTi x) is the composition of − log y with the affine transformation y = bi − aTi x, and
hence self-concordant. Therefore the sum is also self-concordant.

Example 9.5 Log-determinant. The function f(X) = − log detX is self-concordant
on dom f = Sn++. To show this, we consider the function f˜(t) = f(X + tV ), where
X ≻ 0 and V ∈ Sn. It can be expressed as

f˜(t) = − log det(X1/2(I + tX−1/2V X−1/2)X1/2)
= − log detX − log det(I + tX−1/2V X−1/2)

= − log detX −
n∑
i=1

log(1 + tλi)

where λi are the eigenvalues of X
−1/2V X−1/2. Each term − log(1 + tλi) is a self-

concordant function of t, so the sum, f˜ , is self-concordant. It follows that f is
self-concordant.

Example 9.6 Log of concave quadratic. The function

f(x) = − log(xTPx+ qTx+ r),



500 9 Unconstrained minimization

where P ∈ −Sn+, is self-concordant on
dom f = {x | xTPx+ qTx+ r > 0}.

To show this, it suffices to consider the case n = 1 (since by restricting f to a line,
the general case reduces to the n = 1 case). We can then express f as

f(x) = − log(px2 + qx+ r) = − log (−p(x− a)(b− x))
where dom f = (a, b) (i.e., a and b are the roots of px2+qx+r). Using this expression
we have

f(x) = − log(−p)− log(x− a)− log(b− x),
which establishes self-concordance.

Composition with logarithm

Let g : R→ R be a convex function with dom g = R++, and

|g′′′(x)| ≤ 3g
′′(x)

x
(9.43)

for all x. Then
f(x) = − log(−g(x))− log x

is self-concordant on {x | x > 0, g(x) < 0}. (For a proof, see exercise 9.14.)
The condition (9.43) is homogeneous and preserved under addition. It is sat-

isfied by all (convex) quadratic functions, i.e., functions of the form ax2 + bx+ c,
where a ≥ 0. Therefore if (9.43) holds for a function g, then it holds for the function
g(x) + ax2 + bx+ c, where a ≥ 0.

Example 9.7 The following functions g satisfy the condition (9.43).

• g(x) = −xp for 0 < p ≤ 1.
• g(x) = − log x.
• g(x) = x log x.
• g(x) = xp for −1 ≤ p ≤ 0.
• g(x) = (ax+ b)2/x.

It follows that in each case, the function f(x) = − log(−g(x))−log x is self-concordant.
More generally, the function f(x) = − log(−g(x) − ax2 − bx − c) − log x is self-
concordant on its domain,

{x | x > 0, g(x) + ax2 + bx+ c < 0},
provided a ≥ 0.

Example 9.8 The composition with logarithm rule allows us to show self-concordance
of the following functions.

• f(x, y) = − log(y2 − xTx) on {(x, y) | ‖x‖2 < y}.
• f(x, y) = −2 log y − log(y2/p − x2), with p ≥ 1, on {(x, y) ∈ R2 | |x|p < y}.
• f(x, y) = − log y − log(log y − x) on {(x, y) | ex < y}.

We leave the details as an exercise (exercise 9.15).



9.6 Self-concordance 501

9.6.3 Properties of self-concordant functions

In §9.1.2 we used strong convexity to derive bounds on the suboptimality of a point
x in terms of the norm of the gradient at x. For strictly convex self-concordant
functions, we can obtain similar bounds in terms of the Newton decrement

λ(x) =
(∇f(x)T∇2f(x)−1∇f(x))1/2 .

(It can be shown that the Hessian of a strictly convex self-concordant function is
positive definite everywhere; see exercise 9.17.) Unlike the bounds based on the
norm of the gradient, the bounds based on the Newton decrement are not affected
by an affine change of coordinates.

For future reference we note that the Newton decrement can also be expressed
as

λ(x) = sup
v 6=0

−vT∇f(x)
(vT∇2f(x)v)1/2

(see exercise 9.9). In other words, we have

−vT∇f(x)
(vT∇2f(x)v)1/2 ≤ λ(x) (9.44)

for any nonzero v, with equality for v = ∆xnt.

Upper and lower bounds on second derivatives

Suppose f : R→ R is a strictly convex self-concordant function. We can write the
self-concordance inequality (9.41) as∣∣∣∣ ddt (f ′′(t)−1/2)

∣∣∣∣ ≤ 1 (9.45)
for all t ∈ dom f (see exercise 9.16). Assuming t ≥ 0 and the interval between 0
and t is in dom f , we can integrate (9.45) between 0 and t to obtain

−t ≤
∫ t
0

d

dτ

(
f ′′(τ)−1/2

)
dτ ≤ t,

i.e., −t ≤ f ′′(t)−1/2− f ′′(0)−1/2 ≤ t. From this we obtain lower and upper bounds
on f ′′(t):

f ′′(0)(
1 + tf ′′(0)1/2

)2 ≤ f ′′(t) ≤ f ′′(0)(
1− tf ′′(0)1/2)2 . (9.46)

The lower bound is valid for all nonnegative t ∈ dom f ; the upper bound is valid
if t ∈ dom f and 0 ≤ t < f ′′(0)−1/2.

Bound on suboptimality

Let f : Rn → R be a strictly convex self-concordant function, and let v be a
descent direction (i.e., any direction satisfying vT∇f(x) < 0, not necessarily the



502 9 Unconstrained minimization

Newton direction). Define f˜ : R → R as f˜(t) = f(x + tv). By definition, the
function f˜ is self-concordant.

Integrating the lower bound in (9.46) yields a lower bound on f˜ ′(t):

f˜ ′(t) ≥ f˜ ′(0) + f˜ ′′(0)1/2 − f˜
′′(0)1/2

1 + tf˜ ′′(0)1/2
. (9.47)

Integrating again yields a lower bound on f˜(t):

f˜(t) ≥ f˜(0) + tf˜ ′(0) + tf˜ ′′(0)1/2 − log(1 + tf˜ ′′(0)1/2). (9.48)
The righthand side reaches its minimum at

t¯ =
−f˜ ′(0)

f˜ ′′(0) + f˜ ′′(0)1/2f˜ ′(0)
,

and evaluating at t¯ provides a lower bound on f˜ :

inf
t≥0

f˜(t) ≥ f˜(0) + t¯f˜ ′(0) + t¯f˜ ′′(0)1/2 − log(1 + t¯f˜ ′′(0)1/2)

= f˜(0)− f˜ ′(0)f˜ ′′(0)−1/2 + log(1 + f˜ ′(0)f˜ ′′(0)−1/2).
The inequality (9.44) can be expressed as

λ(x) ≥ −f˜ ′(0)f˜ ′′(0)−1/2
(with equality when v = ∆xnt), since we have

f˜ ′(0) = vT∇f(x), f˜ ′′(0) = vT∇2f(x)v.
Now using the fact that u+ log(1− u) is a monotonically decreasing function of u,
and the inequality above, we get

inf
t≥0

f˜(t) ≥ f˜(0) + λ(x) + log(1− λ(x)).

This inequality holds for any descent direction v. Therefore

p⋆ ≥ f(x) + λ(x) + log(1− λ(x)) (9.49)
provided λ(x) < 1. The function − (λ+ log(1− λ)) is plotted in figure 9.24. It
satisfies

− (λ+ log(1− λ)) ≈ λ2/2,
for small λ, and the bound

− (λ+ log(1− λ)) ≤ λ2
for λ ≤ 0.68. Thus, we have the bound on suboptimality

p⋆ ≥ f(x)− λ(x)2, (9.50)
valid for λ(x) ≤ 0.68.

Recall that λ(x)2/2 is the estimate of f(x)− p⋆, based on the quadratic model
at x; the inequality (9.50) shows that for self-concordant functions, doubling this
estimate gives us a provable bound. In particular, it shows that for self-concordant
functions, we can use the stopping criterion

λ(x)2 ≤ ǫ,
(where ǫ < 0.682), and guarantee that on exit f(x)− p⋆ ≤ ǫ.



9.6 Self-concordance 503

0 0.2 0.4 0.6 0.8 1
0

0.2

0.4

0.6

0.8

Figure 9.24 The solid line is the function −(λ+log(1−λ)), which for small λ
is approximately λ2/2. The dashed line shows λ2, which is an upper bound
in the interval 0 ≤ λ ≤ 0.68.

9.6.4 Analysis of Newton’s method for self-concordant functions

We now analyze Newton’s method with backtracking line search, when applied to
a strictly convex self-concordant function f . As before, we assume that a starting
point x(0) is known, and that the sublevel set S = {x | f(x) ≤ f(x(0))} is closed.
We also assume that f is bounded below. (This implies that f has a minimizer x⋆;
see exercise 9.19.)

The analysis is very similar to the classical analysis given in §9.5.2, except that
we use self-concordance as the basic assumption instead of strong convexity and
the Lipschitz condition on the Hessian, and the Newton decrement will play the
role of the norm of the gradient. We will show that there are numbers η and γ > 0,
with 0 < η ≤ 1/4, that depend only on the line search parameters α and β, such
that the following hold:

• If λ(x(k)) > η, then
f(x(k+1))− f(x(k)) ≤ −γ. (9.51)

• If λ(x(k)) ≤ η, then the backtracking line search selects t = 1 and

2λ(x(k+1)) ≤
(
2λ(x(k))

)2
. (9.52)

These are the analogs of (9.32) and (9.33). As in §9.5.3, the second condition can
be applied recursively, so we can conclude that for all l ≥ k, we have λ(x(l)) ≤ η,
and

2λ(x(l)) ≤
(
2λ(x(k))

)2l−k
≤ (2η)2l−k ≤

(
1

2

)2l−k
.

As a consequence, for all l ≥ k,

f(x(l))− p⋆ ≤ λ(x(l))2 ≤ 1
4

(
1

2

)2l−k+1
≤
(
1

2

)2l−k+1
,



504 9 Unconstrained minimization

and hence f(x(l))− p⋆ ≤ ǫ if l − k ≥ log2 log2(1/ǫ).
The first inequality implies that the damped phase cannot require more than

(f(x(0)) − p⋆)/γ steps. Thus the total number of iterations required to obtain an
accuracy f(x)− p⋆ ≤ ǫ, starting at a point x(0), is bounded by

f(x(0))− p⋆
γ

+ log2 log2(1/ǫ). (9.53)

This is the analog of the bound (9.36) in the classical analysis of Newton’s method.

Damped Newton phase

Let f˜(t) = f(x+ t∆xnt), so we have

f˜ ′(0) = −λ(x)2, f˜ ′′(0) = λ(x)2.

If we integrate the upper bound in (9.46) twice, we obtain an upper bound for f˜(t):

f˜(t) ≤ f˜(0) + tf˜ ′(0)− tf˜ ′′(0)1/2 − log
(
1− tf˜ ′′(0)1/2

)
= f˜(0)− tλ(x)2 − tλ(x)− log(1− tλ(x)), (9.54)

valid for 0 ≤ t < 1/λ(x).
We can use this bound to show the backtracking line search always results in a

step size t ≥ β/(1 + λ(x)). To prove this we note that the point tˆ = 1/(1 + λ(x))
satisfies the exit condition of the line search:

f˜(tˆ) ≤ f˜(0)− tˆλ(x)2 − tˆλ(x)− log(1− tˆλ(x))
= f˜(0)− λ(x) + log(1 + λ(x))
≤ f˜(0)− α λ(x)

2

1 + λ(x)

= f˜(0)− αλ(x)2tˆ.

The second inequality follows from the fact that

−x+ log(1 + x) + x
2

2(1 + x)
≤ 0

for x ≥ 0. Since t ≥ β/(1 + λ(x)), we have

f˜(t)− f˜(0) ≤ −αβ λ(x)
2

1 + λ(x)
,

so (9.51) holds with

γ = αβ
η2

1 + η
.



9.6 Self-concordance 505

Quadratically convergent phase

We will show that we can take

η = (1− 2α)/4,

(which satisfies 0 < η < 1/4, since 0 < α < 1/2), i.e., if λ(x(k)) ≤ (1− 2α)/4, then
the backtracking line search accepts the unit step and (9.52) holds.

We first note that the upper bound (9.54) implies that a unit step t = 1 yields a
point in dom f if λ(x) < 1. Moreover, if λ(x) ≤ (1− 2α)/2, we have, using (9.54),

f˜(1) ≤ f˜(0)− λ(x)2 − λ(x)− log(1− λ(x))
≤ f˜(0)− 1

2
λ(x)2 + λ(x)3

≤ f˜(0)− αλ(x)2,

so the unit step satisfies the condition of sufficient decrease. (The second line
follows from the fact that −x− log(1− x) ≤ 12x2 + x3 for 0 ≤ x ≤ 0.81.)

The inequality (9.52) follows from the following fact, proved in exercise 9.18. If
λ(x) < 1, and x+ = x−∇2f(x)−1∇f(x), then

λ(x+) ≤ λ(x)
2

(1− λ(x))2 . (9.55)

In particular, if λ(x) ≤ 1/4,
λ(x+) ≤ 2λ(x)2,

which proves that (9.52) holds when λ(x(k)) ≤ η.

The final complexity bound

Putting it all together, the bound (9.53) on the number of Newton iterations be-
comes

f(x(0))− p⋆
γ

+log2 log2(1/ǫ) =
20− 8α

αβ(1− 2α)2 (f(x
(0))−p⋆)+ log2 log2(1/ǫ). (9.56)

This expression depends only on the line search parameters α and β, and the final
accuracy ǫ. Moreover the term involving ǫ can be safely replaced by the constant
six, so the bound really depends only on α and β. For typical values of α and β, the
constant that scales f(x(0))− p⋆ is on the order of several hundred. For example,
with α = 0.1, β = 0.8, the scaling factor is 375. With tolerance ǫ = 10−10, we
obtain the bound

375(f(x(0))− p⋆) + 6. (9.57)
We will see that this bound is fairly conservative, but does capture what appears
to be the general form of the worst-case number of Newton steps required. A more
refined analysis, such as the one originally given by Nesterov and Nemirovski, gives
a similar bound, with a substantially smaller constant scaling f(x(0))− p⋆.



506 9 Unconstrained minimization

f(x(0))− p⋆

it
er
at
io
n
s

0 5 10 15 20 25 30 35
0

5

10

15

20

25

Figure 9.25 Number of Newton iterations required to minimize self-
concordant functions versus f(x(0)) − p⋆. The function f has the form
f(x) = −∑m

i=1
log(bi − aTi x), where the problem data ai and b are ran-

domly generated. The circles show problems with m = 100, n = 50; the
squares show problems with m = 1000, n = 500; and the diamonds show
problems with m = 1000, n = 50. Fifty instances of each are shown.

9.6.5 Discussion and numerical examples

A family of self-concordant functions

It is interesting to compare the upper bound (9.57) with the actual number of
iterations required to minimize a self-concordant function. We consider a family of
problems of the form

f(x) = −
m∑
i=1

log(bi − aTi x).

The problem data ai and b were generated as follows. For each problem instance,
the coefficients of ai were generated from independent normal distributions with
mean zero and unit variance, and the coefficients b were generated from a uniform
distribution on [0, 1]. Problem instances which were unbounded below were dis-
carded. For each problem we first compute x⋆. We then generate a starting point
by choosing a random direction v, and taking x(0) = x⋆ + sv, where s is chosen so
that f(x(0)) − p⋆ has a prescribed value between 0 and 35. (We should point out
that starting points with values f(x(0))− p⋆ = 10 or higher are actually very close
to the boundary of the polyhedron.) We then minimize the function using New-
ton’s method with a backtracking line search with parameters α = 0.1, β = 0.8,
and tolerance ǫ = 10−10.

Figure 9.25 shows the number of Newton iterations required versus f(x(0))−p⋆
for 150 problem instances. The circles show 50 problems with m = 100, n = 50;
the squares show 50 problems with m = 1000, n = 500; and the diamonds show 50
problems with m = 1000, n = 50.



9.6 Self-concordance 507

For the values of the backtracking parameters used, the complexity bound found
above is

375(f(x(0))− p⋆) + 6, (9.58)

clearly a much larger value than the number of iterations required (for these 150
instances). The plot suggests that there is a valid bound of the same form, but
with a much smaller constant (say, around 1.5) scaling f(x(0)) − p⋆. Indeed, the
expression

f(x(0))− p⋆ + 6

is not a bad gross predictor of the number of Newton steps required, although it is
clearly not the only factor. First, there are plenty of problems instances where the
number of Newton steps is somewhat smaller, which correspond, we can guess, to
‘lucky’ starting points. Note also that for the larger problems, with 500 variables
(represented by the squares), there seem to be even more cases where the number
of Newton steps is unusually small.

We should mention here that the problem family we study is not just self-
concordant, but in fact minimally self-concordant, by which we mean that αf
is not self-concordant for α < 1. Hence, the bound (9.58) cannot be improved
by simply scaling f . (The function f(x) = −20 log x is an example of a self-
concordant function which is not minimally self-concordant, since (1/20)f is also
self-concordant.)

Practical importance of self-concordance

We have already observed that Newton’s method works in general very well for
strongly convex objective functions. We can justify this vague statement empir-
ically, and also using the classical analysis of Newton’s method, which yields a
complexity bound, but one that depends on several constants that are almost al-
ways unknown.

For self-concordant functions we can say somewhat more. We have a complexity
bound that is completely explicit, and does not depend on any unknown constants.
Empirical studies suggest that this bound can be tightened considerably, but its
general form, a small constant plus a multiple of f(x(0))− p⋆, seems to predict, at
least crudely, the number of Newton steps required to minimize an approximately
minimally self-concordant function.

It is not yet clear whether self-concordant functions are in practice more easily
minimized by Newton’s method than non-self-concordant functions. (It is not
even clear how one would make this statement precise.) At the moment, we can
say that self-concordant functions are a class of functions for which we can say
considerably more about the complexity of Newton’s method than is the case for
non-self-concordant functions.



508 9 Unconstrained minimization

9.7 Implementation

In this section we discuss some of the issues that arise in implementing an un-
constrained minimization algorithm. We refer the reader to appendix C for more
details on numerical linear algebra.

9.7.1 Pre-computation for line searches

In the simplest implementation of a line search, f(x + t∆x) is evaluated for each
value of t in the same way that f(z) is evaluated for any z ∈ dom f . But in some
cases we can exploit the fact that f (and its derivatives, in an exact line search) are
to be evaluated at many points along the ray {x+ t∆x | t ≥ 0} to reduce the total
computational effort. This usually requires some pre-computation, which is often
on the same order as computing f at any point, after which f (and its derivatives)
can be computed more efficiently along the ray.

Suppose that x ∈ dom f and ∆x ∈ Rn, and define f˜ as f restricted to the line
or ray determined by x and ∆x, i.e., f˜(t) = f(x + t∆x). In a backtracking line
search we must evaluate f˜ for several, and possibly many, values of t; in an exact
line search method we must evaluate f˜ and one or more derivatives at a number of
values of t. In the simple method described above, we evaluate f˜(t) by first forming
z = x + t∆x, and then evaluating f(z). To evaluate f˜ ′(t), we form z = x + t∆x,
then evaluate ∇f(z), and then compute f˜ ′(t) = ∇f(z)T∆x. In some representative
examples below we show how f˜ can be computed at a number of values of t more
efficiently.

Composition with an affine function

A very general case in which pre-computation can speed up the line search process
occurs when the objective has the form f(x) = φ(Ax+ b), where A ∈ Rp×n, and φ
is easy to evaluate (for example, separable). To evaluate f˜(t) = f(x + t∆x) for k
values of t using the simple approach, we form A(x+ t∆x) + b for each value of t
(which costs 2kpn flops), and then evaluate φ(A(x+ t∆x) + b) for each value of t.
This can be done more efficiently by first computing Ax+ b and A∆x (4pn flops),
then forming A(x+ t∆x) + b for each value of t using

A(x+ t∆x) + b = (Ax+ b) + t(A∆x),

which costs 2kp flops. The total cost, keeping only the dominant terms, is 4pn+2kp
flops, compared to 2kpn for the simple method.

Analytic center of a linear matrix inequality

Here we give an example that is more specific, and more complete. We consider
the problem (9.6) of computing the analytic center of a linear matrix inequality,
i.e., minimizing log detF (x)−1, where x ∈ Rn and F : Rn → Sp is affine. Along
the line through x with direction ∆x we have

f˜(t) = log det(F (x+ t∆x))−1 = − log det(A+ tB)



9.7 Implementation 509

where
A = F (x), B = ∆x1F1 + · · ·+∆xnFn ∈ Sp.

Since A ≻ 0, it has a Cholesky factorization A = LLT , where L is lower triangular
and nonsingular. Therefore we can express f˜ as

f˜(t) = − log det (L(I + tL−1BL−T )LT ) = − log detA− p∑
i=1

log(1 + tλi) (9.59)

where λ1, . . . , λp are the eigenvalues of L
−1BL−T . Once these eigenvalues are

computed, we can evaluate f˜(t), for any t, with 4p simple arithmetic computations,
by using the formula on the right hand side of (9.59). We can evaluate f˜ ′(t) (and
similarly, any higher derivative) in 4p operations, using the formula

f˜ ′(t) = −
p∑
i=1

λi
1 + tλi

.

Let us compare the two methods for carrying out a line search, assuming that
we need to evaluate f(x + t∆x) for k values of t. In the simple method, for each
value of t we form F (x+t∆x), and then evaluate f(x+t∆x) as − log detF (x+t∆x).
For example, we can find the Cholesky factorization of F (x + t∆x) = LLT , and
then evaluate

− log detF (x+ t∆x) = −2
p∑
i=1

logLii.

The cost is np2 to form F (x + t∆x), plus (1/3)p3 for the Cholesky factorization.
Therefore the total cost of the line search is

k(np2 + (1/3)p3) = knp2 + (1/3)kp3.

Using the method outlined above, we first form A, which costs np2, and factor
it, which costs (1/3)p3. We also form B (which costs np2), and L−1BL−T , which
costs 2p3. The eigenvalues of this matrix are then computed, at a cost of about
(4/3)p3 flops. This pre-computation requires a total of 2np2+(11/3)p3 flops. After
finishing this pre-computation, we can now evaluate f˜(t) for each value of t at a
cost of 4p flops. The total cost is then

2np2 + (11/3)p3 + 4kp.

Assuming k is small compared to p(2n+(11/3)p), this means the entire line search
can be carried out at an effort comparable to simply evaluating f . Depending on
the values of k, p, and n, the savings over the simple method can be as large as
order k.

9.7.2 Computing the Newton step

In this section we briefly describe some of the issues that arise in implementing
Newton’s method. In most cases, the work of computing the Newton step ∆xnt



510 9 Unconstrained minimization

dominates the work involved in the line search. To compute the Newton step
∆xnt, we first evaluate and form the Hessian matrix H = ∇2f(x) and the gradient
g = ∇f(x) at x. Then we solve the system of linear equations H∆xnt = −g to
find the Newton step. This set of equations is sometimes called the Newton system
(since its solution gives the Newton step) or the normal equations, since the same
type of equation arises in solving a least-squares problem (see §9.1.1).

While a general linear equation solver can be used, it is better to use methods
that take advantage of the symmetry and positive definiteness of H. The most
common approach is to form the Cholesky factorization of H, i.e., to compute a
lower triangular matrix L that satisfies LLT = H (see §C.3.2). We then solve Lw =
−g by forward substitution, to obtain w = −L−1g, and then solve LT∆xnt = w by
back substitution, to obtain

∆xnt = L
−Tw = −L−TL−1g = −H−1g.

We can compute the Newton decrement as λ2 = −∆xTntg, or use the formula
λ2 = gTH−1g = ‖L−1g‖22 = ‖w‖22.

If a dense (unstructured) Cholesky factorization is used, the cost of the forward and
back substitution is dominated by the cost of the Cholesky factorization, which is
(1/3)n3 flops. The total cost of computing the Newton step ∆xnt is thus F+(1/3)n

3

flops, where F is the cost of forming H and g.
It is often possible to solve the Newton system H∆xnt = −g more efficiently,

by exploiting special structure in H, such as band structure or sparsity. In this
context, ‘structure of H’ means structure that is the same for all x. For example,
when we say that ‘H is tridiagonal’ we mean that for every x ∈ dom f , ∇2f(x) is
tridiagonal.

Band structure

If the Hessian H is banded with bandwidth k, i.e., Hij = 0 for |i− j| > k, then the
banded Cholesky factorization can be used, as well as banded forward and back
substitutions. The cost of computing the Newton step ∆xnt = −H−1g is then
F +nk2 flops (assuming k ≪ n), compared to F +(1/3)n3 for a dense factorization
and substitution method.

The Hessian band structure condition

∇2f(x)ij = ∂
2f(x)

∂xi∂xj
= 0 for |i− j| > k,

for all x ∈ dom f , has an interesting interpretation in terms of the objective
function f . Roughly speaking it means that in the objective function, each variable
xi couples nonlinearly only to the 2k + 1 variables xj , j = i − k, . . . , i + k. This
occurs when f has the partial separability form

f(x) = ψ1(x1, . . . , xk+1) + ψ2(x2, . . . , xk+2) + · · ·+ ψn−k(xn−k, . . . , xn),
where ψi : R

k+1 → R. In other words, f can be expressed as a sum of functions
of k consecutive variables.



9.7 Implementation 511

Example 9.9 Consider the problem of minimizing f : Rn → R, which has the form

f(x) = ψ1(x1, x2) + ψ2(x2, x3) + · · ·+ ψn−1(xn−1, xn),

where ψi : R
2 → R are convex and twice differentiable. Because of this form, the

Hessian ∇2f is tridiagonal, since ∂2f/∂xi∂xj = 0 for |i− j| > 1. (And conversely, if
the Hessian of